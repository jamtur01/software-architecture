
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dotcloud/docker/api.go</option>
				
				<option value="file1">github.com/dotcloud/docker/api_params.go</option>
				
				<option value="file2">github.com/dotcloud/docker/buildfile.go</option>
				
				<option value="file3">github.com/dotcloud/docker/commands.go</option>
				
				<option value="file4">github.com/dotcloud/docker/config.go</option>
				
				<option value="file5">github.com/dotcloud/docker/container.go</option>
				
				<option value="file6">github.com/dotcloud/docker/graph.go</option>
				
				<option value="file7">github.com/dotcloud/docker/image.go</option>
				
				<option value="file8">github.com/dotcloud/docker/links.go</option>
				
				<option value="file9">github.com/dotcloud/docker/lxc_template.go</option>
				
				<option value="file10">github.com/dotcloud/docker/network.go</option>
				
				<option value="file11">github.com/dotcloud/docker/opts.go</option>
				
				<option value="file12">github.com/dotcloud/docker/runtime.go</option>
				
				<option value="file13">github.com/dotcloud/docker/server.go</option>
				
				<option value="file14">github.com/dotcloud/docker/sorter.go</option>
				
				<option value="file15">github.com/dotcloud/docker/state.go</option>
				
				<option value="file16">github.com/dotcloud/docker/tags.go</option>
				
				<option value="file17">github.com/dotcloud/docker/utils.go</option>
				
				<option value="file18">github.com/dotcloud/docker/version.go</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package docker

import (
        "bufio"
        "bytes"
        "code.google.com/p/go.net/websocket"
        "encoding/base64"
        "encoding/json"
        "expvar"
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/auth"
        "github.com/dotcloud/docker/pkg/systemd"
        "github.com/dotcloud/docker/utils"
        "github.com/gorilla/mux"
        "io"
        "io/ioutil"
        "log"
        "mime"
        "net"
        "net/http"
        "net/http/pprof"
        "os"
        "os/exec"
        "regexp"
        "strconv"
        "strings"
)

const (
        APIVERSION        = 1.8
        DEFAULTHTTPHOST   = "127.0.0.1"
        DEFAULTHTTPPORT   = 4243
        DEFAULTUNIXSOCKET = "/var/run/docker.sock"
)

type HttpApiFunc func(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error

func hijackServer(w http.ResponseWriter) (io.ReadCloser, io.Writer, error) <span class="cov0" title="0">{
        conn, _, err := w.(http.Hijacker).Hijack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        // Flush the options to make sure the client sets the raw mode
        <span class="cov0" title="0">conn.Write([]byte{})
        return conn, conn, nil</span>
}

//If we don't do this, POST method without Content-type (even with empty body) will fail
func parseForm(r *http.Request) error <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if err := r.ParseForm(); err != nil &amp;&amp; !strings.HasPrefix(err.Error(), "mime:") </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func parseMultipartForm(r *http.Request) error <span class="cov0" title="0">{
        if err := r.ParseMultipartForm(4096); err != nil &amp;&amp; !strings.HasPrefix(err.Error(), "mime:") </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func httpError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        statusCode := http.StatusInternalServerError
        // FIXME: this is brittle and should not be necessary.
        // If we need to differentiate between different possible error types, we should
        // create appropriate error types with clearly defined meaning.
        if strings.Contains(err.Error(), "No such") </span><span class="cov0" title="0">{
                statusCode = http.StatusNotFound
        }</span> <span class="cov0" title="0">else if strings.Contains(err.Error(), "Bad parameter") </span><span class="cov0" title="0">{
                statusCode = http.StatusBadRequest
        }</span> <span class="cov0" title="0">else if strings.Contains(err.Error(), "Conflict") </span><span class="cov0" title="0">{
                statusCode = http.StatusConflict
        }</span> <span class="cov0" title="0">else if strings.Contains(err.Error(), "Impossible") </span><span class="cov0" title="0">{
                statusCode = http.StatusNotAcceptable
        }</span> <span class="cov0" title="0">else if strings.Contains(err.Error(), "Wrong login/password") </span><span class="cov0" title="0">{
                statusCode = http.StatusUnauthorized
        }</span> <span class="cov0" title="0">else if strings.Contains(err.Error(), "hasn't been activated") </span><span class="cov0" title="0">{
                statusCode = http.StatusForbidden
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.Errorf("HTTP Error: statusCode=%d %s", statusCode, err.Error())
                http.Error(w, err.Error(), statusCode)
        }</span>
}

func writeJSON(w http.ResponseWriter, code int, v interface{}) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        w.Write(b)

        return nil</span>
}

func getBoolParam(value string) (bool, error) <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">ret, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("Bad parameter")
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func matchesContentType(contentType, expectedType string) bool <span class="cov8" title="1">{
        mimetype, _, err := mime.ParseMediaType(contentType)
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorf("Error parsing media type: %s error: %s", contentType, err.Error())
        }</span>
        <span class="cov8" title="1">return err == nil &amp;&amp; mimetype == expectedType</span>
}

func postAuth(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        authConfig := &amp;auth.AuthConfig{}
        err := json.NewDecoder(r.Body).Decode(authConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">status, err := auth.Login(authConfig, srv.HTTPRequestFactory(nil))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if status != "" </span><span class="cov0" title="0">{
                return writeJSON(w, http.StatusOK, &amp;APIAuth{Status: status})
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
        return nil</span>
}

func getVersion(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        srv.Eng.ServeHTTP(w, r)
        return nil
}</span>

func postContainersKill(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">job := srv.Eng.Job("kill", vars["name"])
        if sig := r.Form.Get("signal"); sig != "" </span><span class="cov0" title="0">{
                job.Args = append(job.Args, sig)
        }</span>
        <span class="cov0" title="0">if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
        return nil</span>
}

func getContainersExport(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">job := srv.Eng.Job("export", vars["name"])
        if err := job.Stdout.Add(w); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getImagesJSON(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">all, err := getBoolParam(r.Form.Get("all"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">filter := r.Form.Get("filter")

        outs, err := srv.Images(all, filter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if version &lt; 1.7 </span><span class="cov0" title="0">{
                outs2 := []APIImagesOld{}
                for _, ctnr := range outs </span><span class="cov0" title="0">{
                        outs2 = append(outs2, ctnr.ToLegacy()...)
                }</span>

                <span class="cov0" title="0">return writeJSON(w, http.StatusOK, outs2)</span>
        }
        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, outs)</span>
}

func getImagesViz(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if version &gt; 1.6 </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusNotFound)
                return fmt.Errorf("This is now implemented in the client.")
        }</span>

        <span class="cov0" title="0">if err := srv.ImagesViz(w); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getInfo(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        srv.Eng.ServeHTTP(w, r)
        return nil
}</span>

func getEvents(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        sendEvent := func(wf *utils.WriteFlusher, event *utils.JSONMessage) error </span><span class="cov0" title="0">{
                b, err := json.Marshal(event)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("JSON error")
                }</span>
                <span class="cov0" title="0">_, err = wf.Write(b)
                if err != nil </span><span class="cov0" title="0">{
                        // On error, evict the listener
                        utils.Errorf("%s", err)
                        srv.Lock()
                        delete(srv.listeners, r.RemoteAddr)
                        srv.Unlock()
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">listener := make(chan utils.JSONMessage)
        srv.Lock()
        srv.listeners[r.RemoteAddr] = listener
        srv.Unlock()
        since, err := strconv.ParseInt(r.Form.Get("since"), 10, 0)
        if err != nil </span><span class="cov0" title="0">{
                since = 0
        }</span>
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        wf := utils.NewWriteFlusher(w)
        wf.Flush()
        if since != 0 </span><span class="cov0" title="0">{
                // If since, send previous events that happened after the timestamp
                for _, event := range srv.GetEvents() </span><span class="cov0" title="0">{
                        if event.Time &gt;= since </span><span class="cov0" title="0">{
                                err := sendEvent(wf, &amp;event)
                                if err != nil &amp;&amp; err.Error() == "JSON error" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">for event := range listener </span><span class="cov0" title="0">{
                err := sendEvent(wf, &amp;event)
                if err != nil &amp;&amp; err.Error() == "JSON error" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getImagesHistory(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]
        outs, err := srv.ImageHistory(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, outs)</span>
}

func getContainersChanges(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]
        changesStr, err := srv.ContainerChanges(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, changesStr)</span>
}

func getContainersTop(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if version &lt; 1.4 </span><span class="cov0" title="0">{
                return fmt.Errorf("top was improved a lot since 1.3, Please upgrade your docker client.")
        }</span>
        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">procsStr, err := srv.ContainerTop(vars["name"], r.Form.Get("ps_args"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, procsStr)</span>
}

func getContainersJSON(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">all, err := getBoolParam(r.Form.Get("all"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">size, err := getBoolParam(r.Form.Get("size"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">since := r.Form.Get("since")
        before := r.Form.Get("before")
        n, err := strconv.Atoi(r.Form.Get("limit"))
        if err != nil </span><span class="cov0" title="0">{
                n = -1
        }</span>

        <span class="cov0" title="0">outs := srv.Containers(all, size, n, since, before)

        if version &lt; 1.5 </span><span class="cov0" title="0">{
                outs2 := []APIContainersOld{}
                for _, ctnr := range outs </span><span class="cov0" title="0">{
                        outs2 = append(outs2, *ctnr.ToLegacy())
                }</span>

                <span class="cov0" title="0">return writeJSON(w, http.StatusOK, outs2)</span>
        }
        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, outs)</span>
}

func postImagesTag(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>

        <span class="cov0" title="0">job := srv.Eng.Job("tag", vars["name"], r.Form.Get("repo"), r.Form.Get("tag"))
        job.Setenv("force", r.Form.Get("force"))
        if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)
        return nil</span>
}

func postCommit(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">config := &amp;Config{}
        if err := json.NewDecoder(r.Body).Decode(config); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                utils.Errorf("%s", err)
        }</span>

        <span class="cov0" title="0">job := srv.Eng.Job("commit", r.Form.Get("container"))
        job.Setenv("repo", r.Form.Get("repo"))
        job.Setenv("tag", r.Form.Get("tag"))
        job.Setenv("author", r.Form.Get("author"))
        job.Setenv("comment", r.Form.Get("comment"))
        job.SetenvJson("config", config)

        var id string
        job.Stdout.AddString(&amp;id)
        if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeJSON(w, http.StatusCreated, &amp;APIID{id})</span>
}

// Creates an image from Pull or from Import
func postImagesCreate(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">src := r.Form.Get("fromSrc")
        image := r.Form.Get("fromImage")
        tag := r.Form.Get("tag")
        repo := r.Form.Get("repo")

        authEncoded := r.Header.Get("X-Registry-Auth")
        authConfig := &amp;auth.AuthConfig{}
        if authEncoded != "" </span><span class="cov0" title="0">{
                authJson := base64.NewDecoder(base64.URLEncoding, strings.NewReader(authEncoded))
                if err := json.NewDecoder(authJson).Decode(authConfig); err != nil </span><span class="cov0" title="0">{
                        // for a pull it is not an error if no auth was given
                        // to increase compatibility with the existing api it is defaulting to be empty
                        authConfig = &amp;auth.AuthConfig{}
                }</span>
        }
        <span class="cov0" title="0">if version &gt; 1.0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
        }</span>
        <span class="cov0" title="0">sf := utils.NewStreamFormatter(version &gt; 1.0)
        if image != "" </span><span class="cov0" title="0">{ //pull
                metaHeaders := map[string][]string{}
                for k, v := range r.Header </span><span class="cov0" title="0">{
                        if strings.HasPrefix(k, "X-Meta-") </span><span class="cov0" title="0">{
                                metaHeaders[k] = v
                        }</span>
                }
                <span class="cov0" title="0">if err := srv.ImagePull(image, tag, w, sf, authConfig, metaHeaders, version &gt; 1.3); err != nil </span><span class="cov0" title="0">{
                        if sf.Used() </span><span class="cov0" title="0">{
                                w.Write(sf.FormatError(err))
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        } <span class="cov0" title="0">else { //import
                if err := srv.ImageImport(src, repo, tag, r.Body, w, sf); err != nil </span><span class="cov0" title="0">{
                        if sf.Used() </span><span class="cov0" title="0">{
                                w.Write(sf.FormatError(err))
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func getImagesSearch(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">term := r.Form.Get("term")
        outs, err := srv.ImagesSearch(term)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, outs)</span>
}

func postImagesInsert(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := r.Form.Get("url")
        path := r.Form.Get("path")
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]
        if version &gt; 1.0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
        }</span>
        <span class="cov0" title="0">sf := utils.NewStreamFormatter(version &gt; 1.0)
        err := srv.ImageInsert(name, url, path, w, sf)
        if err != nil </span><span class="cov0" title="0">{
                if sf.Used() </span><span class="cov0" title="0">{
                        w.Write(sf.FormatError(err))
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func postImagesPush(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        metaHeaders := map[string][]string{}
        for k, v := range r.Header </span><span class="cov0" title="0">{
                if strings.HasPrefix(k, "X-Meta-") </span><span class="cov0" title="0">{
                        metaHeaders[k] = v
                }</span>
        }
        <span class="cov0" title="0">if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">authConfig := &amp;auth.AuthConfig{}

        authEncoded := r.Header.Get("X-Registry-Auth")
        if authEncoded != "" </span><span class="cov0" title="0">{
                // the new format is to handle the authConfig as a header
                authJson := base64.NewDecoder(base64.URLEncoding, strings.NewReader(authEncoded))
                if err := json.NewDecoder(authJson).Decode(authConfig); err != nil </span><span class="cov0" title="0">{
                        // to increase compatibility to existing api it is defaulting to be empty
                        authConfig = &amp;auth.AuthConfig{}
                }</span>
        } <span class="cov0" title="0">else {
                // the old format is supported for compatibility if there was no authConfig header
                if err := json.NewDecoder(r.Body).Decode(authConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]
        if version &gt; 1.0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
        }</span>
        <span class="cov0" title="0">sf := utils.NewStreamFormatter(version &gt; 1.0)
        if err := srv.ImagePush(name, w, sf, authConfig, metaHeaders); err != nil </span><span class="cov0" title="0">{
                if sf.Used() </span><span class="cov0" title="0">{
                        w.Write(sf.FormatError(err))
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getImagesGet(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">if version &gt; 1.0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/x-tar")
        }</span>
        <span class="cov0" title="0">job := srv.Eng.Job("image_export", vars["name"])
        if err := job.Stdout.Add(w); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return job.Run()</span>
}

func postImagesLoad(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        return srv.ImageLoad(r.Body)
}</span>

func postContainersCreate(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := &amp;APIRun{}
        job := srv.Eng.Job("create", r.Form.Get("name"))
        if err := job.DecodeEnv(r.Body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resolvConf, err := utils.GetResolvConf()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !job.GetenvBool("NetworkDisabled") &amp;&amp; len(job.Getenv("Dns")) == 0 &amp;&amp; len(srv.runtime.config.Dns) == 0 &amp;&amp; utils.CheckLocalDns(resolvConf) </span><span class="cov0" title="0">{
                out.Warnings = append(out.Warnings, fmt.Sprintf("Docker detected local DNS server on resolv.conf. Using default external servers: %v", defaultDns))
                job.SetenvList("Dns", defaultDns)
        }</span>
        // Read container ID from the first line of stdout
        <span class="cov0" title="0">job.Stdout.AddString(&amp;out.ID)
        // Read warnings from stderr
        warnings := &amp;bytes.Buffer{}
        job.Stderr.Add(warnings)
        if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Parse warnings from stderr
        <span class="cov0" title="0">scanner := bufio.NewScanner(warnings)
        for scanner.Scan() </span><span class="cov0" title="0">{
                out.Warnings = append(out.Warnings, scanner.Text())
        }</span>
        <span class="cov0" title="0">if job.GetenvInt("Memory") &gt; 0 &amp;&amp; !srv.runtime.capabilities.MemoryLimit </span><span class="cov0" title="0">{
                log.Println("WARNING: Your kernel does not support memory limit capabilities. Limitation discarded.")
                out.Warnings = append(out.Warnings, "Your kernel does not support memory limit capabilities. Limitation discarded.")
        }</span>
        <span class="cov0" title="0">if job.GetenvInt("Memory") &gt; 0 &amp;&amp; !srv.runtime.capabilities.SwapLimit </span><span class="cov0" title="0">{
                log.Println("WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.")
                out.Warnings = append(out.Warnings, "Your kernel does not support memory swap capabilities. Limitation discarded.")
        }</span>

        <span class="cov0" title="0">if !job.GetenvBool("NetworkDisabled") &amp;&amp; srv.runtime.capabilities.IPv4ForwardingDisabled </span><span class="cov0" title="0">{
                log.Println("Warning: IPv4 forwarding is disabled.")
                out.Warnings = append(out.Warnings, "IPv4 forwarding is disabled.")
        }</span>

        <span class="cov0" title="0">return writeJSON(w, http.StatusCreated, out)</span>
}

func postContainersRestart(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">job := srv.Eng.Job("restart", vars["name"])
        job.Setenv("t", r.Form.Get("t"))
        if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
        return nil</span>
}

func deleteContainers(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">job := srv.Eng.Job("container_delete", vars["name"])
        job.Setenv("removeVolume", r.Form.Get("v"))
        job.Setenv("removeLink", r.Form.Get("link"))
        if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
        return nil</span>
}

func deleteImages(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]
        imgs, err := srv.ImageDelete(name, version &gt; 1.1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if imgs != nil </span><span class="cov0" title="0">{
                if len(imgs) != 0 </span><span class="cov0" title="0">{
                        return writeJSON(w, http.StatusOK, imgs)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Conflict, %s wasn't deleted", name)</span>
        }
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
        return nil</span>
}

func postContainersStart(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]
        job := srv.Eng.Job("start", name)
        // allow a nil body for backwards compatibility
        if r.Body != nil </span><span class="cov0" title="0">{
                if matchesContentType(r.Header.Get("Content-Type"), "application/json") </span><span class="cov0" title="0">{
                        if err := job.DecodeEnv(r.Body); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
        return nil</span>
}

func postContainersStop(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">job := srv.Eng.Job("stop", vars["name"])
        job.Setenv("t", r.Form.Get("t"))
        if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
        return nil</span>
}

func postContainersWait(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">job := srv.Eng.Job("wait", vars["name"])
        var statusStr string
        job.Stdout.AddString(&amp;statusStr)
        if err := job.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Parse a 16-bit encoded integer to map typical unix exit status.
        <span class="cov0" title="0">status, err := strconv.ParseInt(statusStr, 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, &amp;APIWait{StatusCode: int(status)})</span>
}

func postContainersResize(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">if err := srv.Eng.Job("resize", vars["name"], r.Form.Get("h"), r.Form.Get("w")).Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func postContainersAttach(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logs, err := getBoolParam(r.Form.Get("logs"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stream, err := getBoolParam(r.Form.Get("stream"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stdin, err := getBoolParam(r.Form.Get("stdin"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stdout, err := getBoolParam(r.Form.Get("stdout"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stderr, err := getBoolParam(r.Form.Get("stderr"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]

        c, err := srv.ContainerInspect(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">inStream, outStream, err := hijackServer(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tcpc, ok := inStream.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                        tcpc.CloseWrite()
                }</span> <span class="cov0" title="0">else {
                        inStream.Close()
                }</span>
        }()
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tcpc, ok := outStream.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                        tcpc.CloseWrite()
                }</span> <span class="cov0" title="0">else if closer, ok := outStream.(io.Closer); ok </span><span class="cov0" title="0">{
                        closer.Close()
                }</span>
        }()

        <span class="cov0" title="0">var errStream io.Writer

        fmt.Fprintf(outStream, "HTTP/1.1 200 OK\r\nContent-Type: application/vnd.docker.raw-stream\r\n\r\n")

        if !c.Config.Tty &amp;&amp; version &gt;= 1.6 </span><span class="cov0" title="0">{
                errStream = utils.NewStdWriter(outStream, utils.Stderr)
                outStream = utils.NewStdWriter(outStream, utils.Stdout)
        }</span> <span class="cov0" title="0">else {
                errStream = outStream
        }</span>

        <span class="cov0" title="0">if err := srv.ContainerAttach(name, logs, stream, stdin, stdout, stderr, inStream, outStream, errStream); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(outStream, "Error: %s\n", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func wsContainersAttach(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{

        if err := parseForm(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logs, err := getBoolParam(r.Form.Get("logs"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stream, err := getBoolParam(r.Form.Get("stream"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stdin, err := getBoolParam(r.Form.Get("stdin"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stdout, err := getBoolParam(r.Form.Get("stdout"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stderr, err := getBoolParam(r.Form.Get("stderr"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]

        if _, err := srv.ContainerInspect(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h := websocket.Handler(func(ws *websocket.Conn) </span><span class="cov0" title="0">{
                defer ws.Close()

                if err := srv.ContainerAttach(name, logs, stream, stdin, stdout, stderr, ws, ws, ws); err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Error: %s", err)
                }</span>
        })
        <span class="cov0" title="0">h.ServeHTTP(w, r)

        return nil</span>
}

func getContainersByName(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]

        container, err := srv.ContainerInspect(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = srv.ImageInspect(name)
        if err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Conflict between containers and images")
        }</span>

        <span class="cov0" title="0">container.readHostConfig()
        c := APIContainer{container, container.hostConfig}

        return writeJSON(w, http.StatusOK, c)</span>
}

func getImagesByName(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]

        image, err := srv.ImageInspect(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = srv.ContainerInspect(name)
        if err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Conflict between containers and images")
        }</span>

        <span class="cov0" title="0">return writeJSON(w, http.StatusOK, image)</span>
}

func postBuild(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if version &lt; 1.3 </span><span class="cov0" title="0">{
                return fmt.Errorf("Multipart upload for build is no longer supported. Please upgrade your docker client.")
        }</span>
        <span class="cov0" title="0">var (
                remoteURL         = r.FormValue("remote")
                repoName          = r.FormValue("t")
                rawSuppressOutput = r.FormValue("q")
                rawNoCache        = r.FormValue("nocache")
                rawRm             = r.FormValue("rm")
                authEncoded       = r.Header.Get("X-Registry-Auth")
                authConfig        = &amp;auth.AuthConfig{}
                tag               string
        )
        repoName, tag = utils.ParseRepositoryTag(repoName)
        if authEncoded != "" </span><span class="cov0" title="0">{
                authJson := base64.NewDecoder(base64.URLEncoding, strings.NewReader(authEncoded))
                if err := json.NewDecoder(authJson).Decode(authConfig); err != nil </span><span class="cov0" title="0">{
                        // for a pull it is not an error if no auth was given
                        // to increase compatibility with the existing api it is defaulting to be empty
                        authConfig = &amp;auth.AuthConfig{}
                }</span>
        }

        <span class="cov0" title="0">var context io.Reader

        if remoteURL == "" </span><span class="cov0" title="0">{
                context = r.Body
        }</span> <span class="cov0" title="0">else if utils.IsGIT(remoteURL) </span><span class="cov0" title="0">{
                if !strings.HasPrefix(remoteURL, "git://") </span><span class="cov0" title="0">{
                        remoteURL = "https://" + remoteURL
                }</span>
                <span class="cov0" title="0">root, err := ioutil.TempDir("", "docker-build-git")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer os.RemoveAll(root)

                if output, err := exec.Command("git", "clone", remoteURL, root).CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error trying to use git: %s (%s)", err, output)
                }</span>

                <span class="cov0" title="0">c, err := archive.Tar(root, archive.Uncompressed)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">context = c</span>
        } <span class="cov0" title="0">else if utils.IsURL(remoteURL) </span><span class="cov0" title="0">{
                f, err := utils.Download(remoteURL)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer f.Body.Close()
                dockerFile, err := ioutil.ReadAll(f.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c, err := MkBuildContext(string(dockerFile), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">context = c</span>
        }

        <span class="cov0" title="0">suppressOutput, err := getBoolParam(rawSuppressOutput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">noCache, err := getBoolParam(rawNoCache)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rm, err := getBoolParam(rawRm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if version &gt;= 1.8 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
        }</span>
        <span class="cov0" title="0">sf := utils.NewStreamFormatter(version &gt;= 1.8)
        b := NewBuildFile(srv,
                &amp;StdoutFormater{
                        Writer:          utils.NewWriteFlusher(w),
                        StreamFormatter: sf,
                },
                &amp;StderrFormater{
                        Writer:          utils.NewWriteFlusher(w),
                        StreamFormatter: sf,
                },
                !suppressOutput, !noCache, rm, utils.NewWriteFlusher(w), sf, authConfig)
        id, err := b.Build(context)
        if err != nil </span><span class="cov0" title="0">{
                if sf.Used() </span><span class="cov0" title="0">{
                        w.Write(sf.FormatError(err))
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Error build: %s", err)</span>
        }
        <span class="cov0" title="0">if repoName != "" </span><span class="cov0" title="0">{
                srv.runtime.repositories.Set(repoName, tag, id, false)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func postContainersCopy(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        if vars == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing parameter")
        }</span>
        <span class="cov0" title="0">name := vars["name"]

        copyData := &amp;APICopy{}
        contentType := r.Header.Get("Content-Type")
        if contentType == "application/json" </span><span class="cov0" title="0">{
                if err := json.NewDecoder(r.Body).Decode(copyData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } <span class="cov0" title="0">else {
                return fmt.Errorf("Content-Type not supported: %s", contentType)
        }</span>

        <span class="cov0" title="0">if copyData.Resource == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Path cannot be empty")
        }</span>
        <span class="cov0" title="0">if copyData.Resource[0] == '/' </span><span class="cov0" title="0">{
                copyData.Resource = copyData.Resource[1:]
        }</span>

        <span class="cov0" title="0">if err := srv.ContainerCopy(name, copyData.Resource, w); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("%s", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func optionsHandler(srv *Server, version float64, w http.ResponseWriter, r *http.Request, vars map[string]string) error <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
        return nil
}</span>
func writeCorsHeaders(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Add("Access-Control-Allow-Origin", "*")
        w.Header().Add("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")
        w.Header().Add("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT, OPTIONS")
}</span>

func makeHttpHandler(srv *Server, logging bool, localMethod string, localRoute string, handlerFunc HttpApiFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // log the request
                utils.Debugf("Calling %s %s", localMethod, localRoute)

                if logging </span><span class="cov0" title="0">{
                        log.Println(r.Method, r.RequestURI)
                }</span>

                <span class="cov0" title="0">if strings.Contains(r.Header.Get("User-Agent"), "Docker-Client/") </span><span class="cov0" title="0">{
                        userAgent := strings.Split(r.Header.Get("User-Agent"), "/")
                        if len(userAgent) == 2 &amp;&amp; userAgent[1] != VERSION </span><span class="cov0" title="0">{
                                utils.Debugf("Warning: client and server don't have the same version (client: %s, server: %s)", userAgent[1], VERSION)
                        }</span>
                }
                <span class="cov0" title="0">version, err := strconv.ParseFloat(mux.Vars(r)["version"], 64)
                if err != nil </span><span class="cov0" title="0">{
                        version = APIVERSION
                }</span>
                <span class="cov0" title="0">if srv.runtime.config.EnableCors </span><span class="cov0" title="0">{
                        writeCorsHeaders(w, r)
                }</span>

                <span class="cov0" title="0">if version == 0 || version &gt; APIVERSION </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">if err := handlerFunc(srv, version, w, r, mux.Vars(r)); err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Error: %s", err)
                        httpError(w, err)
                }</span>
        }
}

// Replicated from expvar.go as not public.
func expvarHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        fmt.Fprintf(w, "{\n")
        first := true
        expvar.Do(func(kv expvar.KeyValue) </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, ",\n")
                }</span>
                <span class="cov0" title="0">first = false
                fmt.Fprintf(w, "%q: %s", kv.Key, kv.Value)</span>
        })
        <span class="cov0" title="0">fmt.Fprintf(w, "\n}\n")</span>
}

func AttachProfiler(router *mux.Router) <span class="cov0" title="0">{
        router.HandleFunc("/debug/vars", expvarHandler)
        router.HandleFunc("/debug/pprof/", pprof.Index)
        router.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
        router.HandleFunc("/debug/pprof/profile", pprof.Profile)
        router.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
        router.HandleFunc("/debug/pprof/heap", pprof.Handler("heap").ServeHTTP)
        router.HandleFunc("/debug/pprof/goroutine", pprof.Handler("goroutine").ServeHTTP)
        router.HandleFunc("/debug/pprof/threadcreate", pprof.Handler("threadcreate").ServeHTTP)
}</span>

func createRouter(srv *Server, logging bool) (*mux.Router, error) <span class="cov0" title="0">{
        r := mux.NewRouter()
        if os.Getenv("DEBUG") != "" </span><span class="cov0" title="0">{
                AttachProfiler(r)
        }</span>
        <span class="cov0" title="0">m := map[string]map[string]HttpApiFunc{
                "GET": {
                        "/events":                         getEvents,
                        "/info":                           getInfo,
                        "/version":                        getVersion,
                        "/images/json":                    getImagesJSON,
                        "/images/viz":                     getImagesViz,
                        "/images/search":                  getImagesSearch,
                        "/images/{name:.*}/get":           getImagesGet,
                        "/images/{name:.*}/history":       getImagesHistory,
                        "/images/{name:.*}/json":          getImagesByName,
                        "/containers/ps":                  getContainersJSON,
                        "/containers/json":                getContainersJSON,
                        "/containers/{name:.*}/export":    getContainersExport,
                        "/containers/{name:.*}/changes":   getContainersChanges,
                        "/containers/{name:.*}/json":      getContainersByName,
                        "/containers/{name:.*}/top":       getContainersTop,
                        "/containers/{name:.*}/attach/ws": wsContainersAttach,
                },
                "POST": {
                        "/auth":                         postAuth,
                        "/commit":                       postCommit,
                        "/build":                        postBuild,
                        "/images/create":                postImagesCreate,
                        "/images/{name:.*}/insert":      postImagesInsert,
                        "/images/load":                  postImagesLoad,
                        "/images/{name:.*}/push":        postImagesPush,
                        "/images/{name:.*}/tag":         postImagesTag,
                        "/containers/create":            postContainersCreate,
                        "/containers/{name:.*}/kill":    postContainersKill,
                        "/containers/{name:.*}/restart": postContainersRestart,
                        "/containers/{name:.*}/start":   postContainersStart,
                        "/containers/{name:.*}/stop":    postContainersStop,
                        "/containers/{name:.*}/wait":    postContainersWait,
                        "/containers/{name:.*}/resize":  postContainersResize,
                        "/containers/{name:.*}/attach":  postContainersAttach,
                        "/containers/{name:.*}/copy":    postContainersCopy,
                },
                "DELETE": {
                        "/containers/{name:.*}": deleteContainers,
                        "/images/{name:.*}":     deleteImages,
                },
                "OPTIONS": {
                        "": optionsHandler,
                },
        }

        for method, routes := range m </span><span class="cov0" title="0">{
                for route, fct := range routes </span><span class="cov0" title="0">{
                        utils.Debugf("Registering %s, %s", method, route)
                        // NOTE: scope issue, make sure the variables are local and won't be changed
                        localRoute := route
                        localFct := fct
                        localMethod := method

                        // build the handler function
                        f := makeHttpHandler(srv, logging, localMethod, localRoute, localFct)

                        // add the new route
                        if localRoute == "" </span><span class="cov0" title="0">{
                                r.Methods(localMethod).HandlerFunc(f)
                        }</span> <span class="cov0" title="0">else {
                                r.Path("/v{version:[0-9.]+}" + localRoute).Methods(localMethod).HandlerFunc(f)
                                r.Path(localRoute).Methods(localMethod).HandlerFunc(f)
                        }</span>
                }
        }

        <span class="cov0" title="0">return r, nil</span>
}

// ServeRequest processes a single http request to the docker remote api.
// FIXME: refactor this to be part of Server and not require re-creating a new
// router each time. This requires first moving ListenAndServe into Server.
func ServeRequest(srv *Server, apiversion float64, w http.ResponseWriter, req *http.Request) error <span class="cov0" title="0">{
        router, err := createRouter(srv, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Insert APIVERSION into the request as a convenience
        <span class="cov0" title="0">req.URL.Path = fmt.Sprintf("/v%g%s", apiversion, req.URL.Path)
        router.ServeHTTP(w, req)
        return nil</span>
}

func ListenAndServe(proto, addr string, srv *Server, logging bool) error <span class="cov0" title="0">{
        r, err := createRouter(srv, logging)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">l, e := net.Listen(proto, addr)
        if e != nil </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov0" title="0">if proto == "unix" </span><span class="cov0" title="0">{
                if err := os.Chmod(addr, 0660); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">groups, err := ioutil.ReadFile("/etc/group")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">re := regexp.MustCompile("(^|\n)docker:.*?:([0-9]+)")
                if gidMatch := re.FindStringSubmatch(string(groups)); gidMatch != nil </span><span class="cov0" title="0">{
                        gid, err := strconv.Atoi(gidMatch[2])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">utils.Debugf("docker group found. gid: %d", gid)
                        if err := os.Chown(addr, 0, gid); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">httpSrv := http.Server{Addr: addr, Handler: r}

        log.Printf("Listening for HTTP on %s (%s)\n", addr, proto)
        // Tell the init daemon we are accepting requests
        go systemd.SdNotify("READY=1")
        return httpSrv.Serve(l)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package docker

import "strings"

type (
        APIHistory struct {
                ID        string   `json:"Id"`
                Tags      []string `json:",omitempty"`
                Created   int64
                CreatedBy string `json:",omitempty"`
                Size      int64
        }

        APIImages struct {
                ID          string   `json:"Id"`
                RepoTags    []string `json:",omitempty"`
                Created     int64
                Size        int64
                VirtualSize int64
                ParentId    string `json:",omitempty"`
        }

        APIImagesOld struct {
                Repository  string `json:",omitempty"`
                Tag         string `json:",omitempty"`
                ID          string `json:"Id"`
                Created     int64
                Size        int64
                VirtualSize int64
        }

        APITop struct {
                Titles    []string
                Processes [][]string
        }

        APIRmi struct {
                Deleted  string `json:",omitempty"`
                Untagged string `json:",omitempty"`
        }

        APIContainers struct {
                ID         string `json:"Id"`
                Image      string
                Command    string
                Created    int64
                Status     string
                Ports      []APIPort
                SizeRw     int64
                SizeRootFs int64
                Names      []string
        }

        APIContainersOld struct {
                ID         string `json:"Id"`
                Image      string
                Command    string
                Created    int64
                Status     string
                Ports      string
                SizeRw     int64
                SizeRootFs int64
        }

        APIID struct {
                ID string `json:"Id"`
        }

        APIRun struct {
                ID       string   `json:"Id"`
                Warnings []string `json:",omitempty"`
        }

        APIPort struct {
                PrivatePort int64
                PublicPort  int64
                Type        string
                IP          string
        }

        APIWait struct {
                StatusCode int
        }

        APIAuth struct {
                Status string
        }

        APIImageConfig struct {
                ID string `json:"Id"`
                *Config
        }

        APICopy struct {
                Resource string
                HostPath string
        }
        APIContainer struct {
                *Container
                HostConfig *HostConfig
        }
)

func (api APIImages) ToLegacy() []APIImagesOld <span class="cov0" title="0">{
        outs := []APIImagesOld{}
        for _, repotag := range api.RepoTags </span><span class="cov0" title="0">{
                components := strings.SplitN(repotag, ":", 2)
                outs = append(outs, APIImagesOld{
                        ID:          api.ID,
                        Repository:  components[0],
                        Tag:         components[1],
                        Created:     api.Created,
                        Size:        api.Size,
                        VirtualSize: api.VirtualSize,
                })
        }</span>
        <span class="cov0" title="0">return outs</span>
}

func (api APIContainers) ToLegacy() *APIContainersOld <span class="cov0" title="0">{
        return &amp;APIContainersOld{
                ID:         api.ID,
                Image:      api.Image,
                Command:    api.Command,
                Created:    api.Created,
                Status:     api.Status,
                Ports:      displayablePorts(api.Ports),
                SizeRw:     api.SizeRw,
                SizeRootFs: api.SizeRootFs,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package docker

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/auth"
        "github.com/dotcloud/docker/utils"
        "io"
        "io/ioutil"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "reflect"
        "regexp"
        "sort"
        "strings"
)

var (
        ErrDockerfileEmpty = errors.New("Dockerfile cannot be empty")
)

type BuildFile interface {
        Build(io.Reader) (string, error)
        CmdFrom(string) error
        CmdRun(string) error
}

type buildFile struct {
        runtime *Runtime
        srv     *Server

        image      string
        maintainer string
        config     *Config

        contextPath string
        context     *utils.TarSum

        verbose      bool
        utilizeCache bool
        rm           bool

        authConfig *auth.AuthConfig

        tmpContainers map[string]struct{}
        tmpImages     map[string]struct{}

        outStream io.Writer
        errStream io.Writer

        // Deprecated, original writer used for ImagePull. To be removed.
        outOld io.Writer
        sf     *utils.StreamFormatter
}

func (b *buildFile) clearTmp(containers map[string]struct{}) <span class="cov0" title="0">{
        for c := range containers </span><span class="cov0" title="0">{
                tmp := b.runtime.Get(c)
                b.runtime.Destroy(tmp)
                fmt.Fprintf(b.outStream, "Removing intermediate container %s\n", utils.TruncateID(c))
        }</span>
}

func (b *buildFile) CmdFrom(name string) error <span class="cov0" title="0">{
        image, err := b.runtime.repositories.LookupImage(name)
        if err != nil </span><span class="cov0" title="0">{
                if b.runtime.graph.IsNotExist(err) </span><span class="cov0" title="0">{
                        remote, tag := utils.ParseRepositoryTag(name)
                        if err := b.srv.ImagePull(remote, tag, b.outOld, b.sf, b.authConfig, nil, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">image, err = b.runtime.repositories.LookupImage(name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } <span class="cov0" title="0">else {
                        return err
                }</span>
        }
        <span class="cov0" title="0">b.image = image.ID
        b.config = &amp;Config{}
        if image.Config != nil </span><span class="cov0" title="0">{
                b.config = image.Config
        }</span>
        <span class="cov0" title="0">if b.config.Env == nil || len(b.config.Env) == 0 </span><span class="cov0" title="0">{
                b.config.Env = append(b.config.Env, "HOME=/", "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *buildFile) CmdMaintainer(name string) error <span class="cov0" title="0">{
        b.maintainer = name
        return b.commit("", b.config.Cmd, fmt.Sprintf("MAINTAINER %s", name))
}</span>

// probeCache checks to see if image-caching is enabled (`b.utilizeCache`)
// and if so attempts to look up the current `b.image` and `b.config` pair
// in the current server `b.srv`. If an image is found, probeCache returns
// `(true, nil)`. If no image is found, it returns `(false, nil)`. If there
// is any error, it returns `(false, err)`.
func (b *buildFile) probeCache() (bool, error) <span class="cov0" title="0">{
        if b.utilizeCache </span><span class="cov0" title="0">{
                if cache, err := b.srv.ImageGetCached(b.image, b.config); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span> <span class="cov0" title="0">else if cache != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(b.outStream, " ---&gt; Using cache\n")
                        utils.Debugf("[BUILDER] Use cached version")
                        b.image = cache.ID
                        return true, nil
                }</span> <span class="cov0" title="0">else {
                        utils.Debugf("[BUILDER] Cache miss")
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (b *buildFile) CmdRun(args string) error <span class="cov0" title="0">{
        if b.image == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Please provide a source image with `from` prior to run")
        }</span>
        <span class="cov0" title="0">config, _, _, err := ParseRun([]string{b.image, "/bin/sh", "-c", args}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd := b.config.Cmd
        b.config.Cmd = nil
        MergeConfig(b.config, config)

        defer func(cmd []string) </span><span class="cov0" title="0">{ b.config.Cmd = cmd }</span>(cmd)

        <span class="cov0" title="0">utils.Debugf("Command to be executed: %v", b.config.Cmd)

        hit, err := b.probeCache()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if hit </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cid, err := b.run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := b.commit(cid, cmd, "run"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *buildFile) FindEnvKey(key string) int <span class="cov0" title="0">{
        for k, envVar := range b.config.Env </span><span class="cov0" title="0">{
                envParts := strings.SplitN(envVar, "=", 2)
                if key == envParts[0] </span><span class="cov0" title="0">{
                        return k
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func (b *buildFile) ReplaceEnvMatches(value string) (string, error) <span class="cov0" title="0">{
        exp, err := regexp.Compile("(\\\\\\\\+|[^\\\\]|\\b|\\A)\\$({?)([[:alnum:]_]+)(}?)")
        if err != nil </span><span class="cov0" title="0">{
                return value, err
        }</span>
        <span class="cov0" title="0">matches := exp.FindAllString(value, -1)
        for _, match := range matches </span><span class="cov0" title="0">{
                match = match[strings.Index(match, "$"):]
                matchKey := strings.Trim(match, "${}")

                for _, envVar := range b.config.Env </span><span class="cov0" title="0">{
                        envParts := strings.SplitN(envVar, "=", 2)
                        envKey := envParts[0]
                        envValue := envParts[1]

                        if envKey == matchKey </span><span class="cov0" title="0">{
                                value = strings.Replace(value, match, envValue, -1)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return value, nil</span>
}

func (b *buildFile) CmdEnv(args string) error <span class="cov0" title="0">{
        tmp := strings.SplitN(args, " ", 2)
        if len(tmp) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid ENV format")
        }</span>
        <span class="cov0" title="0">key := strings.Trim(tmp[0], " \t")
        value := strings.Trim(tmp[1], " \t")

        envKey := b.FindEnvKey(key)
        replacedValue, err := b.ReplaceEnvMatches(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">replacedVar := fmt.Sprintf("%s=%s", key, replacedValue)

        if envKey &gt;= 0 </span><span class="cov0" title="0">{
                b.config.Env[envKey] = replacedVar
        }</span> <span class="cov0" title="0">else {
                b.config.Env = append(b.config.Env, replacedVar)
        }</span>
        <span class="cov0" title="0">return b.commit("", b.config.Cmd, fmt.Sprintf("ENV %s", replacedVar))</span>
}

func (b *buildFile) buildCmdFromJson(args string) []string <span class="cov0" title="0">{
        var cmd []string
        if err := json.Unmarshal([]byte(args), &amp;cmd); err != nil </span><span class="cov0" title="0">{
                utils.Debugf("Error unmarshalling: %s, setting to /bin/sh -c", err)
                cmd = []string{"/bin/sh", "-c", args}
        }</span>
        <span class="cov0" title="0">return cmd</span>
}

func (b *buildFile) CmdCmd(args string) error <span class="cov0" title="0">{
        cmd := b.buildCmdFromJson(args)
        b.config.Cmd = cmd
        if err := b.commit("", b.config.Cmd, fmt.Sprintf("CMD %v", cmd)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *buildFile) CmdEntrypoint(args string) error <span class="cov0" title="0">{
        entrypoint := b.buildCmdFromJson(args)
        b.config.Entrypoint = entrypoint
        if err := b.commit("", b.config.Cmd, fmt.Sprintf("ENTRYPOINT %v", entrypoint)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *buildFile) CmdExpose(args string) error <span class="cov0" title="0">{
        ports := strings.Split(args, " ")
        b.config.PortSpecs = append(ports, b.config.PortSpecs...)
        return b.commit("", b.config.Cmd, fmt.Sprintf("EXPOSE %v", ports))
}</span>

func (b *buildFile) CmdUser(args string) error <span class="cov0" title="0">{
        b.config.User = args
        return b.commit("", b.config.Cmd, fmt.Sprintf("USER %v", args))
}</span>

func (b *buildFile) CmdInsert(args string) error <span class="cov0" title="0">{
        return fmt.Errorf("INSERT has been deprecated. Please use ADD instead")
}</span>

func (b *buildFile) CmdCopy(args string) error <span class="cov0" title="0">{
        return fmt.Errorf("COPY has been deprecated. Please use ADD instead")
}</span>

func (b *buildFile) CmdWorkdir(workdir string) error <span class="cov0" title="0">{
        b.config.WorkingDir = workdir
        return b.commit("", b.config.Cmd, fmt.Sprintf("WORKDIR %v", workdir))
}</span>

func (b *buildFile) CmdVolume(args string) error <span class="cov0" title="0">{
        if args == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Volume cannot be empty")
        }</span>

        <span class="cov0" title="0">var volume []string
        if err := json.Unmarshal([]byte(args), &amp;volume); err != nil </span><span class="cov0" title="0">{
                volume = []string{args}
        }</span>
        <span class="cov0" title="0">if b.config.Volumes == nil </span><span class="cov0" title="0">{
                b.config.Volumes = map[string]struct{}{}
        }</span>
        <span class="cov0" title="0">for _, v := range volume </span><span class="cov0" title="0">{
                b.config.Volumes[v] = struct{}{}
        }</span>
        <span class="cov0" title="0">if err := b.commit("", b.config.Cmd, fmt.Sprintf("VOLUME %s", args)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *buildFile) checkPathForAddition(orig string) error <span class="cov0" title="0">{
        origPath := path.Join(b.contextPath, orig)
        if !strings.HasPrefix(origPath, b.contextPath) </span><span class="cov0" title="0">{
                return fmt.Errorf("Forbidden path outside the build context: %s (%s)", orig, origPath)
        }</span>
        <span class="cov0" title="0">_, err := os.Stat(origPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: no such file or directory", orig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *buildFile) addContext(container *Container, orig, dest string) error <span class="cov0" title="0">{
        var (
                origPath = path.Join(b.contextPath, orig)
                destPath = path.Join(container.RootfsPath(), dest)
        )
        // Preserve the trailing '/'
        if strings.HasSuffix(dest, "/") </span><span class="cov0" title="0">{
                destPath = destPath + "/"
        }</span>
        <span class="cov0" title="0">fi, err := os.Stat(origPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: no such file or directory", orig)
        }</span>
        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                if err := archive.CopyWithTar(origPath, destPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // First try to unpack the source as an archive
        } <span class="cov0" title="0">else if err := archive.UntarPath(origPath, destPath); err != nil </span><span class="cov0" title="0">{
                utils.Debugf("Couldn't untar %s to %s: %s", origPath, destPath, err)
                // If that fails, just copy it as a regular file
                if err := os.MkdirAll(path.Dir(destPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := archive.CopyWithTar(origPath, destPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (b *buildFile) CmdAdd(args string) error <span class="cov0" title="0">{
        if b.context == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("No context given. Impossible to use ADD")
        }</span>
        <span class="cov0" title="0">tmp := strings.SplitN(args, " ", 2)
        if len(tmp) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid ADD format")
        }</span>

        <span class="cov0" title="0">orig, err := b.ReplaceEnvMatches(strings.Trim(tmp[0], " \t"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dest, err := b.ReplaceEnvMatches(strings.Trim(tmp[1], " \t"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd := b.config.Cmd
        b.config.Cmd = []string{"/bin/sh", "-c", fmt.Sprintf("#(nop) ADD %s in %s", orig, dest)}
        b.config.Image = b.image

        // FIXME: do we really need this?
        var (
                origPath   = orig
                destPath   = dest
                remoteHash string
        )

        if utils.IsURL(orig) </span><span class="cov0" title="0">{
                resp, err := utils.Download(orig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tmpDirName, err := ioutil.TempDir(b.contextPath, "docker-remote")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tmpFileName := path.Join(tmpDirName, "tmp")
                tmpFile, err := os.OpenFile(tmpFileName, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer os.RemoveAll(tmpDirName)
                if _, err = io.Copy(tmpFile, resp.Body); err != nil </span><span class="cov0" title="0">{
                        tmpFile.Close()
                        return err
                }</span>
                <span class="cov0" title="0">origPath = path.Join(filepath.Base(tmpDirName), filepath.Base(tmpFileName))
                tmpFile.Close()

                // Process the checksum
                r, err := archive.Tar(tmpFileName, archive.Uncompressed)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tarSum := utils.TarSum{Reader: r, DisableCompression: true}
                remoteHash = tarSum.Sum(nil)

                // If the destination is a directory, figure out the filename.
                if strings.HasSuffix(dest, "/") </span><span class="cov0" title="0">{
                        u, err := url.Parse(orig)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">path := u.Path
                        if strings.HasSuffix(path, "/") </span><span class="cov0" title="0">{
                                path = path[:len(path)-1]
                        }</span>
                        <span class="cov0" title="0">parts := strings.Split(path, "/")
                        filename := parts[len(parts)-1]
                        if filename == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot determine filename from url: %s", u)
                        }</span>
                        <span class="cov0" title="0">destPath = dest + filename</span>
                }
        }

        <span class="cov0" title="0">if err := b.checkPathForAddition(origPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Hash path and check the cache
        <span class="cov0" title="0">if b.utilizeCache </span><span class="cov0" title="0">{
                var (
                        hash string
                        sums = b.context.GetSums()
                )

                if remoteHash != "" </span><span class="cov0" title="0">{
                        hash = remoteHash
                }</span> <span class="cov0" title="0">else if fi, err := os.Stat(path.Join(b.contextPath, origPath)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> <span class="cov0" title="0">else if fi.IsDir() </span><span class="cov0" title="0">{
                        var subfiles []string
                        for file, sum := range sums </span><span class="cov0" title="0">{
                                absFile := path.Join(b.contextPath, file)
                                absOrigPath := path.Join(b.contextPath, origPath)
                                if strings.HasPrefix(absFile, absOrigPath) </span><span class="cov0" title="0">{
                                        subfiles = append(subfiles, sum)
                                }</span>
                        }
                        <span class="cov0" title="0">sort.Strings(subfiles)
                        hasher := sha256.New()
                        hasher.Write([]byte(strings.Join(subfiles, ",")))
                        hash = "dir:" + hex.EncodeToString(hasher.Sum(nil))</span>
                } <span class="cov0" title="0">else {
                        if origPath[0] == '/' &amp;&amp; len(origPath) &gt; 1 </span><span class="cov0" title="0">{
                                origPath = origPath[1:]
                        }</span>
                        <span class="cov0" title="0">origPath = strings.TrimPrefix(origPath, "./")
                        if h, ok := sums[origPath]; ok </span><span class="cov0" title="0">{
                                hash = "file:" + h
                        }</span>
                }
                <span class="cov0" title="0">b.config.Cmd = []string{"/bin/sh", "-c", fmt.Sprintf("#(nop) ADD %s in %s", hash, dest)}
                hit, err := b.probeCache()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // If we do not have a hash, never use the cache
                <span class="cov0" title="0">if hit &amp;&amp; hash != "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Create the container and start it
        <span class="cov0" title="0">container, _, err := b.runtime.Create(b.config, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.tmpContainers[container.ID] = struct{}{}

        if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer container.Unmount()

        if err := b.addContext(container, origPath, destPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := b.commit(container.ID, cmd, fmt.Sprintf("ADD %s in %s", orig, dest)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.config.Cmd = cmd
        return nil</span>
}

type StdoutFormater struct {
        io.Writer
        *utils.StreamFormatter
}

func (sf *StdoutFormater) Write(buf []byte) (int, error) <span class="cov0" title="0">{
        formattedBuf := sf.StreamFormatter.FormatStream(string(buf))
        n, err := sf.Writer.Write(formattedBuf)
        if n != len(formattedBuf) </span><span class="cov0" title="0">{
                return n, io.ErrShortWrite
        }</span>
        <span class="cov0" title="0">return len(buf), err</span>
}

type StderrFormater struct {
        io.Writer
        *utils.StreamFormatter
}

func (sf *StderrFormater) Write(buf []byte) (int, error) <span class="cov0" title="0">{
        formattedBuf := sf.StreamFormatter.FormatStream("\033[91m" + string(buf) + "\033[0m")
        n, err := sf.Writer.Write(formattedBuf)
        if n != len(formattedBuf) </span><span class="cov0" title="0">{
                return n, io.ErrShortWrite
        }</span>
        <span class="cov0" title="0">return len(buf), err</span>
}

func (b *buildFile) run() (string, error) <span class="cov0" title="0">{
        if b.image == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Please provide a source image with `from` prior to run")
        }</span>
        <span class="cov0" title="0">b.config.Image = b.image

        // Create the container and start it
        c, _, err := b.runtime.Create(b.config, "")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">b.tmpContainers[c.ID] = struct{}{}
        fmt.Fprintf(b.outStream, " ---&gt; Running in %s\n", utils.TruncateID(c.ID))

        // override the entry point that may have been picked up from the base image
        c.Path = b.config.Cmd[0]
        c.Args = b.config.Cmd[1:]

        var errCh chan error

        if b.verbose </span><span class="cov0" title="0">{
                errCh = utils.Go(func() error </span><span class="cov0" title="0">{
                        return &lt;-c.Attach(nil, nil, b.outStream, b.errStream)
                }</span>)
        }

        //start the container
        <span class="cov0" title="0">if err := c.Start(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if errCh != nil </span><span class="cov0" title="0">{
                if err := &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        // Wait for it to finish
        <span class="cov0" title="0">if ret := c.Wait(); ret != 0 </span><span class="cov0" title="0">{
                err := &amp;utils.JSONError{
                        Message: fmt.Sprintf("The command %v returned a non-zero code: %d", b.config.Cmd, ret),
                        Code:    ret,
                }
                return "", err
        }</span>

        <span class="cov0" title="0">return c.ID, nil</span>
}

// Commit the container &lt;id&gt; with the autorun command &lt;autoCmd&gt;
func (b *buildFile) commit(id string, autoCmd []string, comment string) error <span class="cov0" title="0">{
        if b.image == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Please provide a source image with `from` prior to commit")
        }</span>
        <span class="cov0" title="0">b.config.Image = b.image
        if id == "" </span><span class="cov0" title="0">{
                cmd := b.config.Cmd
                b.config.Cmd = []string{"/bin/sh", "-c", "#(nop) " + comment}
                defer func(cmd []string) </span><span class="cov0" title="0">{ b.config.Cmd = cmd }</span>(cmd)

                <span class="cov0" title="0">hit, err := b.probeCache()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if hit </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">container, warnings, err := b.runtime.Create(b.config, "")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, warning := range warnings </span><span class="cov0" title="0">{
                        fmt.Fprintf(b.outStream, " ---&gt; [Warning] %s\n", warning)
                }</span>
                <span class="cov0" title="0">b.tmpContainers[container.ID] = struct{}{}
                fmt.Fprintf(b.outStream, " ---&gt; Running in %s\n", utils.TruncateID(container.ID))
                id = container.ID
                if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer container.Unmount()</span>
        }

        <span class="cov0" title="0">container := b.runtime.Get(id)
        if container == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("An error occured while creating the container")
        }</span>

        // Note: Actually copy the struct
        <span class="cov0" title="0">autoConfig := *b.config
        autoConfig.Cmd = autoCmd
        // Commit the container
        image, err := b.runtime.Commit(container, "", "", "", b.maintainer, &amp;autoConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.tmpImages[image.ID] = struct{}{}
        b.image = image.ID
        return nil</span>
}

// Long lines can be split with a backslash
var lineContinuation = regexp.MustCompile(`\s*\\\s*\n`)

func (b *buildFile) Build(context io.Reader) (string, error) <span class="cov0" title="0">{
        tmpdirPath, err := ioutil.TempDir("", "docker-build")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">b.context = &amp;utils.TarSum{Reader: context, DisableCompression: true}
        if err := archive.Untar(b.context, tmpdirPath, nil); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tmpdirPath)

        b.contextPath = tmpdirPath
        filename := path.Join(tmpdirPath, "Dockerfile")
        if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Can't build a directory with no Dockerfile")
        }</span>
        <span class="cov0" title="0">fileBytes, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(fileBytes) == 0 </span><span class="cov0" title="0">{
                return "", ErrDockerfileEmpty
        }</span>
        <span class="cov0" title="0">dockerfile := string(fileBytes)
        dockerfile = lineContinuation.ReplaceAllString(dockerfile, "")
        stepN := 0
        for _, line := range strings.Split(dockerfile, "\n") </span><span class="cov0" title="0">{
                line = strings.Trim(strings.Replace(line, "\t", " ", -1), " \t\r\n")
                // Skip comments and empty line
                if len(line) == 0 || line[0] == '#' </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">tmp := strings.SplitN(line, " ", 2)
                if len(tmp) != 2 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("Invalid Dockerfile format")
                }</span>
                <span class="cov0" title="0">instruction := strings.ToLower(strings.Trim(tmp[0], " "))
                arguments := strings.Trim(tmp[1], " ")

                method, exists := reflect.TypeOf(b).MethodByName("Cmd" + strings.ToUpper(instruction[:1]) + strings.ToLower(instruction[1:]))
                if !exists </span><span class="cov0" title="0">{
                        fmt.Fprintf(b.errStream, "# Skipping unknown instruction %s\n", strings.ToUpper(instruction))
                        continue</span>
                }

                <span class="cov0" title="0">stepN += 1
                fmt.Fprintf(b.outStream, "Step %d : %s %s\n", stepN, strings.ToUpper(instruction), arguments)

                ret := method.Func.Call([]reflect.Value{reflect.ValueOf(b), reflect.ValueOf(arguments)})[0].Interface()
                if ret != nil </span><span class="cov0" title="0">{
                        return "", ret.(error)
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(b.outStream, " ---&gt; %s\n", utils.TruncateID(b.image))</span>
        }
        <span class="cov0" title="0">if b.image != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(b.outStream, "Successfully built %s\n", utils.TruncateID(b.image))
                if b.rm </span><span class="cov0" title="0">{
                        b.clearTmp(b.tmpContainers)
                }</span>
                <span class="cov0" title="0">return b.image, nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("No image was generated. This may be because the Dockerfile does not, like, do anything.\n")</span>
}

func NewBuildFile(srv *Server, outStream, errStream io.Writer, verbose, utilizeCache, rm bool, outOld io.Writer, sf *utils.StreamFormatter, auth *auth.AuthConfig) BuildFile <span class="cov0" title="0">{
        return &amp;buildFile{
                runtime:       srv.runtime,
                srv:           srv,
                config:        &amp;Config{},
                outStream:     outStream,
                errStream:     errStream,
                tmpContainers: make(map[string]struct{}),
                tmpImages:     make(map[string]struct{}),
                verbose:       verbose,
                utilizeCache:  utilizeCache,
                rm:            rm,
                sf:            sf,
                authConfig:    auth,
                outOld:        outOld,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package docker

import (
        "archive/tar"
        "bufio"
        "bytes"
        "encoding/base64"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/auth"
        "github.com/dotcloud/docker/engine"
        "github.com/dotcloud/docker/pkg/term"
        "github.com/dotcloud/docker/registry"
        "github.com/dotcloud/docker/utils"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "net/http/httputil"
        "net/url"
        "os"
        "os/signal"
        "path"
        "reflect"
        "regexp"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "syscall"
        "text/tabwriter"
        "text/template"
        "time"
)

var (
        GITCOMMIT string
        VERSION   string
)

var (
        ErrConnectionRefused = errors.New("Can't connect to docker daemon. Is 'docker -d' running on this host?")
)

func (cli *DockerCli) getMethod(name string) (func(...string) error, bool) <span class="cov0" title="0">{
        methodName := "Cmd" + strings.ToUpper(name[:1]) + strings.ToLower(name[1:])
        method := reflect.ValueOf(cli).MethodByName(methodName)
        if !method.IsValid() </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return method.Interface().(func(...string) error), true</span>
}

func ParseCommands(proto, addr string, args ...string) error <span class="cov0" title="0">{
        cli := NewDockerCli(os.Stdin, os.Stdout, os.Stderr, proto, addr)

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                method, exists := cli.getMethod(args[0])
                if !exists </span><span class="cov0" title="0">{
                        fmt.Println("Error: Command not found:", args[0])
                        return cli.CmdHelp(args[1:]...)
                }</span>
                <span class="cov0" title="0">return method(args[1:]...)</span>
        }
        <span class="cov0" title="0">return cli.CmdHelp(args...)</span>
}

func (cli *DockerCli) CmdHelp(args ...string) error <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                method, exists := cli.getMethod(args[0])
                if !exists </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "Error: Command not found: %s\n", args[0])
                }</span> <span class="cov0" title="0">else {
                        method("--help")
                        return nil
                }</span>
        }
        <span class="cov0" title="0">help := fmt.Sprintf("Usage: docker [OPTIONS] COMMAND [arg...]\n -H=[unix://%s]: tcp://host:port to bind/connect to or unix://path/to/socket to use\n\nA self-sufficient runtime for linux containers.\n\nCommands:\n", DEFAULTUNIXSOCKET)
        for _, command := range [][]string{
                {"attach", "Attach to a running container"},
                {"build", "Build a container from a Dockerfile"},
                {"commit", "Create a new image from a container's changes"},
                {"cp", "Copy files/folders from the containers filesystem to the host path"},
                {"diff", "Inspect changes on a container's filesystem"},
                {"events", "Get real time events from the server"},
                {"export", "Stream the contents of a container as a tar archive"},
                {"history", "Show the history of an image"},
                {"images", "List images"},
                {"import", "Create a new filesystem image from the contents of a tarball"},
                {"info", "Display system-wide information"},
                {"insert", "Insert a file in an image"},
                {"inspect", "Return low-level information on a container"},
                {"kill", "Kill a running container"},
                {"load", "Load an image from a tar archive"},
                {"login", "Register or Login to the docker registry server"},
                {"logs", "Fetch the logs of a container"},
                {"port", "Lookup the public-facing port which is NAT-ed to PRIVATE_PORT"},
                {"ps", "List containers"},
                {"pull", "Pull an image or a repository from the docker registry server"},
                {"push", "Push an image or a repository to the docker registry server"},
                {"restart", "Restart a running container"},
                {"rm", "Remove one or more containers"},
                {"rmi", "Remove one or more images"},
                {"run", "Run a command in a new container"},
                {"save", "Save an image to a tar archive"},
                {"search", "Search for an image in the docker index"},
                {"start", "Start a stopped container"},
                {"stop", "Stop a running container"},
                {"tag", "Tag an image into a repository"},
                {"top", "Lookup the running processes of a container"},
                {"version", "Show the docker version information"},
                {"wait", "Block until a container stops, then print its exit code"},
        } </span><span class="cov0" title="0">{
                help += fmt.Sprintf("    %-10.10s%s\n", command[0], command[1])
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(cli.err, "%s\n", help)
        return nil</span>
}

func (cli *DockerCli) CmdInsert(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("insert", "IMAGE URL PATH", "Insert a file from URL in the IMAGE at PATH")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 3 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        v.Set("url", cmd.Arg(1))
        v.Set("path", cmd.Arg(2))

        return cli.stream("POST", "/images/"+cmd.Arg(0)+"/insert?"+v.Encode(), nil, cli.out, nil)</span>
}

// mkBuildContext returns an archive of an empty context with the contents
// of `dockerfile` at the path ./Dockerfile
func MkBuildContext(dockerfile string, files [][2]string) (archive.Archive, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        tw := tar.NewWriter(buf)
        files = append(files, [2]string{"Dockerfile", dockerfile})
        for _, file := range files </span><span class="cov0" title="0">{
                name, content := file[0], file[1]
                hdr := &amp;tar.Header{
                        Name: name,
                        Size: int64(len(content)),
                }
                if err := tw.WriteHeader(hdr); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if _, err := tw.Write([]byte(content)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if err := tw.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return buf, nil</span>
}

func (cli *DockerCli) CmdBuild(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("build", "[OPTIONS] PATH | URL | -", "Build a new container image from the source code at PATH")
        tag := cmd.String("t", "", "Repository name (and optionally a tag) to be applied to the resulting image in case of success")
        suppressOutput := cmd.Bool("q", false, "Suppress verbose build output")
        noCache := cmd.Bool("no-cache", false, "Do not use cache when building the image")
        rm := cmd.Bool("rm", false, "Remove intermediate containers after a successful build")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var (
                context  archive.Archive
                isRemote bool
                err      error
        )

        if cmd.Arg(0) == "-" </span><span class="cov0" title="0">{
                // As a special case, 'docker build -' will build from an empty context with the
                // contents of stdin as a Dockerfile
                dockerfile, err := ioutil.ReadAll(cli.in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">context, err = MkBuildContext(string(dockerfile), nil)</span>
        } <span class="cov0" title="0">else if utils.IsURL(cmd.Arg(0)) || utils.IsGIT(cmd.Arg(0)) </span><span class="cov0" title="0">{
                isRemote = true
        }</span> <span class="cov0" title="0">else {
                if _, err := os.Stat(cmd.Arg(0)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">filename := path.Join(cmd.Arg(0), "Dockerfile")
                if _, err = os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("no Dockerfile found in %s", cmd.Arg(0))
                }</span>
                <span class="cov0" title="0">context, err = archive.Tar(cmd.Arg(0), archive.Uncompressed)</span>
        }
        <span class="cov0" title="0">var body io.Reader
        // Setup an upload progress bar
        // FIXME: ProgressReader shouldn't be this annoying to use
        if context != nil </span><span class="cov0" title="0">{
                sf := utils.NewStreamFormatter(false)
                body = utils.ProgressReader(ioutil.NopCloser(context), 0, cli.err, sf, true, "", "Uploading context")
        }</span>
        // Upload the build context
        <span class="cov0" title="0">v := &amp;url.Values{}
        v.Set("t", *tag)

        if *suppressOutput </span><span class="cov0" title="0">{
                v.Set("q", "1")
        }</span>
        <span class="cov0" title="0">if isRemote </span><span class="cov0" title="0">{
                v.Set("remote", cmd.Arg(0))
        }</span>
        <span class="cov0" title="0">if *noCache </span><span class="cov0" title="0">{
                v.Set("nocache", "1")
        }</span>
        <span class="cov0" title="0">if *rm </span><span class="cov0" title="0">{
                v.Set("rm", "1")
        }</span>

        <span class="cov0" title="0">headers := http.Header(make(map[string][]string))
        buf, err := json.Marshal(cli.configFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">headers.Add("X-Registry-Auth", base64.URLEncoding.EncodeToString(buf))

        if context != nil </span><span class="cov0" title="0">{
                headers.Set("Content-Type", "application/tar")
        }</span>
        <span class="cov0" title="0">err = cli.stream("POST", fmt.Sprintf("/build?%s", v.Encode()), body, cli.out, headers)
        if jerr, ok := err.(*utils.JSONError); ok </span><span class="cov0" title="0">{
                // If no error code is set, default to 1
                if jerr.Code == 0 </span><span class="cov0" title="0">{
                        jerr.Code = 1
                }</span>
                <span class="cov0" title="0">return &amp;utils.StatusError{Status: jerr.Message, StatusCode: jerr.Code}</span>
        }
        <span class="cov0" title="0">return err</span>
}

// 'docker login': login / register a user to registry service.
func (cli *DockerCli) CmdLogin(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("login", "[OPTIONS] [SERVER]", "Register or Login to a docker registry server, if no server is specified \""+auth.IndexServerAddress()+"\" is the default.")

        var username, password, email string

        cmd.StringVar(&amp;username, "u", "", "username")
        cmd.StringVar(&amp;password, "p", "", "password")
        cmd.StringVar(&amp;email, "e", "", "email")
        err := cmd.Parse(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">serverAddress := auth.IndexServerAddress()
        if len(cmd.Args()) &gt; 0 </span><span class="cov0" title="0">{
                serverAddress, err = registry.ExpandAndVerifyRegistryUrl(cmd.Arg(0))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(cli.out, "Login against server at %s\n", serverAddress)</span>
        }

        <span class="cov0" title="0">promptDefault := func(prompt string, configDefault string) </span><span class="cov0" title="0">{
                if configDefault == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, "%s: ", prompt)
                }</span> <span class="cov0" title="0">else {
                        fmt.Fprintf(cli.out, "%s (%s): ", prompt, configDefault)
                }</span>
        }

        <span class="cov0" title="0">readInput := func(in io.Reader, out io.Writer) string </span><span class="cov0" title="0">{
                reader := bufio.NewReader(in)
                line, _, err := reader.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(out, err.Error())
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return string(line)</span>
        }

        <span class="cov0" title="0">cli.LoadConfigFile()
        authconfig, ok := cli.configFile.Configs[serverAddress]
        if !ok </span><span class="cov0" title="0">{
                authconfig = auth.AuthConfig{}
        }</span>

        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                promptDefault("Username", authconfig.Username)
                username = readInput(cli.in, cli.out)
                if username == "" </span><span class="cov0" title="0">{
                        username = authconfig.Username
                }</span>
        }
        <span class="cov0" title="0">if username != authconfig.Username </span><span class="cov0" title="0">{
                if password == "" </span><span class="cov0" title="0">{
                        oldState, _ := term.SaveState(cli.terminalFd)
                        fmt.Fprintf(cli.out, "Password: ")
                        term.DisableEcho(cli.terminalFd, oldState)

                        password = readInput(cli.in, cli.out)
                        fmt.Fprint(cli.out, "\n")

                        term.RestoreTerminal(cli.terminalFd, oldState)
                        if password == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("Error : Password Required")
                        }</span>
                }

                <span class="cov0" title="0">if email == "" </span><span class="cov0" title="0">{
                        promptDefault("Email", authconfig.Email)
                        email = readInput(cli.in, cli.out)
                        if email == "" </span><span class="cov0" title="0">{
                                email = authconfig.Email
                        }</span>
                }
        } <span class="cov0" title="0">else {
                password = authconfig.Password
                email = authconfig.Email
        }</span>
        <span class="cov0" title="0">authconfig.Username = username
        authconfig.Password = password
        authconfig.Email = email
        authconfig.ServerAddress = serverAddress
        cli.configFile.Configs[serverAddress] = authconfig

        body, statusCode, err := cli.call("POST", "/auth", cli.configFile.Configs[serverAddress])
        if statusCode == 401 </span><span class="cov0" title="0">{
                delete(cli.configFile.Configs, serverAddress)
                auth.SaveConfig(cli.configFile)
                return err
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var out2 APIAuth
        err = json.Unmarshal(body, &amp;out2)
        if err != nil </span><span class="cov0" title="0">{
                cli.configFile, _ = auth.LoadConfig(os.Getenv("HOME"))
                return err
        }</span>
        <span class="cov0" title="0">auth.SaveConfig(cli.configFile)
        if out2.Status != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, "%s\n", out2.Status)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 'docker wait': block until a container stops
func (cli *DockerCli) CmdWait(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("wait", "CONTAINER [CONTAINER...]", "Block until a container stops, then print its exit code.")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>
        <span class="cov0" title="0">var encounteredError error
        for _, name := range cmd.Args() </span><span class="cov0" title="0">{
                status, err := waitForExit(cli, name)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "%s\n", err)
                        encounteredError = fmt.Errorf("Error: failed to wait one or more containers")
                }</span> <span class="cov0" title="0">else {
                        fmt.Fprintf(cli.out, "%d\n", status)
                }</span>
        }
        <span class="cov0" title="0">return encounteredError</span>
}

// 'docker version': show version information
func (cli *DockerCli) CmdVersion(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("version", "", "Show the docker version information.")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cmd.NArg() &gt; 0 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>
        <span class="cov0" title="0">if VERSION != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, "Client version: %s\n", VERSION)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(cli.out, "Go version (client): %s\n", runtime.Version())
        if GITCOMMIT != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, "Git commit (client): %s\n", GITCOMMIT)
        }</span>

        <span class="cov0" title="0">body, _, err := cli.call("GET", "/version", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">out := engine.NewOutput()
        remoteVersion, err := out.AddEnv()
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorf("Error reading remote version: %s\n", err)
                return err
        }</span>
        <span class="cov0" title="0">if _, err := out.Write(body); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("Error reading remote version: %s\n", err)
                return err
        }</span>
        <span class="cov0" title="0">out.Close()
        fmt.Fprintf(cli.out, "Server version: %s\n", remoteVersion.Get("Version"))
        fmt.Fprintf(cli.out, "Git commit (server): %s\n", remoteVersion.Get("GitCommit"))
        fmt.Fprintf(cli.out, "Go version (server): %s\n", remoteVersion.Get("GoVersion"))
        release := utils.GetReleaseVersion()
        if release != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, "Last stable version: %s", release)
                if (VERSION != "" || remoteVersion.Exists("Version")) &amp;&amp; (strings.Trim(VERSION, "-dev") != release || strings.Trim(remoteVersion.Get("Version"), "-dev") != release) </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, ", please update docker")
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(cli.out, "\n")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// 'docker info': display system-wide information.
func (cli *DockerCli) CmdInfo(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("info", "", "Display system-wide information")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &gt; 0 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">body, _, err := cli.call("GET", "/info", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">out := engine.NewOutput()
        remoteInfo, err := out.AddEnv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := out.Write(body); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("Error reading remote info: %s\n", err)
                return err
        }</span>
        <span class="cov0" title="0">out.Close()

        fmt.Fprintf(cli.out, "Containers: %d\n", remoteInfo.GetInt("Containers"))
        fmt.Fprintf(cli.out, "Images: %d\n", remoteInfo.GetInt("Images"))
        fmt.Fprintf(cli.out, "Driver: %s\n", remoteInfo.Get("Driver"))
        var driverStatus [][2]string
        if err := remoteInfo.GetJson("DriverStatus", &amp;driverStatus); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, pair := range driverStatus </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, " %s: %s\n", pair[0], pair[1])
        }</span>
        <span class="cov0" title="0">if remoteInfo.GetBool("Debug") || os.Getenv("DEBUG") != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, "Debug mode (server): %v\n", remoteInfo.GetBool("Debug"))
                fmt.Fprintf(cli.out, "Debug mode (client): %v\n", os.Getenv("DEBUG") != "")
                fmt.Fprintf(cli.out, "Fds: %d\n", remoteInfo.GetInt("NFd"))
                fmt.Fprintf(cli.out, "Goroutines: %d\n", remoteInfo.GetInt("NGoroutines"))
                fmt.Fprintf(cli.out, "LXC Version: %s\n", remoteInfo.Get("LXCVersion"))
                fmt.Fprintf(cli.out, "EventsListeners: %d\n", remoteInfo.GetInt("NEventsListener"))
                fmt.Fprintf(cli.out, "Kernel Version: %s\n", remoteInfo.Get("KernelVersion"))

                if initSha1 := remoteInfo.Get("InitSha1"); initSha1 != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, "Init SHA1: %s\n", initSha1)
                }</span>
                <span class="cov0" title="0">if initPath := remoteInfo.Get("InitPath"); initPath != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, "Init Path: %s\n", initPath)
                }</span>
        }

        <span class="cov0" title="0">if len(remoteInfo.GetList("IndexServerAddress")) != 0 </span><span class="cov0" title="0">{
                cli.LoadConfigFile()
                u := cli.configFile.Configs[remoteInfo.Get("IndexServerAddress")].Username
                if len(u) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, "Username: %v\n", u)
                        fmt.Fprintf(cli.out, "Registry: %v\n", remoteInfo.GetList("IndexServerAddress"))
                }</span>
        }
        <span class="cov0" title="0">if !remoteInfo.GetBool("MemoryLimit") </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "WARNING: No memory limit support\n")
        }</span>
        <span class="cov0" title="0">if !remoteInfo.GetBool("SwapLimit") </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "WARNING: No swap limit support\n")
        }</span>
        <span class="cov0" title="0">if !remoteInfo.GetBool("IPv4Forwarding") </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "WARNING: IPv4 forwarding is disabled.\n")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdStop(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("stop", "[OPTIONS] CONTAINER [CONTAINER...]", "Stop a running container (Send SIGTERM, and then SIGKILL after grace period)")
        nSeconds := cmd.Int("t", 10, "Number of seconds to wait for the container to stop before killing it.")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        v.Set("t", strconv.Itoa(*nSeconds))

        var encounteredError error
        for _, name := range cmd.Args() </span><span class="cov0" title="0">{
                _, _, err := cli.call("POST", "/containers/"+name+"/stop?"+v.Encode(), nil)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "%s\n", err)
                        encounteredError = fmt.Errorf("Error: failed to stop one or more containers")
                }</span> <span class="cov0" title="0">else {
                        fmt.Fprintf(cli.out, "%s\n", name)
                }</span>
        }
        <span class="cov0" title="0">return encounteredError</span>
}

func (cli *DockerCli) CmdRestart(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("restart", "[OPTIONS] CONTAINER [CONTAINER...]", "Restart a running container")
        nSeconds := cmd.Int("t", 10, "Number of seconds to try to stop for before killing the container. Once killed it will then be restarted. Default=10")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        v.Set("t", strconv.Itoa(*nSeconds))

        var encounteredError error
        for _, name := range cmd.Args() </span><span class="cov0" title="0">{
                _, _, err := cli.call("POST", "/containers/"+name+"/restart?"+v.Encode(), nil)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "%s\n", err)
                        encounteredError = fmt.Errorf("Error: failed to  restart one or more containers")
                }</span> <span class="cov0" title="0">else {
                        fmt.Fprintf(cli.out, "%s\n", name)
                }</span>
        }
        <span class="cov0" title="0">return encounteredError</span>
}

func (cli *DockerCli) forwardAllSignals(cid string) chan os.Signal <span class="cov0" title="0">{
        sigc := make(chan os.Signal, 1)
        utils.CatchAll(sigc)
        go func() </span><span class="cov0" title="0">{
                for s := range sigc </span><span class="cov0" title="0">{
                        if s == syscall.SIGCHLD </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, _, err := cli.call("POST", fmt.Sprintf("/containers/%s/kill?signal=%d", cid, s), nil); err != nil </span><span class="cov0" title="0">{
                                utils.Debugf("Error sending signal: %s", err)
                        }</span>
                }
        }()
        <span class="cov0" title="0">return sigc</span>
}

func (cli *DockerCli) CmdStart(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("start", "CONTAINER [CONTAINER...]", "Restart a stopped container")
        attach := cmd.Bool("a", false, "Attach container's stdout/stderr and forward all signals to the process")
        openStdin := cmd.Bool("i", false, "Attach container's stdin")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var cErr chan error
        var tty bool
        if *attach || *openStdin </span><span class="cov0" title="0">{
                if cmd.NArg() &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Impossible to start and attach multiple containers at once.")
                }</span>

                <span class="cov0" title="0">body, _, err := cli.call("GET", "/containers/"+cmd.Arg(0)+"/json", nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">container := &amp;Container{}
                err = json.Unmarshal(body, container)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">tty = container.Config.Tty

                if !container.Config.Tty </span><span class="cov0" title="0">{
                        sigc := cli.forwardAllSignals(cmd.Arg(0))
                        defer utils.StopCatch(sigc)
                }</span>

                <span class="cov0" title="0">var in io.ReadCloser

                v := url.Values{}
                v.Set("stream", "1")
                if *openStdin &amp;&amp; container.Config.OpenStdin </span><span class="cov0" title="0">{
                        v.Set("stdin", "1")
                        in = cli.in
                }</span>
                <span class="cov0" title="0">v.Set("stdout", "1")
                v.Set("stderr", "1")

                cErr = utils.Go(func() error </span><span class="cov0" title="0">{
                        return cli.hijack("POST", "/containers/"+cmd.Arg(0)+"/attach?"+v.Encode(), container.Config.Tty, in, cli.out, cli.err, nil)
                }</span>)
        }

        <span class="cov0" title="0">var encounteredError error
        for _, name := range cmd.Args() </span><span class="cov0" title="0">{
                _, _, err := cli.call("POST", "/containers/"+name+"/start", nil)
                if err != nil </span><span class="cov0" title="0">{
                        if !*attach || !*openStdin </span><span class="cov0" title="0">{
                                fmt.Fprintf(cli.err, "%s\n", err)
                                encounteredError = fmt.Errorf("Error: failed to start one or more containers")
                        }</span>
                } <span class="cov0" title="0">else {
                        if !*attach || !*openStdin </span><span class="cov0" title="0">{
                                fmt.Fprintf(cli.out, "%s\n", name)
                        }</span>
                }
        }
        <span class="cov0" title="0">if encounteredError != nil </span><span class="cov0" title="0">{
                if *openStdin || *attach </span><span class="cov0" title="0">{
                        cli.in.Close()
                        &lt;-cErr
                }</span>
                <span class="cov0" title="0">return encounteredError</span>
        }

        <span class="cov0" title="0">if *openStdin || *attach </span><span class="cov0" title="0">{
                if tty &amp;&amp; cli.isTerminal </span><span class="cov0" title="0">{
                        if err := cli.monitorTtySize(cmd.Arg(0)); err != nil </span><span class="cov0" title="0">{
                                utils.Errorf("Error monitoring TTY size: %s\n", err)
                        }</span>
                }
                <span class="cov0" title="0">return &lt;-cErr</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdInspect(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("inspect", "CONTAINER|IMAGE [CONTAINER|IMAGE...]", "Return low-level information on a container/image")
        tmplStr := cmd.String("format", "", "Format the output using the given go template.")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var tmpl *template.Template
        if *tmplStr != "" </span><span class="cov0" title="0">{
                var err error
                if tmpl, err = template.New("").Parse(*tmplStr); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "Template parsing error: %v\n", err)
                        return &amp;utils.StatusError{StatusCode: 64,
                                Status: "Template parsing error: " + err.Error()}
                }</span>
        }

        <span class="cov0" title="0">indented := new(bytes.Buffer)
        indented.WriteByte('[')
        status := 0

        for _, name := range cmd.Args() </span><span class="cov0" title="0">{
                obj, _, err := cli.call("GET", "/containers/"+name+"/json", nil)
                if err != nil </span><span class="cov0" title="0">{
                        obj, _, err = cli.call("GET", "/images/"+name+"/json", nil)
                        if err != nil </span><span class="cov0" title="0">{
                                if strings.Contains(err.Error(), "No such") </span><span class="cov0" title="0">{
                                        fmt.Fprintf(cli.err, "Error: No such image or container: %s\n", name)
                                }</span> <span class="cov0" title="0">else {
                                        fmt.Fprintf(cli.err, "%s", err)
                                }</span>
                                <span class="cov0" title="0">status = 1
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if tmpl == nil </span><span class="cov0" title="0">{
                        if err = json.Indent(indented, obj, "", "    "); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(cli.err, "%s\n", err)
                                status = 1
                                continue</span>
                        }
                } <span class="cov0" title="0">else {
                        // Has template, will render
                        var value interface{}
                        if err := json.Unmarshal(obj, &amp;value); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(cli.err, "%s\n", err)
                                status = 1
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := tmpl.Execute(cli.out, value); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">cli.out.Write([]byte{'\n'})</span>
                }
                <span class="cov0" title="0">indented.WriteString(",")</span>
        }

        <span class="cov0" title="0">if indented.Len() &gt; 1 </span><span class="cov0" title="0">{
                // Remove trailing ','
                indented.Truncate(indented.Len() - 1)
        }</span>
        <span class="cov0" title="0">indented.WriteByte(']')

        if tmpl == nil </span><span class="cov0" title="0">{
                if _, err := io.Copy(cli.out, indented); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if status != 0 </span><span class="cov0" title="0">{
                return &amp;utils.StatusError{StatusCode: status}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdTop(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("top", "CONTAINER [ps OPTIONS]", "Lookup the running processes of a container")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() == 0 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>
        <span class="cov0" title="0">val := url.Values{}
        if cmd.NArg() &gt; 1 </span><span class="cov0" title="0">{
                val.Set("ps_args", strings.Join(cmd.Args()[1:], " "))
        }</span>

        <span class="cov0" title="0">body, _, err := cli.call("GET", "/containers/"+cmd.Arg(0)+"/top?"+val.Encode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">procs := APITop{}
        err = json.Unmarshal(body, &amp;procs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w := tabwriter.NewWriter(cli.out, 20, 1, 3, ' ', 0)
        fmt.Fprintln(w, strings.Join(procs.Titles, "\t"))
        for _, proc := range procs.Processes </span><span class="cov0" title="0">{
                fmt.Fprintln(w, strings.Join(proc, "\t"))
        }</span>
        <span class="cov0" title="0">w.Flush()
        return nil</span>
}

func (cli *DockerCli) CmdPort(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("port", "CONTAINER PRIVATE_PORT", "Lookup the public-facing port which is NAT-ed to PRIVATE_PORT")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 2 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">port := cmd.Arg(1)
        proto := "tcp"
        parts := strings.SplitN(port, "/", 2)
        if len(parts) == 2 &amp;&amp; len(parts[1]) != 0 </span><span class="cov0" title="0">{
                port = parts[0]
                proto = parts[1]
        }</span>
        <span class="cov0" title="0">body, _, err := cli.call("GET", "/containers/"+cmd.Arg(0)+"/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var out Container
        err = json.Unmarshal(body, &amp;out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if frontends, exists := out.NetworkSettings.Ports[Port(port+"/"+proto)]; exists &amp;&amp; frontends != nil </span><span class="cov0" title="0">{
                for _, frontend := range frontends </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, "%s:%s\n", frontend.HostIp, frontend.HostPort)
                }</span>
        } <span class="cov0" title="0">else {
                return fmt.Errorf("Error: No public port '%s' published for %s", cmd.Arg(1), cmd.Arg(0))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 'docker rmi IMAGE' removes all images with the name IMAGE
func (cli *DockerCli) CmdRmi(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("rmi", "IMAGE [IMAGE...]", "Remove one or more images")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var encounteredError error
        for _, name := range cmd.Args() </span><span class="cov0" title="0">{
                body, _, err := cli.call("DELETE", "/images/"+name, nil)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "%s\n", err)
                        encounteredError = fmt.Errorf("Error: failed to remove one or more images")
                }</span> <span class="cov0" title="0">else {
                        var outs []APIRmi
                        err = json.Unmarshal(body, &amp;outs)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(cli.err, "%s\n", err)
                                encounteredError = fmt.Errorf("Error: failed to remove one or more images")
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, out := range outs </span><span class="cov0" title="0">{
                                if out.Deleted != "" </span><span class="cov0" title="0">{
                                        fmt.Fprintf(cli.out, "Deleted: %s\n", out.Deleted)
                                }</span> <span class="cov0" title="0">else {
                                        fmt.Fprintf(cli.out, "Untagged: %s\n", out.Untagged)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return encounteredError</span>
}

func (cli *DockerCli) CmdHistory(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("history", "[OPTIONS] IMAGE", "Show the history of an image")
        quiet := cmd.Bool("q", false, "only show numeric IDs")
        noTrunc := cmd.Bool("notrunc", false, "Don't truncate output")

        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">body, _, err := cli.call("GET", "/images/"+cmd.Arg(0)+"/history", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outs []APIHistory
        err = json.Unmarshal(body, &amp;outs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">w := tabwriter.NewWriter(cli.out, 20, 1, 3, ' ', 0)
        if !*quiet </span><span class="cov0" title="0">{
                fmt.Fprintln(w, "IMAGE\tCREATED\tCREATED BY\tSIZE")
        }</span>

        <span class="cov0" title="0">for _, out := range outs </span><span class="cov0" title="0">{
                if !*quiet </span><span class="cov0" title="0">{
                        if *noTrunc </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, "%s\t", out.ID)
                        }</span> <span class="cov0" title="0">else {
                                fmt.Fprintf(w, "%s\t", utils.TruncateID(out.ID))
                        }</span>

                        <span class="cov0" title="0">fmt.Fprintf(w, "%s ago\t", utils.HumanDuration(time.Now().UTC().Sub(time.Unix(out.Created, 0))))

                        if *noTrunc </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, "%s\t", out.CreatedBy)
                        }</span> <span class="cov0" title="0">else {
                                fmt.Fprintf(w, "%s\t", utils.Trunc(out.CreatedBy, 45))
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(w, "%s\n", utils.HumanSize(out.Size))</span>
                } <span class="cov0" title="0">else {
                        if *noTrunc </span><span class="cov0" title="0">{
                                fmt.Fprintln(w, out.ID)
                        }</span> <span class="cov0" title="0">else {
                                fmt.Fprintln(w, utils.TruncateID(out.ID))
                        }</span>
                }
        }
        <span class="cov0" title="0">w.Flush()
        return nil</span>
}

func (cli *DockerCli) CmdRm(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("rm", "[OPTIONS] CONTAINER [CONTAINER...]", "Remove one or more containers")
        v := cmd.Bool("v", false, "Remove the volumes associated to the container")
        link := cmd.Bool("link", false, "Remove the specified link and not the underlying container")

        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>
        <span class="cov0" title="0">val := url.Values{}
        if *v </span><span class="cov0" title="0">{
                val.Set("v", "1")
        }</span>
        <span class="cov0" title="0">if *link </span><span class="cov0" title="0">{
                val.Set("link", "1")
        }</span>

        <span class="cov0" title="0">var encounteredError error
        for _, name := range cmd.Args() </span><span class="cov0" title="0">{
                _, _, err := cli.call("DELETE", "/containers/"+name+"?"+val.Encode(), nil)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "%s\n", err)
                        encounteredError = fmt.Errorf("Error: failed to remove one or more containers")
                }</span> <span class="cov0" title="0">else {
                        fmt.Fprintf(cli.out, "%s\n", name)
                }</span>
        }
        <span class="cov0" title="0">return encounteredError</span>
}

// 'docker kill NAME' kills a running container
func (cli *DockerCli) CmdKill(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("kill", "CONTAINER [CONTAINER...]", "Kill a running container (send SIGKILL)")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var encounteredError error
        for _, name := range args </span><span class="cov0" title="0">{
                if _, _, err := cli.call("POST", "/containers/"+name+"/kill", nil); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.err, "%s\n", err)
                        encounteredError = fmt.Errorf("Error: failed to kill one or more containers")
                }</span> <span class="cov0" title="0">else {
                        fmt.Fprintf(cli.out, "%s\n", name)
                }</span>
        }
        <span class="cov0" title="0">return encounteredError</span>
}

func (cli *DockerCli) CmdImport(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("import", "URL|- [REPOSITORY[:TAG]]", "Create an empty filesystem image and import the contents of the tarball (.tar, .tar.gz, .tgz, .bzip, .tar.xz, .txz) into it, then optionally tag it.")

        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &lt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var src, repository, tag string

        if cmd.NArg() == 3 </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "[DEPRECATED] The format 'URL|- [REPOSITORY [TAG]]' as been deprecated. Please use URL|- [REPOSITORY[:TAG]]\n")
                src, repository, tag = cmd.Arg(0), cmd.Arg(1), cmd.Arg(2)
        }</span> <span class="cov0" title="0">else {
                src = cmd.Arg(0)
                repository, tag = utils.ParseRepositoryTag(cmd.Arg(1))
        }</span>
        <span class="cov0" title="0">v := url.Values{}
        v.Set("repo", repository)
        v.Set("tag", tag)
        v.Set("fromSrc", src)

        var in io.Reader

        if src == "-" </span><span class="cov0" title="0">{
                in = cli.in
        }</span>

        <span class="cov0" title="0">return cli.stream("POST", "/images/create?"+v.Encode(), in, cli.out, nil)</span>
}

func (cli *DockerCli) CmdPush(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("push", "NAME", "Push an image or a repository to the registry")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">name := cmd.Arg(0)

        if name == "" </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">cli.LoadConfigFile()

        // Resolve the Repository name from fqn to endpoint + name
        endpoint, _, err := registry.ResolveRepositoryName(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Resolve the Auth config relevant for this server
        <span class="cov0" title="0">authConfig := cli.configFile.ResolveAuthConfig(endpoint)
        // If we're not using a custom registry, we know the restrictions
        // applied to repository names and can warn the user in advance.
        // Custom repositories can have different rules, and we must also
        // allow pushing by image ID.
        if len(strings.SplitN(name, "/", 2)) == 1 </span><span class="cov0" title="0">{
                username := cli.configFile.Configs[auth.IndexServerAddress()].Username
                if username == "" </span><span class="cov0" title="0">{
                        username = "&lt;user&gt;"
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Impossible to push a \"root\" repository. Please rename your repository in &lt;user&gt;/&lt;repo&gt; (ex: %s/%s)", username, name)</span>
        }

        <span class="cov0" title="0">v := url.Values{}
        push := func(authConfig auth.AuthConfig) error </span><span class="cov0" title="0">{
                buf, err := json.Marshal(authConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">registryAuthHeader := []string{
                        base64.URLEncoding.EncodeToString(buf),
                }

                return cli.stream("POST", "/images/"+name+"/push?"+v.Encode(), nil, cli.out, map[string][]string{
                        "X-Registry-Auth": registryAuthHeader,
                })</span>
        }

        <span class="cov0" title="0">if err := push(authConfig); err != nil </span><span class="cov0" title="0">{
                if err.Error() == registry.ErrLoginRequired.Error() </span><span class="cov0" title="0">{
                        fmt.Fprintln(cli.out, "\nPlease login prior to push:")
                        if err := cli.CmdLogin(endpoint); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">authConfig := cli.configFile.ResolveAuthConfig(endpoint)
                        return push(authConfig)</span>
                }
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdPull(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("pull", "NAME", "Pull an image or a repository from the registry")
        tag := cmd.String("t", "", "Download tagged image in repository")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">remote, parsedTag := utils.ParseRepositoryTag(cmd.Arg(0))
        if *tag == "" </span><span class="cov0" title="0">{
                *tag = parsedTag
        }</span>

        // Resolve the Repository name from fqn to endpoint + name
        <span class="cov0" title="0">endpoint, _, err := registry.ResolveRepositoryName(remote)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cli.LoadConfigFile()

        // Resolve the Auth config relevant for this server
        authConfig := cli.configFile.ResolveAuthConfig(endpoint)
        v := url.Values{}
        v.Set("fromImage", remote)
        v.Set("tag", *tag)

        pull := func(authConfig auth.AuthConfig) error </span><span class="cov0" title="0">{
                buf, err := json.Marshal(authConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">registryAuthHeader := []string{
                        base64.URLEncoding.EncodeToString(buf),
                }

                return cli.stream("POST", "/images/create?"+v.Encode(), nil, cli.out, map[string][]string{
                        "X-Registry-Auth": registryAuthHeader,
                })</span>
        }

        <span class="cov0" title="0">if err := pull(authConfig); err != nil </span><span class="cov0" title="0">{
                if err.Error() == registry.ErrLoginRequired.Error() </span><span class="cov0" title="0">{
                        fmt.Fprintln(cli.out, "\nPlease login prior to pull:")
                        if err := cli.CmdLogin(endpoint); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">authConfig := cli.configFile.ResolveAuthConfig(endpoint)
                        return pull(authConfig)</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdImages(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("images", "[OPTIONS] [NAME]", "List images")
        quiet := cmd.Bool("q", false, "only show numeric IDs")
        all := cmd.Bool("a", false, "show all images (by default filter out the intermediate images used to build)")
        noTrunc := cmd.Bool("notrunc", false, "Don't truncate output")
        flViz := cmd.Bool("viz", false, "output graph in graphviz format")
        flTree := cmd.Bool("tree", false, "output graph in tree format")

        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() &gt; 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">filter := cmd.Arg(0)

        if *flViz || *flTree </span><span class="cov0" title="0">{
                body, _, err := cli.call("GET", "/images/json?all=1", nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var outs []APIImages
                if err := json.Unmarshal(body, &amp;outs); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var (
                        printNode  func(cli *DockerCli, noTrunc bool, image APIImages, prefix string)
                        startImage APIImages

                        roots    []APIImages
                        byParent = make(map[string][]APIImages)
                )

                for _, image := range outs </span><span class="cov0" title="0">{
                        if image.ParentId == "" </span><span class="cov0" title="0">{
                                roots = append(roots, image)
                        }</span> <span class="cov0" title="0">else {
                                if children, exists := byParent[image.ParentId]; exists </span><span class="cov0" title="0">{
                                        byParent[image.ParentId] = append(children, image)
                                }</span> <span class="cov0" title="0">else {
                                        byParent[image.ParentId] = []APIImages{image}
                                }</span>
                        }

                        <span class="cov0" title="0">if filter != "" </span><span class="cov0" title="0">{
                                if filter == image.ID || filter == utils.TruncateID(image.ID) </span><span class="cov0" title="0">{
                                        startImage = image
                                }</span>

                                <span class="cov0" title="0">for _, repotag := range image.RepoTags </span><span class="cov0" title="0">{
                                        if repotag == filter </span><span class="cov0" title="0">{
                                                startImage = image
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if *flViz </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, "digraph docker {\n")
                        printNode = (*DockerCli).printVizNode
                }</span> <span class="cov0" title="0">else {
                        printNode = (*DockerCli).printTreeNode
                }</span>

                <span class="cov0" title="0">if startImage.ID != "" </span><span class="cov0" title="0">{
                        cli.WalkTree(*noTrunc, &amp;[]APIImages{startImage}, byParent, "", printNode)
                }</span> <span class="cov0" title="0">else if filter == "" </span><span class="cov0" title="0">{
                        cli.WalkTree(*noTrunc, &amp;roots, byParent, "", printNode)
                }</span>
                <span class="cov0" title="0">if *flViz </span><span class="cov0" title="0">{
                        fmt.Fprintf(cli.out, " base [style=invisible]\n}\n")
                }</span>
        } <span class="cov0" title="0">else {
                v := url.Values{}
                if cmd.NArg() == 1 </span><span class="cov0" title="0">{
                        v.Set("filter", filter)
                }</span>
                <span class="cov0" title="0">if *all </span><span class="cov0" title="0">{
                        v.Set("all", "1")
                }</span>

                <span class="cov0" title="0">body, _, err := cli.call("GET", "/images/json?"+v.Encode(), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var outs []APIImages
                err = json.Unmarshal(body, &amp;outs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">w := tabwriter.NewWriter(cli.out, 20, 1, 3, ' ', 0)
                if !*quiet </span><span class="cov0" title="0">{
                        fmt.Fprintln(w, "REPOSITORY\tTAG\tIMAGE ID\tCREATED\tVIRTUAL SIZE")
                }</span>

                <span class="cov0" title="0">for _, out := range outs </span><span class="cov0" title="0">{
                        for _, repotag := range out.RepoTags </span><span class="cov0" title="0">{

                                repo, tag := utils.ParseRepositoryTag(repotag)

                                if !*noTrunc </span><span class="cov0" title="0">{
                                        out.ID = utils.TruncateID(out.ID)
                                }</span>

                                <span class="cov0" title="0">if !*quiet </span><span class="cov0" title="0">{
                                        fmt.Fprintf(w, "%s\t%s\t%s\t%s ago\t%s\n", repo, tag, out.ID, utils.HumanDuration(time.Now().UTC().Sub(time.Unix(out.Created, 0))), utils.HumanSize(out.VirtualSize))
                                }</span> <span class="cov0" title="0">else {
                                        fmt.Fprintln(w, out.ID)
                                }</span>
                        }
                }

                <span class="cov0" title="0">if !*quiet </span><span class="cov0" title="0">{
                        w.Flush()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) WalkTree(noTrunc bool, images *[]APIImages, byParent map[string][]APIImages, prefix string, printNode func(cli *DockerCli, noTrunc bool, image APIImages, prefix string)) <span class="cov0" title="0">{
        length := len(*images)
        if length &gt; 1 </span><span class="cov0" title="0">{
                for index, image := range *images </span><span class="cov0" title="0">{
                        if index+1 == length </span><span class="cov0" title="0">{
                                printNode(cli, noTrunc, image, prefix+"└─")
                                if subimages, exists := byParent[image.ID]; exists </span><span class="cov0" title="0">{
                                        cli.WalkTree(noTrunc, &amp;subimages, byParent, prefix+"  ", printNode)
                                }</span>
                        } <span class="cov0" title="0">else {
                                printNode(cli, noTrunc, image, prefix+"├─")
                                if subimages, exists := byParent[image.ID]; exists </span><span class="cov0" title="0">{
                                        cli.WalkTree(noTrunc, &amp;subimages, byParent, prefix+"│ ", printNode)
                                }</span>
                        }
                }
        } <span class="cov0" title="0">else {
                for _, image := range *images </span><span class="cov0" title="0">{
                        printNode(cli, noTrunc, image, prefix+"└─")
                        if subimages, exists := byParent[image.ID]; exists </span><span class="cov0" title="0">{
                                cli.WalkTree(noTrunc, &amp;subimages, byParent, prefix+"  ", printNode)
                        }</span>
                }
        }
}

func (cli *DockerCli) printVizNode(noTrunc bool, image APIImages, prefix string) <span class="cov0" title="0">{
        var (
                imageID  string
                parentID string
        )
        if noTrunc </span><span class="cov0" title="0">{
                imageID = image.ID
                parentID = image.ParentId
        }</span> <span class="cov0" title="0">else {
                imageID = utils.TruncateID(image.ID)
                parentID = utils.TruncateID(image.ParentId)
        }</span>
        <span class="cov0" title="0">if image.ParentId == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, " base -&gt; \"%s\" [style=invis]\n", imageID)
        }</span> <span class="cov0" title="0">else {
                fmt.Fprintf(cli.out, " \"%s\" -&gt; \"%s\"\n", parentID, imageID)
        }</span>
        <span class="cov0" title="0">if image.RepoTags[0] != "&lt;none&gt;:&lt;none&gt;" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, " \"%s\" [label=\"%s\\n%s\",shape=box,fillcolor=\"paleturquoise\",style=\"filled,rounded\"];\n",
                        imageID, imageID, strings.Join(image.RepoTags, "\\n"))
        }</span>
}

func (cli *DockerCli) printTreeNode(noTrunc bool, image APIImages, prefix string) <span class="cov0" title="0">{
        var imageID string
        if noTrunc </span><span class="cov0" title="0">{
                imageID = image.ID
        }</span> <span class="cov0" title="0">else {
                imageID = utils.TruncateID(image.ID)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(cli.out, "%s%s Virtual Size: %s", prefix, imageID, utils.HumanSize(image.VirtualSize))
        if image.RepoTags[0] != "&lt;none&gt;:&lt;none&gt;" </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, " Tags: %s\n", strings.Join(image.RepoTags, ", "))
        }</span> <span class="cov0" title="0">else {
                fmt.Fprint(cli.out, "\n")
        }</span>
}

func displayablePorts(ports []APIPort) string <span class="cov0" title="0">{
        result := []string{}
        for _, port := range ports </span><span class="cov0" title="0">{
                if port.IP == "" </span><span class="cov0" title="0">{
                        result = append(result, fmt.Sprintf("%d/%s", port.PublicPort, port.Type))
                }</span> <span class="cov0" title="0">else {
                        result = append(result, fmt.Sprintf("%s:%d-&gt;%d/%s", port.IP, port.PublicPort, port.PrivatePort, port.Type))
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(result)
        return strings.Join(result, ", ")</span>
}

func (cli *DockerCli) CmdPs(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("ps", "[OPTIONS]", "List containers")
        quiet := cmd.Bool("q", false, "Only display numeric IDs")
        size := cmd.Bool("s", false, "Display sizes")
        all := cmd.Bool("a", false, "Show all containers. Only running containers are shown by default.")
        noTrunc := cmd.Bool("notrunc", false, "Don't truncate output")
        nLatest := cmd.Bool("l", false, "Show only the latest created container, include non-running ones.")
        since := cmd.String("sinceId", "", "Show only containers created since Id, include non-running ones.")
        before := cmd.String("beforeId", "", "Show only container created before Id, include non-running ones.")
        last := cmd.Int("n", -1, "Show n last created containers, include non-running ones.")

        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">v := url.Values{}
        if *last == -1 &amp;&amp; *nLatest </span><span class="cov0" title="0">{
                *last = 1
        }</span>
        <span class="cov0" title="0">if *all </span><span class="cov0" title="0">{
                v.Set("all", "1")
        }</span>
        <span class="cov0" title="0">if *last != -1 </span><span class="cov0" title="0">{
                v.Set("limit", strconv.Itoa(*last))
        }</span>
        <span class="cov0" title="0">if *since != "" </span><span class="cov0" title="0">{
                v.Set("since", *since)
        }</span>
        <span class="cov0" title="0">if *before != "" </span><span class="cov0" title="0">{
                v.Set("before", *before)
        }</span>
        <span class="cov0" title="0">if *size </span><span class="cov0" title="0">{
                v.Set("size", "1")
        }</span>

        <span class="cov0" title="0">body, _, err := cli.call("GET", "/containers/json?"+v.Encode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outs []APIContainers
        err = json.Unmarshal(body, &amp;outs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w := tabwriter.NewWriter(cli.out, 20, 1, 3, ' ', 0)
        if !*quiet </span><span class="cov0" title="0">{
                fmt.Fprint(w, "CONTAINER ID\tIMAGE\tCOMMAND\tCREATED\tSTATUS\tPORTS\tNAMES")
                if *size </span><span class="cov0" title="0">{
                        fmt.Fprintln(w, "\tSIZE")
                }</span> <span class="cov0" title="0">else {
                        fmt.Fprint(w, "\n")
                }</span>
        }

        <span class="cov0" title="0">for _, out := range outs </span><span class="cov0" title="0">{
                if !*noTrunc </span><span class="cov0" title="0">{
                        out.ID = utils.TruncateID(out.ID)
                }</span>

                // Remove the leading / from the names
                <span class="cov0" title="0">for i := 0; i &lt; len(out.Names); i++ </span><span class="cov0" title="0">{
                        out.Names[i] = out.Names[i][1:]
                }</span>

                <span class="cov0" title="0">if !*quiet </span><span class="cov0" title="0">{
                        if !*noTrunc </span><span class="cov0" title="0">{
                                out.Command = utils.Trunc(out.Command, 20)
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%s\t%s ago\t%s\t%s\t%s\t", out.ID, out.Image, out.Command, utils.HumanDuration(time.Now().UTC().Sub(time.Unix(out.Created, 0))), out.Status, displayablePorts(out.Ports), strings.Join(out.Names, ","))
                        if *size </span><span class="cov0" title="0">{
                                if out.SizeRootFs &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(w, "%s (virtual %s)\n", utils.HumanSize(out.SizeRw), utils.HumanSize(out.SizeRootFs))
                                }</span> <span class="cov0" title="0">else {
                                        fmt.Fprintf(w, "%s\n", utils.HumanSize(out.SizeRw))
                                }</span>
                        } <span class="cov0" title="0">else {
                                fmt.Fprint(w, "\n")
                        }</span>
                } <span class="cov0" title="0">else {
                        fmt.Fprintln(w, out.ID)
                }</span>
        }

        <span class="cov0" title="0">if !*quiet </span><span class="cov0" title="0">{
                w.Flush()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdCommit(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("commit", "[OPTIONS] CONTAINER [REPOSITORY[:TAG]]", "Create a new image from a container's changes")
        flComment := cmd.String("m", "", "Commit message")
        flAuthor := cmd.String("author", "", "Author (eg. \"John Hannibal Smith &lt;hannibal@a-team.com&gt;\"")
        flConfig := cmd.String("run", "", "Config automatically applied when the image is run. "+`(ex: -run='{"Cmd": ["cat", "/world"], "PortSpecs": ["22"]}')`)
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var name, repository, tag string

        if cmd.NArg() == 3 </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "[DEPRECATED] The format 'CONTAINER [REPOSITORY [TAG]]' as been deprecated. Please use CONTAINER [REPOSITORY[:TAG]]\n")
                name, repository, tag = cmd.Arg(0), cmd.Arg(1), cmd.Arg(2)
        }</span> <span class="cov0" title="0">else {
                name = cmd.Arg(0)
                repository, tag = utils.ParseRepositoryTag(cmd.Arg(1))
        }</span>

        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        v.Set("container", name)
        v.Set("repo", repository)
        v.Set("tag", tag)
        v.Set("comment", *flComment)
        v.Set("author", *flAuthor)
        var config *Config
        if *flConfig != "" </span><span class="cov0" title="0">{
                config = &amp;Config{}
                if err := json.Unmarshal([]byte(*flConfig), config); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">body, _, err := cli.call("POST", "/commit?"+v.Encode(), config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">apiID := &amp;APIID{}
        err = json.Unmarshal(body, apiID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(cli.out, "%s\n", apiID.ID)
        return nil</span>
}

func (cli *DockerCli) CmdEvents(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("events", "[OPTIONS]", "Get real time events from the server")
        since := cmd.String("since", "", "Show previously created events and then stream.")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cmd.NArg() != 0 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        if *since != "" </span><span class="cov0" title="0">{
                loc := time.FixedZone(time.Now().Zone())
                format := "2006-01-02 15:04:05 -0700 MST"
                if len(*since) &lt; len(format) </span><span class="cov0" title="0">{
                        format = format[:len(*since)]
                }</span>

                <span class="cov0" title="0">if t, err := time.ParseInLocation(format, *since, loc); err == nil </span><span class="cov0" title="0">{
                        v.Set("since", strconv.FormatInt(t.Unix(), 10))
                }</span> <span class="cov0" title="0">else {
                        v.Set("since", *since)
                }</span>
        }

        <span class="cov0" title="0">if err := cli.stream("GET", "/events?"+v.Encode(), nil, cli.out, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdExport(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("export", "CONTAINER", "Export the contents of a filesystem as a tar archive to STDOUT")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">if err := cli.stream("GET", "/containers/"+cmd.Arg(0)+"/export", nil, cli.out, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdDiff(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("diff", "CONTAINER", "Inspect changes on a container's filesystem")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">body, _, err := cli.call("GET", "/containers/"+cmd.Arg(0)+"/changes", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">changes := []Change{}
        err = json.Unmarshal(body, &amp;changes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, change := range changes </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.out, "%s\n", change.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdLogs(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("logs", "CONTAINER", "Fetch the logs of a container")
        follow := cmd.Bool("f", false, "Follow log output")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>
        <span class="cov0" title="0">name := cmd.Arg(0)
        body, _, err := cli.call("GET", "/containers/"+name+"/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">container := &amp;Container{}
        err = json.Unmarshal(body, container)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        v.Set("logs", "1")
        v.Set("stdout", "1")
        v.Set("stderr", "1")
        if *follow &amp;&amp; container.State.Running </span><span class="cov0" title="0">{
                v.Set("stream", "1")
        }</span>

        <span class="cov0" title="0">if err := cli.hijack("POST", "/containers/"+name+"/attach?"+v.Encode(), container.Config.Tty, nil, cli.out, cli.err, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdAttach(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("attach", "[OPTIONS] CONTAINER", "Attach to a running container")
        noStdin := cmd.Bool("nostdin", false, "Do not attach stdin")
        proxy := cmd.Bool("sig-proxy", true, "Proxify all received signal to the process (even in non-tty mode)")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>
        <span class="cov0" title="0">name := cmd.Arg(0)
        body, _, err := cli.call("GET", "/containers/"+name+"/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">container := &amp;Container{}
        err = json.Unmarshal(body, container)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !container.State.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("Impossible to attach to a stopped container, start it first")
        }</span>

        <span class="cov0" title="0">if container.Config.Tty &amp;&amp; cli.isTerminal </span><span class="cov0" title="0">{
                if err := cli.monitorTtySize(cmd.Arg(0)); err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error monitoring TTY size: %s", err)
                }</span>
        }

        <span class="cov0" title="0">var in io.ReadCloser

        v := url.Values{}
        v.Set("stream", "1")
        if !*noStdin &amp;&amp; container.Config.OpenStdin </span><span class="cov0" title="0">{
                v.Set("stdin", "1")
                in = cli.in
        }</span>
        <span class="cov0" title="0">v.Set("stdout", "1")
        v.Set("stderr", "1")

        if *proxy &amp;&amp; !container.Config.Tty </span><span class="cov0" title="0">{
                sigc := cli.forwardAllSignals(cmd.Arg(0))
                defer utils.StopCatch(sigc)
        }</span>

        <span class="cov0" title="0">if err := cli.hijack("POST", "/containers/"+cmd.Arg(0)+"/attach?"+v.Encode(), container.Config.Tty, in, cli.out, cli.err, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, status, err := getExitCode(cli, cmd.Arg(0))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if status != 0 </span><span class="cov0" title="0">{
                return &amp;utils.StatusError{StatusCode: status}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdSearch(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("search", "TERM", "Search the docker index for images")
        noTrunc := cmd.Bool("notrunc", false, "Don't truncate output")
        trusted := cmd.Bool("trusted", false, "Only show trusted builds")
        stars := cmd.Int("stars", 0, "Only displays with at least xxx stars")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        v.Set("term", cmd.Arg(0))
        body, _, err := cli.call("GET", "/images/search?"+v.Encode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">outs := []registry.SearchResult{}
        err = json.Unmarshal(body, &amp;outs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">w := tabwriter.NewWriter(cli.out, 10, 1, 3, ' ', 0)
        fmt.Fprintf(w, "NAME\tDESCRIPTION\tSTARS\tOFFICIAL\tTRUSTED\n")
        for _, out := range outs </span><span class="cov0" title="0">{
                if (*trusted &amp;&amp; !out.IsTrusted) || (*stars &gt; out.StarCount) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">desc := strings.Replace(out.Description, "\n", " ", -1)
                desc = strings.Replace(desc, "\r", " ", -1)
                if !*noTrunc &amp;&amp; len(desc) &gt; 45 </span><span class="cov0" title="0">{
                        desc = utils.Trunc(desc, 42) + "..."
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%d\t", out.Name, desc, out.StarCount)
                if out.IsOfficial </span><span class="cov0" title="0">{
                        fmt.Fprint(w, "[OK]")

                }</span>
                <span class="cov0" title="0">fmt.Fprint(w, "\t")
                if out.IsTrusted </span><span class="cov0" title="0">{
                        fmt.Fprint(w, "[OK]")
                }</span>
                <span class="cov0" title="0">fmt.Fprint(w, "\n")</span>
        }
        <span class="cov0" title="0">w.Flush()
        return nil</span>
}

// Ports type - Used to parse multiple -p flags
type ports []int

func (cli *DockerCli) CmdTag(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("tag", "[OPTIONS] IMAGE REPOSITORY[:TAG]", "Tag an image into a repository")
        force := cmd.Bool("f", false, "Force")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cmd.NArg() != 2 &amp;&amp; cmd.NArg() != 3 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var repository, tag string

        if cmd.NArg() == 3 </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "[DEPRECATED] The format 'IMAGE [REPOSITORY [TAG]]' as been deprecated. Please use IMAGE [REPOSITORY[:TAG]]\n")
                repository, tag = cmd.Arg(1), cmd.Arg(2)
        }</span> <span class="cov0" title="0">else {
                repository, tag = utils.ParseRepositoryTag(cmd.Arg(1))
        }</span>

        <span class="cov0" title="0">v := url.Values{}
        v.Set("repo", repository)
        v.Set("tag", tag)

        if *force </span><span class="cov0" title="0">{
                v.Set("force", "1")
        }</span>

        <span class="cov0" title="0">if _, _, err := cli.call("POST", "/images/"+cmd.Arg(0)+"/tag?"+v.Encode(), nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//FIXME Only used in tests
func ParseRun(args []string, capabilities *Capabilities) (*Config, *HostConfig, *flag.FlagSet, error) <span class="cov8" title="1">{
        cmd := flag.NewFlagSet("run", flag.ContinueOnError)
        cmd.SetOutput(ioutil.Discard)
        cmd.Usage = nil
        return parseRun(cmd, args, capabilities)
}</span>

func parseRun(cmd *flag.FlagSet, args []string, capabilities *Capabilities) (*Config, *HostConfig, *flag.FlagSet, error) <span class="cov8" title="1">{
        var (
                // FIXME: use utils.ListOpts for attach and volumes?
                flAttach  = NewListOpts(ValidateAttach)
                flVolumes = NewListOpts(ValidatePath)
                flLinks   = NewListOpts(ValidateLink)
                flEnv     = NewListOpts(ValidateEnv)

                flPublish     ListOpts
                flExpose      ListOpts
                flDns         ListOpts
                flVolumesFrom ListOpts
                flLxcOpts     ListOpts

                flAutoRemove      = cmd.Bool("rm", false, "Automatically remove the container when it exits (incompatible with -d)")
                flDetach          = cmd.Bool("d", false, "Detached mode: Run container in the background, print new container id")
                flNetwork         = cmd.Bool("n", true, "Enable networking for this container")
                flPrivileged      = cmd.Bool("privileged", false, "Give extended privileges to this container")
                flPublishAll      = cmd.Bool("P", false, "Publish all exposed ports to the host interfaces")
                flStdin           = cmd.Bool("i", false, "Keep stdin open even if not attached")
                flTty             = cmd.Bool("t", false, "Allocate a pseudo-tty")
                flContainerIDFile = cmd.String("cidfile", "", "Write the container ID to the file")
                flEntrypoint      = cmd.String("entrypoint", "", "Overwrite the default entrypoint of the image")
                flHostname        = cmd.String("h", "", "Container host name")
                flMemoryString    = cmd.String("m", "", "Memory limit (format: &lt;number&gt;&lt;optional unit&gt;, where unit = b, k, m or g)")
                flUser            = cmd.String("u", "", "Username or UID")
                flWorkingDir      = cmd.String("w", "", "Working directory inside the container")
                flCpuShares       = cmd.Int64("c", 0, "CPU shares (relative weight)")

                // For documentation purpose
                _ = cmd.Bool("sig-proxy", true, "Proxify all received signal to the process (even in non-tty mode)")
                _ = cmd.String("name", "", "Assign a name to the container")
        )

        cmd.Var(&amp;flAttach, "a", "Attach to stdin, stdout or stderr.")
        cmd.Var(&amp;flVolumes, "v", "Bind mount a volume (e.g. from the host: -v /host:/container, from docker: -v /container)")
        cmd.Var(&amp;flLinks, "link", "Add link to another container (name:alias)")
        cmd.Var(&amp;flEnv, "e", "Set environment variables")

        cmd.Var(&amp;flPublish, "p", fmt.Sprintf("Publish a container's port to the host (format: %s) (use 'docker port' to see the actual mapping)", PortSpecTemplateFormat))
        cmd.Var(&amp;flExpose, "expose", "Expose a port from the container without publishing it to your host")
        cmd.Var(&amp;flDns, "dns", "Set custom dns servers")
        cmd.Var(&amp;flVolumesFrom, "volumes-from", "Mount volumes from the specified container(s)")
        cmd.Var(&amp;flLxcOpts, "lxc-conf", "Add custom lxc options -lxc-conf=\"lxc.cgroup.cpuset.cpus = 0,1\"")

        if err := cmd.Parse(args); err != nil </span><span class="cov8" title="1">{
                return nil, nil, cmd, err
        }</span>

        // Check if the kernel supports memory limit cgroup.
        <span class="cov8" title="1">if capabilities != nil &amp;&amp; *flMemoryString != "" &amp;&amp; !capabilities.MemoryLimit </span><span class="cov0" title="0">{
                *flMemoryString = ""
        }</span>

        // Validate input params
        <span class="cov8" title="1">if *flDetach &amp;&amp; flAttach.Len() &gt; 0 </span><span class="cov8" title="1">{
                return nil, nil, cmd, ErrConflictAttachDetach
        }</span>
        <span class="cov8" title="1">if *flWorkingDir != "" &amp;&amp; !path.IsAbs(*flWorkingDir) </span><span class="cov0" title="0">{
                return nil, nil, cmd, ErrInvalidWorikingDirectory
        }</span>
        <span class="cov8" title="1">if *flDetach &amp;&amp; *flAutoRemove </span><span class="cov8" title="1">{
                return nil, nil, cmd, ErrConflictDetachAutoRemove
        }</span>

        // If neither -d or -a are set, attach to everything by default
        <span class="cov8" title="1">if flAttach.Len() == 0 &amp;&amp; !*flDetach </span><span class="cov8" title="1">{
                if !*flDetach </span><span class="cov8" title="1">{
                        flAttach.Set("stdout")
                        flAttach.Set("stderr")
                        if *flStdin </span><span class="cov0" title="0">{
                                flAttach.Set("stdin")
                        }</span>
                }
        }

        <span class="cov8" title="1">var flMemory int64
        if *flMemoryString != "" </span><span class="cov0" title="0">{
                parsedMemory, err := utils.RAMInBytes(*flMemoryString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, cmd, err
                }</span>
                <span class="cov0" title="0">flMemory = parsedMemory</span>
        }

        <span class="cov8" title="1">var binds []string
        // add any bind targets to the list of container volumes
        for bind := range flVolumes.GetMap() </span><span class="cov8" title="1">{
                if arr := strings.Split(bind, ":"); len(arr) &gt; 1 </span><span class="cov8" title="1">{
                        if arr[0] == "/" </span><span class="cov8" title="1">{
                                return nil, nil, cmd, fmt.Errorf("Invalid bind mount: source can't be '/'")
                        }</span>
                        <span class="cov8" title="1">dstDir := arr[1]
                        flVolumes.Set(dstDir)
                        binds = append(binds, bind)
                        flVolumes.Delete(bind)</span>
                } <span class="cov8" title="1">else if bind == "/" </span><span class="cov8" title="1">{
                        return nil, nil, cmd, fmt.Errorf("Invalid volume: path can't be '/'")
                }</span>
        }

        <span class="cov8" title="1">var (
                parsedArgs = cmd.Args()
                runCmd     []string
                entrypoint []string
                image      string
        )
        if len(parsedArgs) &gt;= 1 </span><span class="cov8" title="1">{
                image = cmd.Arg(0)
        }</span>
        <span class="cov8" title="1">if len(parsedArgs) &gt; 1 </span><span class="cov8" title="1">{
                runCmd = parsedArgs[1:]
        }</span>
        <span class="cov8" title="1">if *flEntrypoint != "" </span><span class="cov0" title="0">{
                entrypoint = []string{*flEntrypoint}
        }</span>

        <span class="cov8" title="1">lxcConf, err := parseLxcConfOpts(flLxcOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, cmd, err
        }</span>

        <span class="cov8" title="1">var (
                domainname string
                hostname   = *flHostname
                parts      = strings.SplitN(hostname, ".", 2)
        )
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                hostname = parts[0]
                domainname = parts[1]
        }</span>

        <span class="cov8" title="1">ports, portBindings, err := parsePortSpecs(flPublish.GetAll())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, cmd, err
        }</span>

        // Merge in exposed ports to the map of published ports
        <span class="cov8" title="1">for _, e := range flExpose.GetAll() </span><span class="cov0" title="0">{
                if strings.Contains(e, ":") </span><span class="cov0" title="0">{
                        return nil, nil, cmd, fmt.Errorf("Invalid port format for -expose: %s", e)
                }</span>
                <span class="cov0" title="0">p := NewPort(splitProtoPort(e))
                if _, exists := ports[p]; !exists </span><span class="cov0" title="0">{
                        ports[p] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">config := &amp;Config{
                Hostname:        hostname,
                Domainname:      domainname,
                PortSpecs:       nil, // Deprecated
                ExposedPorts:    ports,
                User:            *flUser,
                Tty:             *flTty,
                NetworkDisabled: !*flNetwork,
                OpenStdin:       *flStdin,
                Memory:          flMemory,
                CpuShares:       *flCpuShares,
                AttachStdin:     flAttach.Get("stdin"),
                AttachStdout:    flAttach.Get("stdout"),
                AttachStderr:    flAttach.Get("stderr"),
                Env:             flEnv.GetAll(),
                Cmd:             runCmd,
                Dns:             flDns.GetAll(),
                Image:           image,
                Volumes:         flVolumes.GetMap(),
                VolumesFrom:     strings.Join(flVolumesFrom.GetAll(), ","),
                Entrypoint:      entrypoint,
                WorkingDir:      *flWorkingDir,
        }

        hostConfig := &amp;HostConfig{
                Binds:           binds,
                ContainerIDFile: *flContainerIDFile,
                LxcConf:         lxcConf,
                Privileged:      *flPrivileged,
                PortBindings:    portBindings,
                Links:           flLinks.GetAll(),
                PublishAllPorts: *flPublishAll,
        }

        if capabilities != nil &amp;&amp; flMemory &gt; 0 &amp;&amp; !capabilities.SwapLimit </span><span class="cov0" title="0">{
                //fmt.Fprintf(stdout, "WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.\n")
                config.MemorySwap = -1
        }</span>

        // When allocating stdin in attached mode, close stdin at client disconnect
        <span class="cov8" title="1">if config.OpenStdin &amp;&amp; config.AttachStdin </span><span class="cov0" title="0">{
                config.StdinOnce = true
        }</span>
        <span class="cov8" title="1">return config, hostConfig, cmd, nil</span>
}

func (cli *DockerCli) CmdRun(args ...string) error <span class="cov0" title="0">{
        config, hostConfig, cmd, err := parseRun(cli.Subcmd("run", "[OPTIONS] IMAGE [COMMAND] [ARG...]", "Run a command in a new container"), args, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if config.Image == "" </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        // Retrieve relevant client-side config
        <span class="cov0" title="0">var (
                flName        = cmd.Lookup("name")
                flRm          = cmd.Lookup("rm")
                flSigProxy    = cmd.Lookup("sig-proxy")
                autoRemove, _ = strconv.ParseBool(flRm.Value.String())
                sigProxy, _   = strconv.ParseBool(flSigProxy.Value.String())
        )

        // Disable sigProxy in case on TTY
        if config.Tty </span><span class="cov0" title="0">{
                sigProxy = false
        }</span>

        <span class="cov0" title="0">var containerIDFile io.WriteCloser
        if len(hostConfig.ContainerIDFile) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := os.Stat(hostConfig.ContainerIDFile); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cid file found, make sure the other container isn't running or delete %s", hostConfig.ContainerIDFile)
                }</span>
                <span class="cov0" title="0">if containerIDFile, err = os.Create(hostConfig.ContainerIDFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create the container ID file: %s", err)
                }</span>
                <span class="cov0" title="0">defer containerIDFile.Close()</span>
        }

        <span class="cov0" title="0">containerValues := url.Values{}
        if name := flName.Value.String(); name != "" </span><span class="cov0" title="0">{
                containerValues.Set("name", name)
        }</span>

        //create the container
        <span class="cov0" title="0">body, statusCode, err := cli.call("POST", "/containers/create?"+containerValues.Encode(), config)
        //if image not found try to pull it
        if statusCode == 404 </span><span class="cov0" title="0">{
                _, tag := utils.ParseRepositoryTag(config.Image)
                if tag == "" </span><span class="cov0" title="0">{
                        tag = DEFAULTTAG
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(cli.err, "Unable to find image '%s' (tag: %s) locally\n", config.Image, tag)

                v := url.Values{}
                repos, tag := utils.ParseRepositoryTag(config.Image)
                v.Set("fromImage", repos)
                v.Set("tag", tag)

                // Resolve the Repository name from fqn to endpoint + name
                endpoint, _, err := registry.ResolveRepositoryName(repos)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Load the auth config file, to be able to pull the image
                <span class="cov0" title="0">cli.LoadConfigFile()

                // Resolve the Auth config relevant for this server
                authConfig := cli.configFile.ResolveAuthConfig(endpoint)
                buf, err := json.Marshal(authConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">registryAuthHeader := []string{
                        base64.URLEncoding.EncodeToString(buf),
                }
                if err = cli.stream("POST", "/images/create?"+v.Encode(), nil, cli.err, map[string][]string{"X-Registry-Auth": registryAuthHeader}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if body, _, err = cli.call("POST", "/containers/create?"+containerValues.Encode(), config); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } <span class="cov0" title="0">else if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var runResult APIRun
        if err := json.Unmarshal(body, &amp;runResult); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, warning := range runResult.Warnings </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "WARNING: %s\n", warning)
        }</span>

        <span class="cov0" title="0">if len(hostConfig.ContainerIDFile) &gt; 0 </span><span class="cov0" title="0">{
                if _, err = containerIDFile.Write([]byte(runResult.ID)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write the container ID to the file: %s", err)
                }</span>
        }

        <span class="cov0" title="0">if sigProxy </span><span class="cov0" title="0">{
                sigc := cli.forwardAllSignals(runResult.ID)
                defer utils.StopCatch(sigc)
        }</span>

        <span class="cov0" title="0">var (
                waitDisplayId chan struct{}
                errCh         chan error
        )

        if !config.AttachStdout &amp;&amp; !config.AttachStderr </span><span class="cov0" title="0">{
                // Make this asynchrone in order to let the client write to stdin before having to read the ID
                waitDisplayId = make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        defer close(waitDisplayId)
                        fmt.Fprintf(cli.out, "%s\n", runResult.ID)
                }</span>()
        }

        // We need to instanciate the chan because the select needs it. It can
        // be closed but can't be uninitialized.
        <span class="cov0" title="0">hijacked := make(chan io.Closer)

        // Block the return until the chan gets closed
        defer func() </span><span class="cov0" title="0">{
                utils.Debugf("End of CmdRun(), Waiting for hijack to finish.")
                if _, ok := &lt;-hijacked; ok </span><span class="cov0" title="0">{
                        utils.Errorf("Hijack did not finish (chan still open)")
                }</span>
        }()

        <span class="cov0" title="0">if config.AttachStdin || config.AttachStdout || config.AttachStderr </span><span class="cov0" title="0">{
                var (
                        out, stderr io.Writer
                        in          io.ReadCloser
                        v           = url.Values{}
                )
                v.Set("stream", "1")

                if config.AttachStdin </span><span class="cov0" title="0">{
                        v.Set("stdin", "1")
                        in = cli.in
                }</span>
                <span class="cov0" title="0">if config.AttachStdout </span><span class="cov0" title="0">{
                        v.Set("stdout", "1")
                        out = cli.out
                }</span>
                <span class="cov0" title="0">if config.AttachStderr </span><span class="cov0" title="0">{
                        v.Set("stderr", "1")
                        if config.Tty </span><span class="cov0" title="0">{
                                stderr = cli.out
                        }</span> <span class="cov0" title="0">else {
                                stderr = cli.err
                        }</span>
                }

                <span class="cov0" title="0">errCh = utils.Go(func() error </span><span class="cov0" title="0">{
                        return cli.hijack("POST", "/containers/"+runResult.ID+"/attach?"+v.Encode(), config.Tty, in, out, stderr, hijacked)
                }</span>)
        } <span class="cov0" title="0">else {
                close(hijacked)
        }</span>

        // Acknowledge the hijack before starting
        <span class="cov0" title="0">select </span>{
        <span class="cov0" title="0">case closer := &lt;-hijacked:
                // Make sure that hijack gets closed when returning. (result
                // in closing hijack chan and freeing server's goroutines.
                if closer != nil </span><span class="cov0" title="0">{
                        defer closer.Close()
                }</span>
        <span class="cov0" title="0">case err := &lt;-errCh:
                if err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error hijack: %s", err)
                        return err
                }</span>
        }

        //start the container
        <span class="cov0" title="0">if _, _, err = cli.call("POST", "/containers/"+runResult.ID+"/start", hostConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if (config.AttachStdin || config.AttachStdout || config.AttachStderr) &amp;&amp; config.Tty &amp;&amp; cli.isTerminal </span><span class="cov0" title="0">{
                if err := cli.monitorTtySize(runResult.ID); err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Error monitoring TTY size: %s\n", err)
                }</span>
        }

        <span class="cov0" title="0">if errCh != nil </span><span class="cov0" title="0">{
                if err := &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error hijack: %s", err)
                        return err
                }</span>
        }

        // Detached mode: wait for the id to be displayed and return.
        <span class="cov0" title="0">if !config.AttachStdout &amp;&amp; !config.AttachStderr </span><span class="cov0" title="0">{
                // Detached mode
                &lt;-waitDisplayId
                return nil
        }</span>

        <span class="cov0" title="0">var status int

        // Attached mode
        if autoRemove </span><span class="cov0" title="0">{
                // Autoremove: wait for the container to finish, retrieve
                // the exit code and remove the container
                if _, _, err := cli.call("POST", "/containers/"+runResult.ID+"/wait", nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, status, err = getExitCode(cli, runResult.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, _, err := cli.call("DELETE", "/containers/"+runResult.ID+"?v=1", nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } <span class="cov0" title="0">else {
                // No Autoremove: Simply retrieve the exit code
                if _, status, err = getExitCode(cli, runResult.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if status != 0 </span><span class="cov0" title="0">{
                return &amp;utils.StatusError{StatusCode: status}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdCp(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("cp", "CONTAINER:PATH HOSTPATH", "Copy files/folders from the PATH to the HOSTPATH")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cmd.NArg() != 2 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">var copyData APICopy
        info := strings.Split(cmd.Arg(0), ":")

        if len(info) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Error: Path not specified")
        }</span>

        <span class="cov0" title="0">copyData.Resource = info[1]
        copyData.HostPath = cmd.Arg(1)

        data, statusCode, err := cli.call("POST", "/containers/"+info[0]+"/copy", copyData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if statusCode == 200 </span><span class="cov0" title="0">{
                r := bytes.NewReader(data)
                if err := archive.Untar(r, copyData.HostPath, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdSave(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("save", "IMAGE", "Save an image to a tar archive (streamed to stdout)")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cmd.NArg() != 1 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">image := cmd.Arg(0)
        if err := cli.stream("GET", "/images/"+image+"/get", nil, cli.out, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) CmdLoad(args ...string) error <span class="cov0" title="0">{
        cmd := cli.Subcmd("load", "", "Load an image from a tar archive on STDIN")
        if err := cmd.Parse(args); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cmd.NArg() != 0 </span><span class="cov0" title="0">{
                cmd.Usage()
                return nil
        }</span>

        <span class="cov0" title="0">if err := cli.stream("POST", "/images/load", cli.in, cli.out, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) call(method, path string, data interface{}) ([]byte, int, error) <span class="cov0" title="0">{
        var params io.Reader
        if data != nil </span><span class="cov0" title="0">{
                buf, err := json.Marshal(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, -1, err
                }</span>
                <span class="cov0" title="0">params = bytes.NewBuffer(buf)</span>
        }

        // fixme: refactor client to support redirect
        <span class="cov0" title="0">re := regexp.MustCompile("/+")
        path = re.ReplaceAllString(path, "/")

        req, err := http.NewRequest(method, fmt.Sprintf("/v%g%s", APIVERSION, path), params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, -1, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("User-Agent", "Docker-Client/"+VERSION)
        req.Host = cli.addr
        if data != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span> <span class="cov0" title="0">else if method == "POST" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "plain/text")
        }</span>
        <span class="cov0" title="0">dial, err := net.Dial(cli.proto, cli.addr)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "connection refused") </span><span class="cov0" title="0">{
                        return nil, -1, ErrConnectionRefused
                }</span>
                <span class="cov0" title="0">return nil, -1, err</span>
        }
        <span class="cov0" title="0">clientconn := httputil.NewClientConn(dial, nil)
        resp, err := clientconn.Do(req)
        defer clientconn.Close()
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "connection refused") </span><span class="cov0" title="0">{
                        return nil, -1, ErrConnectionRefused
                }</span>
                <span class="cov0" title="0">return nil, -1, err</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, -1, err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                if len(body) == 0 </span><span class="cov0" title="0">{
                        return nil, resp.StatusCode, fmt.Errorf("Error: %s", http.StatusText(resp.StatusCode))
                }</span>
                <span class="cov0" title="0">return nil, resp.StatusCode, fmt.Errorf("Error: %s", bytes.TrimSpace(body))</span>
        }
        <span class="cov0" title="0">return body, resp.StatusCode, nil</span>
}

func (cli *DockerCli) stream(method, path string, in io.Reader, out io.Writer, headers map[string][]string) error <span class="cov0" title="0">{
        if (method == "POST" || method == "PUT") &amp;&amp; in == nil </span><span class="cov0" title="0">{
                in = bytes.NewReader([]byte{})
        }</span>

        // fixme: refactor client to support redirect
        <span class="cov0" title="0">re := regexp.MustCompile("/+")
        path = re.ReplaceAllString(path, "/")

        req, err := http.NewRequest(method, fmt.Sprintf("/v%g%s", APIVERSION, path), in)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">req.Header.Set("User-Agent", "Docker-Client/"+VERSION)
        req.Host = cli.addr
        if method == "POST" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "plain/text")
        }</span>

        <span class="cov0" title="0">if headers != nil </span><span class="cov0" title="0">{
                for k, v := range headers </span><span class="cov0" title="0">{
                        req.Header[k] = v
                }</span>
        }

        <span class="cov0" title="0">dial, err := net.Dial(cli.proto, cli.addr)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "connection refused") </span><span class="cov0" title="0">{
                        return fmt.Errorf("Can't connect to docker daemon. Is 'docker -d' running on this host?")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">clientconn := httputil.NewClientConn(dial, nil)
        resp, err := clientconn.Do(req)
        defer clientconn.Close()
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "connection refused") </span><span class="cov0" title="0">{
                        return fmt.Errorf("Can't connect to docker daemon. Is 'docker -d' running on this host?")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, err := ioutil.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(body) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error :%s", http.StatusText(resp.StatusCode))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Error: %s", bytes.TrimSpace(body))</span>
        }

        <span class="cov0" title="0">if matchesContentType(resp.Header.Get("Content-Type"), "application/json") </span><span class="cov0" title="0">{
                return utils.DisplayJSONMessagesStream(resp.Body, out, cli.terminalFd, cli.isTerminal)
        }</span>
        <span class="cov0" title="0">if _, err := io.Copy(out, resp.Body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) hijack(method, path string, setRawTerminal bool, in io.ReadCloser, stdout, stderr io.Writer, started chan io.Closer) error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if started != nil </span><span class="cov0" title="0">{
                        close(started)
                }</span>
        }()
        // fixme: refactor client to support redirect
        <span class="cov0" title="0">re := regexp.MustCompile("/+")
        path = re.ReplaceAllString(path, "/")

        req, err := http.NewRequest(method, fmt.Sprintf("/v%g%s", APIVERSION, path), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">req.Header.Set("User-Agent", "Docker-Client/"+VERSION)
        req.Header.Set("Content-Type", "plain/text")
        req.Host = cli.addr

        dial, err := net.Dial(cli.proto, cli.addr)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "connection refused") </span><span class="cov0" title="0">{
                        return fmt.Errorf("Can't connect to docker daemon. Is 'docker -d' running on this host?")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">clientconn := httputil.NewClientConn(dial, nil)
        defer clientconn.Close()

        // Server hijacks the connection, error 'connection closed' expected
        clientconn.Do(req)

        rwc, br := clientconn.Hijack()
        defer rwc.Close()

        if started != nil </span><span class="cov0" title="0">{
                started &lt;- rwc
        }</span>

        <span class="cov0" title="0">var receiveStdout chan error

        var oldState *term.State

        if in != nil &amp;&amp; setRawTerminal &amp;&amp; cli.isTerminal &amp;&amp; os.Getenv("NORAW") == "" </span><span class="cov0" title="0">{
                oldState, err = term.SetRawTerminal(cli.terminalFd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer term.RestoreTerminal(cli.terminalFd, oldState)</span>
        }

        <span class="cov0" title="0">if stdout != nil || stderr != nil </span><span class="cov0" title="0">{
                receiveStdout = utils.Go(func() (err error) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if in != nil </span><span class="cov0" title="0">{
                                        if setRawTerminal &amp;&amp; cli.isTerminal </span><span class="cov0" title="0">{
                                                term.RestoreTerminal(cli.terminalFd, oldState)
                                        }</span>
                                        <span class="cov0" title="0">in.Close()</span>
                                }
                        }()

                        // When TTY is ON, use regular copy
                        <span class="cov0" title="0">if setRawTerminal </span><span class="cov0" title="0">{
                                _, err = io.Copy(stdout, br)
                        }</span> <span class="cov0" title="0">else {
                                _, err = utils.StdCopy(stdout, stderr, br)
                        }</span>
                        <span class="cov0" title="0">utils.Debugf("[hijack] End of stdout")
                        return err</span>
                })
        }

        <span class="cov0" title="0">sendStdin := utils.Go(func() error </span><span class="cov0" title="0">{
                if in != nil </span><span class="cov0" title="0">{
                        io.Copy(rwc, in)
                        utils.Debugf("[hijack] End of stdin")
                }</span>
                <span class="cov0" title="0">if tcpc, ok := rwc.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                        if err := tcpc.CloseWrite(); err != nil </span><span class="cov0" title="0">{
                                utils.Errorf("Couldn't send EOF: %s\n", err)
                        }</span>
                } <span class="cov0" title="0">else if unixc, ok := rwc.(*net.UnixConn); ok </span><span class="cov0" title="0">{
                        if err := unixc.CloseWrite(); err != nil </span><span class="cov0" title="0">{
                                utils.Errorf("Couldn't send EOF: %s\n", err)
                        }</span>
                }
                // Discard errors due to pipe interruption
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if stdout != nil || stderr != nil </span><span class="cov0" title="0">{
                if err := &lt;-receiveStdout; err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Error receiveStdout: %s", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">if !cli.isTerminal </span><span class="cov0" title="0">{
                if err := &lt;-sendStdin; err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Error sendStdin: %s", err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>

}

func (cli *DockerCli) getTtySize() (int, int) <span class="cov0" title="0">{
        if !cli.isTerminal </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov0" title="0">ws, err := term.GetWinsize(cli.terminalFd)
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorf("Error getting size: %s", err)
                if ws == nil </span><span class="cov0" title="0">{
                        return 0, 0
                }</span>
        }
        <span class="cov0" title="0">return int(ws.Height), int(ws.Width)</span>
}

func (cli *DockerCli) resizeTty(id string) <span class="cov0" title="0">{
        height, width := cli.getTtySize()
        if height == 0 &amp;&amp; width == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v := url.Values{}
        v.Set("h", strconv.Itoa(height))
        v.Set("w", strconv.Itoa(width))
        if _, _, err := cli.call("POST", "/containers/"+id+"/resize?"+v.Encode(), nil); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("Error resize: %s", err)
        }</span>
}

func (cli *DockerCli) monitorTtySize(id string) error <span class="cov0" title="0">{
        cli.resizeTty(id)

        sigchan := make(chan os.Signal, 1)
        signal.Notify(sigchan, syscall.SIGWINCH)
        go func() </span><span class="cov0" title="0">{
                for _ = range sigchan </span><span class="cov0" title="0">{
                        cli.resizeTty(id)
                }</span>
        }()
        <span class="cov0" title="0">return nil</span>
}

func (cli *DockerCli) Subcmd(name, signature, description string) *flag.FlagSet <span class="cov0" title="0">{
        flags := flag.NewFlagSet(name, flag.ContinueOnError)
        flags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "\nUsage: docker %s %s\n\n%s\n\n", name, signature, description)
                flags.PrintDefaults()
                os.Exit(2)
        }</span>
        <span class="cov0" title="0">return flags</span>
}

func (cli *DockerCli) LoadConfigFile() (err error) <span class="cov0" title="0">{
        cli.configFile, err = auth.LoadConfig(os.Getenv("HOME"))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(cli.err, "WARNING: %s\n", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func waitForExit(cli *DockerCli, containerId string) (int, error) <span class="cov0" title="0">{
        body, _, err := cli.call("POST", "/containers/"+containerId+"/wait", nil)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">var out APIWait
        if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">return out.StatusCode, nil</span>
}

// getExitCode perform an inspect on the container. It returns
// the running state and the exit code.
func getExitCode(cli *DockerCli, containerId string) (bool, int, error) <span class="cov0" title="0">{
        body, _, err := cli.call("GET", "/containers/"+containerId+"/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't connect, then the daemon probably died.
                if err != ErrConnectionRefused </span><span class="cov0" title="0">{
                        return false, -1, err
                }</span>
                <span class="cov0" title="0">return false, -1, nil</span>
        }
        <span class="cov0" title="0">c := &amp;Container{}
        if err := json.Unmarshal(body, c); err != nil </span><span class="cov0" title="0">{
                return false, -1, err
        }</span>
        <span class="cov0" title="0">return c.State.IsRunning(), c.State.GetExitCode(), nil</span>
}

func NewDockerCli(in io.ReadCloser, out, err io.Writer, proto, addr string) *DockerCli <span class="cov0" title="0">{
        var (
                isTerminal = false
                terminalFd uintptr
        )

        if in != nil </span><span class="cov0" title="0">{
                if file, ok := in.(*os.File); ok </span><span class="cov0" title="0">{
                        terminalFd = file.Fd()
                        isTerminal = term.IsTerminal(terminalFd)
                }</span>
        }

        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                err = out
        }</span>
        <span class="cov0" title="0">return &amp;DockerCli{
                proto:      proto,
                addr:       addr,
                in:         in,
                out:        out,
                err:        err,
                isTerminal: isTerminal,
                terminalFd: terminalFd,
        }</span>
}

type DockerCli struct {
        proto      string
        addr       string
        configFile *auth.ConfigFile
        in         io.ReadCloser
        out        io.Writer
        err        io.Writer
        isTerminal bool
        terminalFd uintptr
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package docker

import (
        "github.com/dotcloud/docker/engine"
        "net"
)

// FIXME: separate runtime configuration from http api configuration
type DaemonConfig struct {
        Pidfile                     string
        Root                        string
        AutoRestart                 bool
        EnableCors                  bool
        Dns                         []string
        EnableIptables              bool
        BridgeIface                 string
        BridgeIp                    string
        DefaultIp                   net.IP
        InterContainerCommunication bool
        GraphDriver                 string
        Mtu                         int
}

// ConfigFromJob creates and returns a new DaemonConfig object
// by parsing the contents of a job's environment.
func ConfigFromJob(job *engine.Job) *DaemonConfig <span class="cov0" title="0">{
        var config DaemonConfig
        config.Pidfile = job.Getenv("Pidfile")
        config.Root = job.Getenv("Root")
        config.AutoRestart = job.GetenvBool("AutoRestart")
        config.EnableCors = job.GetenvBool("EnableCors")
        if dns := job.GetenvList("Dns"); dns != nil </span><span class="cov0" title="0">{
                config.Dns = dns
        }</span>
        <span class="cov0" title="0">config.EnableIptables = job.GetenvBool("EnableIptables")
        if br := job.Getenv("BridgeIface"); br != "" </span><span class="cov0" title="0">{
                config.BridgeIface = br
        }</span> <span class="cov0" title="0">else {
                config.BridgeIface = DefaultNetworkBridge
        }</span>
        <span class="cov0" title="0">config.BridgeIp = job.Getenv("BridgeIp")
        config.DefaultIp = net.ParseIP(job.Getenv("DefaultIp"))
        config.InterContainerCommunication = job.GetenvBool("InterContainerCommunication")
        config.GraphDriver = job.Getenv("GraphDriver")
        if mtu := job.GetenvInt("Mtu"); mtu != -1 </span><span class="cov0" title="0">{
                config.Mtu = mtu
        }</span> <span class="cov0" title="0">else {
                config.Mtu = DefaultNetworkMtu
        }</span>
        <span class="cov0" title="0">return &amp;config</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package docker

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/graphdriver"
        "github.com/dotcloud/docker/mount"
        "github.com/dotcloud/docker/pkg/term"
        "github.com/dotcloud/docker/utils"
        "github.com/kr/pty"
        "io"
        "io/ioutil"
        "log"
        "net"
        "os"
        "os/exec"
        "path"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"
)

var (
        ErrNotATTY = errors.New("The PTY is not a file")
        ErrNoTTY   = errors.New("No PTY found")
)

type Container struct {
        sync.Mutex
        root   string // Path to the "home" of the container, including metadata.
        rootfs string // Path to the root filesystem of the container.

        ID string

        Created time.Time

        Path string
        Args []string

        Config *Config
        State  State
        Image  string

        network         *NetworkInterface
        NetworkSettings *NetworkSettings

        ResolvConfPath string
        HostnamePath   string
        HostsPath      string
        Name           string
        Driver         string

        cmd       *exec.Cmd
        stdout    *utils.WriteBroadcaster
        stderr    *utils.WriteBroadcaster
        stdin     io.ReadCloser
        stdinPipe io.WriteCloser
        ptyMaster io.Closer

        runtime *Runtime

        waitLock chan struct{}
        Volumes  map[string]string
        // Store rw/ro in a separate structure to preserve reverse-compatibility on-disk.
        // Easier than migrating older container configs :)
        VolumesRW  map[string]bool
        hostConfig *HostConfig

        activeLinks map[string]*Link
}

// Note: the Config structure should hold only portable information about the container.
// Here, "portable" means "independent from the host we are running on".
// Non-portable information *should* appear in HostConfig.
type Config struct {
        Hostname        string
        Domainname      string
        User            string
        Memory          int64 // Memory limit (in bytes)
        MemorySwap      int64 // Total memory usage (memory + swap); set `-1' to disable swap
        CpuShares       int64 // CPU shares (relative weight vs. other containers)
        AttachStdin     bool
        AttachStdout    bool
        AttachStderr    bool
        PortSpecs       []string // Deprecated - Can be in the format of 8080/tcp
        ExposedPorts    map[Port]struct{}
        Tty             bool // Attach standard streams to a tty, including stdin if it is not closed.
        OpenStdin       bool // Open stdin
        StdinOnce       bool // If true, close stdin after the 1 attached client disconnects.
        Env             []string
        Cmd             []string
        Dns             []string
        Image           string // Name of the image as it was passed by the operator (eg. could be symbolic)
        Volumes         map[string]struct{}
        VolumesFrom     string
        WorkingDir      string
        Entrypoint      []string
        NetworkDisabled bool
}

type HostConfig struct {
        Binds           []string
        ContainerIDFile string
        LxcConf         []KeyValuePair
        Privileged      bool
        PortBindings    map[Port][]PortBinding
        Links           []string
        PublishAllPorts bool
}

type BindMap struct {
        SrcPath string
        DstPath string
        Mode    string
}

var (
        ErrContainerStart           = errors.New("The container failed to start. Unknown error")
        ErrContainerStartTimeout    = errors.New("The container failed to start due to timed out.")
        ErrInvalidWorikingDirectory = errors.New("The working directory is invalid. It needs to be an absolute path.")
        ErrConflictAttachDetach     = errors.New("Conflicting options: -a and -d")
        ErrConflictDetachAutoRemove = errors.New("Conflicting options: -rm and -d")
)

type KeyValuePair struct {
        Key   string
        Value string
}

type PortBinding struct {
        HostIp   string
        HostPort string
}

// 80/tcp
type Port string

func (p Port) Proto() string <span class="cov8" title="1">{
        parts := strings.Split(string(p), "/")
        if len(parts) == 1 </span><span class="cov0" title="0">{
                return "tcp"
        }</span>
        <span class="cov8" title="1">return parts[1]</span>
}

func (p Port) Port() string <span class="cov8" title="1">{
        return strings.Split(string(p), "/")[0]
}</span>

func (p Port) Int() int <span class="cov8" title="1">{
        i, err := parsePort(p.Port())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)
        }</span>
        <span class="cov8" title="1">return i</span>
}

func NewPort(proto, port string) Port <span class="cov8" title="1">{
        return Port(fmt.Sprintf("%s/%s", port, proto))
}</span>

type PortMapping map[string]string // Deprecated

type NetworkSettings struct {
        IPAddress   string
        IPPrefixLen int
        Gateway     string
        Bridge      string
        PortMapping map[string]PortMapping // Deprecated
        Ports       map[Port][]PortBinding
}

func (settings *NetworkSettings) PortMappingAPI() []APIPort <span class="cov0" title="0">{
        var mapping []APIPort
        for port, bindings := range settings.Ports </span><span class="cov0" title="0">{
                p, _ := parsePort(port.Port())
                if len(bindings) == 0 </span><span class="cov0" title="0">{
                        mapping = append(mapping, APIPort{
                                PublicPort: int64(p),
                                Type:       port.Proto(),
                        })
                        continue</span>
                }
                <span class="cov0" title="0">for _, binding := range bindings </span><span class="cov0" title="0">{
                        p, _ := parsePort(port.Port())
                        h, _ := parsePort(binding.HostPort)
                        mapping = append(mapping, APIPort{
                                PrivatePort: int64(p),
                                PublicPort:  int64(h),
                                Type:        port.Proto(),
                                IP:          binding.HostIp,
                        })
                }</span>
        }
        <span class="cov0" title="0">return mapping</span>
}

// Inject the io.Reader at the given path. Note: do not close the reader
func (container *Container) Inject(file io.Reader, pth string) error <span class="cov0" title="0">{
        if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("inject: error mounting container %s: %s", container.ID, err)
        }</span>

        // Return error if path exists
        <span class="cov0" title="0">destPath := path.Join(container.RootfsPath(), pth)
        if _, err := os.Stat(destPath); err == nil </span><span class="cov0" title="0">{
                // Since err is nil, the path could be stat'd and it exists
                return fmt.Errorf("%s exists", pth)
        }</span> <span class="cov0" title="0">else if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Expect err might be that the file doesn't exist, so
                // if it's some other error, return that.

                return err
        }</span>

        // Make sure the directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(path.Join(container.RootfsPath(), path.Dir(pth)), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dest, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer dest.Close()

        if _, err := io.Copy(dest, file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (container *Container) Cmd() *exec.Cmd <span class="cov0" title="0">{
        return container.cmd
}</span>

func (container *Container) When() time.Time <span class="cov0" title="0">{
        return container.Created
}</span>

func (container *Container) FromDisk() error <span class="cov0" title="0">{
        data, err := ioutil.ReadFile(container.jsonPath())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Load container settings
        // udp broke compat of docker.PortMapping, but it's not used when loading a container, we can skip it
        <span class="cov0" title="0">if err := json.Unmarshal(data, container); err != nil &amp;&amp; !strings.Contains(err.Error(), "docker.PortMapping") </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return container.readHostConfig()</span>
}

func (container *Container) ToDisk() (err error) <span class="cov0" title="0">{
        data, err := json.Marshal(container)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = ioutil.WriteFile(container.jsonPath(), data, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return container.writeHostConfig()</span>
}

func (container *Container) readHostConfig() error <span class="cov0" title="0">{
        container.hostConfig = &amp;HostConfig{}
        // If the hostconfig file does not exist, do not read it.
        // (We still have to initialize container.hostConfig,
        // but that's OK, since we just did that above.)
        _, err := os.Stat(container.hostConfigPath())
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">data, err := ioutil.ReadFile(container.hostConfigPath())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(data, container.hostConfig)</span>
}

func (container *Container) writeHostConfig() (err error) <span class="cov0" title="0">{
        data, err := json.Marshal(container.hostConfig)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return ioutil.WriteFile(container.hostConfigPath(), data, 0666)</span>
}

func (container *Container) generateEnvConfig(env []string) error <span class="cov0" title="0">{
        data, err := json.Marshal(env)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">p, err := container.EnvConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ioutil.WriteFile(p, data, 0600)
        return nil</span>
}

func (container *Container) generateLXCConfig() error <span class="cov8" title="1">{
        fo, err := os.Create(container.lxcConfigPath())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer fo.Close()
        return LxcTemplateCompiled.Execute(fo, container)</span>
}

func (container *Container) startPty() error <span class="cov0" title="0">{
        ptyMaster, ptySlave, err := pty.Open()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">container.ptyMaster = ptyMaster
        container.cmd.Stdout = ptySlave
        container.cmd.Stderr = ptySlave

        // Copy the PTYs to our broadcasters
        go func() </span><span class="cov0" title="0">{
                defer container.stdout.CloseWriters()
                utils.Debugf("startPty: begin of stdout pipe")
                io.Copy(container.stdout, ptyMaster)
                utils.Debugf("startPty: end of stdout pipe")
        }</span>()

        // stdin
        <span class="cov0" title="0">if container.Config.OpenStdin </span><span class="cov0" title="0">{
                container.cmd.Stdin = ptySlave
                container.cmd.SysProcAttr.Setctty = true
                go func() </span><span class="cov0" title="0">{
                        defer container.stdin.Close()
                        utils.Debugf("startPty: begin of stdin pipe")
                        io.Copy(ptyMaster, container.stdin)
                        utils.Debugf("startPty: end of stdin pipe")
                }</span>()
        }
        <span class="cov0" title="0">if err := container.cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ptySlave.Close()
        return nil</span>
}

func (container *Container) start() error <span class="cov0" title="0">{
        container.cmd.Stdout = container.stdout
        container.cmd.Stderr = container.stderr
        if container.Config.OpenStdin </span><span class="cov0" title="0">{
                stdin, err := container.cmd.StdinPipe()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        defer stdin.Close()
                        utils.Debugf("start: begin of stdin pipe")
                        io.Copy(stdin, container.stdin)
                        utils.Debugf("start: end of stdin pipe")
                }</span>()
        }
        <span class="cov0" title="0">return container.cmd.Start()</span>
}

func (container *Container) Attach(stdin io.ReadCloser, stdinCloser io.Closer, stdout io.Writer, stderr io.Writer) chan error <span class="cov0" title="0">{
        var cStdout, cStderr io.ReadCloser

        var nJobs int
        errors := make(chan error, 3)
        if stdin != nil &amp;&amp; container.Config.OpenStdin </span><span class="cov0" title="0">{
                nJobs += 1
                if cStdin, err := container.StdinPipe(); err != nil </span><span class="cov0" title="0">{
                        errors &lt;- err
                }</span> <span class="cov0" title="0">else {
                        go func() </span><span class="cov0" title="0">{
                                utils.Debugf("attach: stdin: begin")
                                defer utils.Debugf("attach: stdin: end")
                                // No matter what, when stdin is closed (io.Copy unblock), close stdout and stderr
                                if container.Config.StdinOnce &amp;&amp; !container.Config.Tty </span><span class="cov0" title="0">{
                                        defer cStdin.Close()
                                }</span> <span class="cov0" title="0">else {
                                        if cStdout != nil </span><span class="cov0" title="0">{
                                                defer cStdout.Close()
                                        }</span>
                                        <span class="cov0" title="0">if cStderr != nil </span><span class="cov0" title="0">{
                                                defer cStderr.Close()
                                        }</span>
                                }
                                <span class="cov0" title="0">if container.Config.Tty </span><span class="cov0" title="0">{
                                        _, err = utils.CopyEscapable(cStdin, stdin)
                                }</span> <span class="cov0" title="0">else {
                                        _, err = io.Copy(cStdin, stdin)
                                }</span>
                                <span class="cov0" title="0">if err == io.ErrClosedPipe </span><span class="cov0" title="0">{
                                        err = nil
                                }</span>
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("attach: stdin: %s", err)
                                }</span>
                                <span class="cov0" title="0">errors &lt;- err</span>
                        }()
                }
        }
        <span class="cov0" title="0">if stdout != nil </span><span class="cov0" title="0">{
                nJobs += 1
                if p, err := container.StdoutPipe(); err != nil </span><span class="cov0" title="0">{
                        errors &lt;- err
                }</span> <span class="cov0" title="0">else {
                        cStdout = p
                        go func() </span><span class="cov0" title="0">{
                                utils.Debugf("attach: stdout: begin")
                                defer utils.Debugf("attach: stdout: end")
                                // If we are in StdinOnce mode, then close stdin
                                if container.Config.StdinOnce &amp;&amp; stdin != nil </span><span class="cov0" title="0">{
                                        defer stdin.Close()
                                }</span>
                                <span class="cov0" title="0">if stdinCloser != nil </span><span class="cov0" title="0">{
                                        defer stdinCloser.Close()
                                }</span>
                                <span class="cov0" title="0">_, err := io.Copy(stdout, cStdout)
                                if err == io.ErrClosedPipe </span><span class="cov0" title="0">{
                                        err = nil
                                }</span>
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("attach: stdout: %s", err)
                                }</span>
                                <span class="cov0" title="0">errors &lt;- err</span>
                        }()
                }
        } <span class="cov0" title="0">else {
                go func() </span><span class="cov0" title="0">{
                        if stdinCloser != nil </span><span class="cov0" title="0">{
                                defer stdinCloser.Close()
                        }</span>
                        <span class="cov0" title="0">if cStdout, err := container.StdoutPipe(); err != nil </span><span class="cov0" title="0">{
                                utils.Errorf("attach: stdout pipe: %s", err)
                        }</span> <span class="cov0" title="0">else {
                                io.Copy(&amp;utils.NopWriter{}, cStdout)
                        }</span>
                }()
        }
        <span class="cov0" title="0">if stderr != nil </span><span class="cov0" title="0">{
                nJobs += 1
                if p, err := container.StderrPipe(); err != nil </span><span class="cov0" title="0">{
                        errors &lt;- err
                }</span> <span class="cov0" title="0">else {
                        cStderr = p
                        go func() </span><span class="cov0" title="0">{
                                utils.Debugf("attach: stderr: begin")
                                defer utils.Debugf("attach: stderr: end")
                                // If we are in StdinOnce mode, then close stdin
                                if container.Config.StdinOnce &amp;&amp; stdin != nil </span><span class="cov0" title="0">{
                                        defer stdin.Close()
                                }</span>
                                <span class="cov0" title="0">if stdinCloser != nil </span><span class="cov0" title="0">{
                                        defer stdinCloser.Close()
                                }</span>
                                <span class="cov0" title="0">_, err := io.Copy(stderr, cStderr)
                                if err == io.ErrClosedPipe </span><span class="cov0" title="0">{
                                        err = nil
                                }</span>
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("attach: stderr: %s", err)
                                }</span>
                                <span class="cov0" title="0">errors &lt;- err</span>
                        }()
                }
        } <span class="cov0" title="0">else {
                go func() </span><span class="cov0" title="0">{
                        if stdinCloser != nil </span><span class="cov0" title="0">{
                                defer stdinCloser.Close()
                        }</span>

                        <span class="cov0" title="0">if cStderr, err := container.StderrPipe(); err != nil </span><span class="cov0" title="0">{
                                utils.Errorf("attach: stdout pipe: %s", err)
                        }</span> <span class="cov0" title="0">else {
                                io.Copy(&amp;utils.NopWriter{}, cStderr)
                        }</span>
                }()
        }

        <span class="cov0" title="0">return utils.Go(func() error </span><span class="cov0" title="0">{
                if cStdout != nil </span><span class="cov0" title="0">{
                        defer cStdout.Close()
                }</span>
                <span class="cov0" title="0">if cStderr != nil </span><span class="cov0" title="0">{
                        defer cStderr.Close()
                }</span>
                // FIXME: how to clean up the stdin goroutine without the unwanted side effect
                // of closing the passed stdin? Add an intermediary io.Pipe?
                <span class="cov0" title="0">for i := 0; i &lt; nJobs; i += 1 </span><span class="cov0" title="0">{
                        utils.Debugf("attach: waiting for job %d/%d", i+1, nJobs)
                        if err := &lt;-errors; err != nil </span><span class="cov0" title="0">{
                                utils.Errorf("attach: job %d returned error %s, aborting all jobs", i+1, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">utils.Debugf("attach: job %d completed successfully", i+1)</span>
                }
                <span class="cov0" title="0">utils.Debugf("attach: all jobs completed successfully")
                return nil</span>
        })
}

func (container *Container) Start() (err error) <span class="cov0" title="0">{
        container.Lock()
        defer container.Unlock()

        if container.State.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("The container %s is already running.", container.ID)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        container.cleanup()
                }</span>
        }()
        <span class="cov0" title="0">if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if container.runtime.networkManager.disabled </span><span class="cov0" title="0">{
                container.Config.NetworkDisabled = true
                container.buildHostnameAndHostsFiles("127.0.1.1")
        }</span> <span class="cov0" title="0">else {
                if err := container.allocateNetwork(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">container.buildHostnameAndHostsFiles(container.NetworkSettings.IPAddress)</span>
        }

        // Make sure the config is compatible with the current kernel
        <span class="cov0" title="0">if container.Config.Memory &gt; 0 &amp;&amp; !container.runtime.capabilities.MemoryLimit </span><span class="cov0" title="0">{
                log.Printf("WARNING: Your kernel does not support memory limit capabilities. Limitation discarded.\n")
                container.Config.Memory = 0
        }</span>
        <span class="cov0" title="0">if container.Config.Memory &gt; 0 &amp;&amp; !container.runtime.capabilities.SwapLimit </span><span class="cov0" title="0">{
                log.Printf("WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.\n")
                container.Config.MemorySwap = -1
        }</span>

        <span class="cov0" title="0">if container.runtime.capabilities.IPv4ForwardingDisabled </span><span class="cov0" title="0">{
                log.Printf("WARNING: IPv4 forwarding is disabled. Networking will not work")
        }</span>

        <span class="cov0" title="0">if container.Volumes == nil || len(container.Volumes) == 0 </span><span class="cov0" title="0">{
                container.Volumes = make(map[string]string)
                container.VolumesRW = make(map[string]bool)
        }</span>

        // Apply volumes from another container if requested
        <span class="cov0" title="0">if err := container.applyExternalVolumes(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := container.createVolumes(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := container.generateLXCConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var lxcStart string = "lxc-start"
        if container.hostConfig.Privileged &amp;&amp; container.runtime.capabilities.AppArmor </span><span class="cov0" title="0">{
                lxcStart = path.Join(container.runtime.config.Root, "lxc-start-unconfined")
        }</span>

        <span class="cov0" title="0">params := []string{
                lxcStart,
                "-n", container.ID,
                "-f", container.lxcConfigPath(),
                "--",
                "/.dockerinit",
        }

        // Networking
        if !container.Config.NetworkDisabled </span><span class="cov0" title="0">{
                network := container.NetworkSettings
                params = append(params,
                        "-g", network.Gateway,
                        "-i", fmt.Sprintf("%s/%d", network.IPAddress, network.IPPrefixLen),
                        "-mtu", strconv.Itoa(container.runtime.config.Mtu),
                )
        }</span>

        // User
        <span class="cov0" title="0">if container.Config.User != "" </span><span class="cov0" title="0">{
                params = append(params, "-u", container.Config.User)
        }</span>

        // Setup environment
        <span class="cov0" title="0">env := []string{
                "HOME=/",
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "HOSTNAME=" + container.Config.Hostname,
        }

        if container.Config.Tty </span><span class="cov0" title="0">{
                env = append(env, "TERM=xterm")
        }</span>

        <span class="cov0" title="0">if container.hostConfig.Privileged </span><span class="cov0" title="0">{
                params = append(params, "-privileged")
        }</span>

        // Init any links between the parent and children
        <span class="cov0" title="0">runtime := container.runtime

        children, err := runtime.Children(container.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(children) &gt; 0 </span><span class="cov0" title="0">{
                container.activeLinks = make(map[string]*Link, len(children))

                // If we encounter an error make sure that we rollback any network
                // config and ip table changes
                rollback := func() </span><span class="cov0" title="0">{
                        for _, link := range container.activeLinks </span><span class="cov0" title="0">{
                                link.Disable()
                        }</span>
                        <span class="cov0" title="0">container.activeLinks = nil</span>
                }

                <span class="cov0" title="0">for p, child := range children </span><span class="cov0" title="0">{
                        link, err := NewLink(container, child, p, runtime.networkManager.bridgeIface)
                        if err != nil </span><span class="cov0" title="0">{
                                rollback()
                                return err
                        }</span>

                        <span class="cov0" title="0">container.activeLinks[link.Alias()] = link
                        if err := link.Enable(); err != nil </span><span class="cov0" title="0">{
                                rollback()
                                return err
                        }</span>

                        <span class="cov0" title="0">for _, envVar := range link.ToEnv() </span><span class="cov0" title="0">{
                                env = append(env, envVar)
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, elem := range container.Config.Env </span><span class="cov0" title="0">{
                env = append(env, elem)
        }</span>

        <span class="cov0" title="0">if err := container.generateEnvConfig(env); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if container.Config.WorkingDir != "" </span><span class="cov0" title="0">{
                workingDir := path.Clean(container.Config.WorkingDir)
                utils.Debugf("[working dir] working dir is %s", workingDir)

                if err := os.MkdirAll(path.Join(container.RootfsPath(), workingDir), 0755); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">params = append(params,
                        "-w", workingDir,
                )</span>
        }

        // Program
        <span class="cov0" title="0">params = append(params, "--", container.Path)
        params = append(params, container.Args...)

        if RootIsShared() </span><span class="cov0" title="0">{
                // lxc-start really needs / to be non-shared, or all kinds of stuff break
                // when lxc-start unmount things and those unmounts propagate to the main
                // mount namespace.
                // What we really want is to clone into a new namespace and then
                // mount / MS_REC|MS_SLAVE, but since we can't really clone or fork
                // without exec in go we have to do this horrible shell hack...
                shellString :=
                        "mount --make-rslave /; exec " +
                                utils.ShellQuoteArguments(params)

                params = []string{
                        "unshare", "-m", "--", "/bin/sh", "-c", shellString,
                }
        }</span>

        <span class="cov0" title="0">root := container.RootfsPath()
        envPath, err := container.EnvConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Mount docker specific files into the containers root fs
        <span class="cov0" title="0">if err := mount.Mount(runtime.sysInitPath, path.Join(root, "/.dockerinit"), "none", "bind,ro"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := mount.Mount(envPath, path.Join(root, "/.dockerenv"), "none", "bind,ro"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := mount.Mount(container.ResolvConfPath, path.Join(root, "/etc/resolv.conf"), "none", "bind,ro"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if container.HostnamePath != "" &amp;&amp; container.HostsPath != "" </span><span class="cov0" title="0">{
                if err := mount.Mount(container.HostnamePath, path.Join(root, "/etc/hostname"), "none", "bind,ro"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := mount.Mount(container.HostsPath, path.Join(root, "/etc/hosts"), "none", "bind,ro"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Mount user specified volumes

        <span class="cov0" title="0">for r, v := range container.Volumes </span><span class="cov0" title="0">{
                mountAs := "ro"
                if container.VolumesRW[v] </span><span class="cov0" title="0">{
                        mountAs = "rw"
                }</span>

                <span class="cov0" title="0">if err := mount.Mount(v, path.Join(root, r), "none", fmt.Sprintf("bind,%s", mountAs)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">container.cmd = exec.Command(params[0], params[1:]...)

        // Setup logging of stdout and stderr to disk
        if err := container.runtime.LogToDisk(container.stdout, container.logPath("json"), "stdout"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := container.runtime.LogToDisk(container.stderr, container.logPath("json"), "stderr"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">container.cmd.SysProcAttr = &amp;syscall.SysProcAttr{Setsid: true}

        if container.Config.Tty </span><span class="cov0" title="0">{
                err = container.startPty()
        }</span> <span class="cov0" title="0">else {
                err = container.start()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // FIXME: save state on disk *first*, then converge
        // this way disk state is used as a journal, eg. we can restore after crash etc.
        <span class="cov0" title="0">container.State.SetRunning(container.cmd.Process.Pid)

        // Init the lock
        container.waitLock = make(chan struct{})

        container.ToDisk()
        go container.monitor()

        defer utils.Debugf("Container running: %v", container.State.IsRunning())
        // We wait for the container to be fully running.
        // Timeout after 5 seconds. In case of broken pipe, just retry.
        // Note: The container can run and finish correctly before
        //       the end of this loop
        for now := time.Now(); time.Since(now) &lt; 5*time.Second; </span><span class="cov0" title="0">{
                // If the container dies while waiting for it, just return
                if !container.State.IsRunning() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">output, err := exec.Command("lxc-info", "-s", "-n", container.ID).CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error with lxc-info: %s (%s)", err, output)

                        output, err = exec.Command("lxc-info", "-s", "-n", container.ID).CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Debugf("Second Error with lxc-info: %s (%s)", err, output)
                                return err
                        }</span>

                }
                <span class="cov0" title="0">if strings.Contains(string(output), "RUNNING") </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">utils.Debugf("Waiting for the container to start (running: %v): %s", container.State.IsRunning(), bytes.TrimSpace(output))
                time.Sleep(50 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">if container.State.IsRunning() </span><span class="cov0" title="0">{
                return ErrContainerStartTimeout
        }</span>
        <span class="cov0" title="0">return ErrContainerStart</span>
}

func (container *Container) getBindMap() (map[string]BindMap, error) <span class="cov0" title="0">{
        // Create the requested bind mounts
        binds := make(map[string]BindMap)
        // Define illegal container destinations
        illegalDsts := []string{"/", "."}

        for _, bind := range container.hostConfig.Binds </span><span class="cov0" title="0">{
                // FIXME: factorize bind parsing in parseBind
                var src, dst, mode string
                arr := strings.Split(bind, ":")
                if len(arr) == 2 </span><span class="cov0" title="0">{
                        src = arr[0]
                        dst = arr[1]
                        mode = "rw"
                }</span> <span class="cov0" title="0">else if len(arr) == 3 </span><span class="cov0" title="0">{
                        src = arr[0]
                        dst = arr[1]
                        mode = arr[2]
                }</span> <span class="cov0" title="0">else {
                        return nil, fmt.Errorf("Invalid bind specification: %s", bind)
                }</span>

                // Bail if trying to mount to an illegal destination
                <span class="cov0" title="0">for _, illegal := range illegalDsts </span><span class="cov0" title="0">{
                        if dst == illegal </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Illegal bind destination: %s", dst)
                        }</span>
                }

                <span class="cov0" title="0">bindMap := BindMap{
                        SrcPath: src,
                        DstPath: dst,
                        Mode:    mode,
                }
                binds[path.Clean(dst)] = bindMap</span>
        }
        <span class="cov0" title="0">return binds, nil</span>
}

func (container *Container) createVolumes() error <span class="cov0" title="0">{
        binds, err := container.getBindMap()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">volumesDriver := container.runtime.volumes.driver
        // Create the requested volumes if they don't exist
        for volPath := range container.Config.Volumes </span><span class="cov0" title="0">{
                volPath = path.Clean(volPath)
                volIsDir := true
                // Skip existing volumes
                if _, exists := container.Volumes[volPath]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var srcPath string
                var isBindMount bool
                srcRW := false
                // If an external bind is defined for this volume, use that as a source
                if bindMap, exists := binds[volPath]; exists </span><span class="cov0" title="0">{
                        isBindMount = true
                        srcPath = bindMap.SrcPath
                        if strings.ToLower(bindMap.Mode) == "rw" </span><span class="cov0" title="0">{
                                srcRW = true
                        }</span>
                        <span class="cov0" title="0">if stat, err := os.Lstat(bindMap.SrcPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span> <span class="cov0" title="0">else {
                                volIsDir = stat.IsDir()
                        }</span>
                        // Otherwise create an directory in $ROOT/volumes/ and use that
                } <span class="cov0" title="0">else {

                        // Do not pass a container as the parameter for the volume creation.
                        // The graph driver using the container's information ( Image ) to
                        // create the parent.
                        c, err := container.runtime.volumes.Create(nil, nil, "", "", nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">srcPath, err = volumesDriver.Get(c.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Driver %s failed to get volume rootfs %s: %s", volumesDriver, c.ID, err)
                        }</span>
                        <span class="cov0" title="0">srcRW = true</span> // RW by default
                }
                <span class="cov0" title="0">container.Volumes[volPath] = srcPath
                container.VolumesRW[volPath] = srcRW

                // Create the mountpoint
                volPath = path.Join(container.RootfsPath(), volPath)
                rootVolPath, err := utils.FollowSymlinkInScope(volPath, container.RootfsPath())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(rootVolPath); err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                if volIsDir </span><span class="cov0" title="0">{
                                        if err := os.MkdirAll(rootVolPath, 0755); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                } <span class="cov0" title="0">else {
                                        if err := os.MkdirAll(path.Dir(rootVolPath), 0755); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if f, err := os.OpenFile(rootVolPath, os.O_CREATE, 0755); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span> <span class="cov0" title="0">else {
                                                f.Close()
                                        }</span>
                                }
                        }
                }

                // Do not copy or change permissions if we are mounting from the host
                <span class="cov0" title="0">if srcRW &amp;&amp; !isBindMount </span><span class="cov0" title="0">{
                        volList, err := ioutil.ReadDir(rootVolPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if len(volList) &gt; 0 </span><span class="cov0" title="0">{
                                srcList, err := ioutil.ReadDir(srcPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if len(srcList) == 0 </span><span class="cov0" title="0">{
                                        // If the source volume is empty copy files from the root into the volume
                                        if err := archive.CopyWithTar(rootVolPath, srcPath); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">var stat syscall.Stat_t
                                        if err := syscall.Stat(rootVolPath, &amp;stat); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">var srcStat syscall.Stat_t
                                        if err := syscall.Stat(srcPath, &amp;srcStat); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        // Change the source volume's ownership if it differs from the root
                                        // files that where just copied
                                        <span class="cov0" title="0">if stat.Uid != srcStat.Uid || stat.Gid != srcStat.Gid </span><span class="cov0" title="0">{
                                                if err := os.Chown(srcPath, int(stat.Uid), int(stat.Gid)); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (container *Container) applyExternalVolumes() error <span class="cov0" title="0">{
        if container.Config.VolumesFrom != "" </span><span class="cov0" title="0">{
                containerSpecs := strings.Split(container.Config.VolumesFrom, ",")
                for _, containerSpec := range containerSpecs </span><span class="cov0" title="0">{
                        mountRW := true
                        specParts := strings.SplitN(containerSpec, ":", 2)
                        switch len(specParts) </span>{
                        <span class="cov0" title="0">case 0:
                                return fmt.Errorf("Malformed volumes-from specification: %s", container.Config.VolumesFrom)</span>
                        <span class="cov0" title="0">case 2:
                                switch specParts[1] </span>{
                                <span class="cov0" title="0">case "ro":
                                        mountRW = false</span>
                                <span class="cov0" title="0">case "rw":</span> // mountRW is already true
                                <span class="cov0" title="0">default:
                                        return fmt.Errorf("Malformed volumes-from speficication: %s", containerSpec)</span>
                                }
                        }
                        <span class="cov0" title="0">c := container.runtime.Get(specParts[0])
                        if c == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Container %s not found. Impossible to mount its volumes", container.ID)
                        }</span>
                        <span class="cov0" title="0">for volPath, id := range c.Volumes </span><span class="cov0" title="0">{
                                if _, exists := container.Volumes[volPath]; exists </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err := os.MkdirAll(path.Join(container.RootfsPath(), volPath), 0755); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">container.Volumes[volPath] = id
                                if isRW, exists := c.VolumesRW[volPath]; exists </span><span class="cov0" title="0">{
                                        container.VolumesRW[volPath] = isRW &amp;&amp; mountRW
                                }</span>
                        }

                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (container *Container) Run() error <span class="cov0" title="0">{
        if err := container.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">container.Wait()
        return nil</span>
}

func (container *Container) Output() (output []byte, err error) <span class="cov0" title="0">{
        pipe, err := container.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer pipe.Close()
        if err := container.Start(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">output, err = ioutil.ReadAll(pipe)
        container.Wait()
        return output, err</span>
}

// Container.StdinPipe returns a WriteCloser which can be used to feed data
// to the standard input of the container's active process.
// Container.StdoutPipe and Container.StderrPipe each return a ReadCloser
// which can be used to retrieve the standard output (and error) generated
// by the container's active process. The output (and error) are actually
// copied and delivered to all StdoutPipe and StderrPipe consumers, using
// a kind of "broadcaster".

func (container *Container) StdinPipe() (io.WriteCloser, error) <span class="cov0" title="0">{
        return container.stdinPipe, nil
}</span>

func (container *Container) StdoutPipe() (io.ReadCloser, error) <span class="cov0" title="0">{
        reader, writer := io.Pipe()
        container.stdout.AddWriter(writer, "")
        return utils.NewBufReader(reader), nil
}</span>

func (container *Container) StderrPipe() (io.ReadCloser, error) <span class="cov0" title="0">{
        reader, writer := io.Pipe()
        container.stderr.AddWriter(writer, "")
        return utils.NewBufReader(reader), nil
}</span>

func (container *Container) buildHostnameAndHostsFiles(IP string) <span class="cov0" title="0">{
        container.HostnamePath = path.Join(container.root, "hostname")
        ioutil.WriteFile(container.HostnamePath, []byte(container.Config.Hostname+"\n"), 0644)

        hostsContent := []byte(`
127.0.0.1        localhost
::1                localhost ip6-localhost ip6-loopback
fe00::0                ip6-localnet
ff00::0                ip6-mcastprefix
ff02::1                ip6-allnodes
ff02::2                ip6-allrouters
`)

        container.HostsPath = path.Join(container.root, "hosts")

        if container.Config.Domainname != "" </span><span class="cov0" title="0">{
                hostsContent = append([]byte(fmt.Sprintf("%s\t%s.%s %s\n", IP, container.Config.Hostname, container.Config.Domainname, container.Config.Hostname)), hostsContent...)
        }</span> <span class="cov0" title="0">else if !container.Config.NetworkDisabled </span><span class="cov0" title="0">{
                hostsContent = append([]byte(fmt.Sprintf("%s\t%s\n", IP, container.Config.Hostname)), hostsContent...)
        }</span>

        <span class="cov0" title="0">ioutil.WriteFile(container.HostsPath, hostsContent, 0644)</span>
}

func (container *Container) allocateNetwork() error <span class="cov0" title="0">{
        if container.Config.NetworkDisabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var (
                iface *NetworkInterface
                err   error
        )
        if container.State.IsGhost() </span><span class="cov0" title="0">{
                if manager := container.runtime.networkManager; manager.disabled </span><span class="cov0" title="0">{
                        iface = &amp;NetworkInterface{disabled: true}
                }</span> <span class="cov0" title="0">else {
                        iface = &amp;NetworkInterface{
                                IPNet:   net.IPNet{IP: net.ParseIP(container.NetworkSettings.IPAddress), Mask: manager.bridgeNetwork.Mask},
                                Gateway: manager.bridgeNetwork.IP,
                                manager: manager,
                        }
                        if iface != nil &amp;&amp; iface.IPNet.IP != nil </span><span class="cov0" title="0">{
                                ipNum := ipToInt(iface.IPNet.IP)
                                manager.ipAllocator.inUse[ipNum] = struct{}{}
                        }</span> <span class="cov0" title="0">else {
                                iface, err = container.runtime.networkManager.Allocate()
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        } <span class="cov0" title="0">else {
                iface, err = container.runtime.networkManager.Allocate()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if container.Config.PortSpecs != nil </span><span class="cov0" title="0">{
                utils.Debugf("Migrating port mappings for container: %s", strings.Join(container.Config.PortSpecs, ", "))
                if err := migratePortMappings(container.Config, container.hostConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">container.Config.PortSpecs = nil
                if err := container.writeHostConfig(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">var (
                portSpecs = make(map[Port]struct{})
                bindings  = make(map[Port][]PortBinding)
        )

        if !container.State.IsGhost() </span><span class="cov0" title="0">{
                if container.Config.ExposedPorts != nil </span><span class="cov0" title="0">{
                        portSpecs = container.Config.ExposedPorts
                }</span>
                <span class="cov0" title="0">if container.hostConfig.PortBindings != nil </span><span class="cov0" title="0">{
                        bindings = container.hostConfig.PortBindings
                }</span>
        } <span class="cov0" title="0">else {
                if container.NetworkSettings.Ports != nil </span><span class="cov0" title="0">{
                        for port, binding := range container.NetworkSettings.Ports </span><span class="cov0" title="0">{
                                portSpecs[port] = struct{}{}
                                bindings[port] = binding
                        }</span>
                }
        }

        <span class="cov0" title="0">container.NetworkSettings.PortMapping = nil

        for port := range portSpecs </span><span class="cov0" title="0">{
                binding := bindings[port]
                if container.hostConfig.PublishAllPorts &amp;&amp; len(binding) == 0 </span><span class="cov0" title="0">{
                        binding = append(binding, PortBinding{})
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; len(binding); i++ </span><span class="cov0" title="0">{
                        b := binding[i]
                        nat, err := iface.AllocatePort(port, b)
                        if err != nil </span><span class="cov0" title="0">{
                                iface.Release()
                                return err
                        }</span>
                        <span class="cov0" title="0">utils.Debugf("Allocate port: %s:%s-&gt;%s", nat.Binding.HostIp, port, nat.Binding.HostPort)
                        binding[i] = nat.Binding</span>
                }
                <span class="cov0" title="0">bindings[port] = binding</span>
        }
        <span class="cov0" title="0">container.writeHostConfig()

        container.NetworkSettings.Ports = bindings
        container.network = iface

        container.NetworkSettings.Bridge = container.runtime.networkManager.bridgeIface
        container.NetworkSettings.IPAddress = iface.IPNet.IP.String()
        container.NetworkSettings.IPPrefixLen, _ = iface.IPNet.Mask.Size()
        container.NetworkSettings.Gateway = iface.Gateway.String()

        return nil</span>
}

func (container *Container) releaseNetwork() <span class="cov0" title="0">{
        if container.Config.NetworkDisabled || container.network == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">container.network.Release()
        container.network = nil
        container.NetworkSettings = &amp;NetworkSettings{}</span>
}

// FIXME: replace this with a control socket within dockerinit
func (container *Container) waitLxc() error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                output, err := exec.Command("lxc-info", "-n", container.ID).CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !strings.Contains(string(output), "RUNNING") </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)</span>
        }
}

func (container *Container) monitor() <span class="cov0" title="0">{
        // Wait for the program to exit

        // If the command does not exist, try to wait via lxc
        // (This probably happens only for ghost containers, i.e. containers that were running when Docker started)
        if container.cmd == nil </span><span class="cov0" title="0">{
                utils.Debugf("monitor: waiting for container %s using waitLxc", container.ID)
                if err := container.waitLxc(); err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("monitor: while waiting for container %s, waitLxc had a problem: %s", container.ID, err)
                }</span>
        } <span class="cov0" title="0">else {
                utils.Debugf("monitor: waiting for container %s using cmd.Wait", container.ID)
                if err := container.cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                        // Since non-zero exit status and signal terminations will cause err to be non-nil,
                        // we have to actually discard it. Still, log it anyway, just in case.
                        utils.Debugf("monitor: cmd.Wait reported exit status %s for container %s", err, container.ID)
                }</span>
        }
        <span class="cov0" title="0">utils.Debugf("monitor: container %s finished", container.ID)

        exitCode := -1
        if container.cmd != nil </span><span class="cov0" title="0">{
                exitCode = container.cmd.ProcessState.Sys().(syscall.WaitStatus).ExitStatus()
        }</span>

        <span class="cov0" title="0">if container.runtime != nil &amp;&amp; container.runtime.srv != nil </span><span class="cov0" title="0">{
                container.runtime.srv.LogEvent("die", container.ID, container.runtime.repositories.ImageName(container.Image))
        }</span>

        // Cleanup
        <span class="cov0" title="0">container.cleanup()

        // Re-create a brand new stdin pipe once the container exited
        if container.Config.OpenStdin </span><span class="cov0" title="0">{
                container.stdin, container.stdinPipe = io.Pipe()
        }</span>

        // Report status back
        <span class="cov0" title="0">container.State.SetStopped(exitCode)

        // Release the lock
        close(container.waitLock)

        if err := container.ToDisk(); err != nil </span><span class="cov0" title="0">{
                // FIXME: there is a race condition here which causes this to fail during the unit tests.
                // If another goroutine was waiting for Wait() to return before removing the container's root
                // from the filesystem... At this point it may already have done so.
                // This is because State.setStopped() has already been called, and has caused Wait()
                // to return.
                // FIXME: why are we serializing running state to disk in the first place?
                //log.Printf("%s: Failed to dump configuration to the disk: %s", container.ID, err)
        }</span>
}

func (container *Container) cleanup() <span class="cov0" title="0">{
        container.releaseNetwork()

        // Disable all active links
        if container.activeLinks != nil </span><span class="cov0" title="0">{
                for _, link := range container.activeLinks </span><span class="cov0" title="0">{
                        link.Disable()
                }</span>
        }

        <span class="cov0" title="0">if container.Config.OpenStdin </span><span class="cov0" title="0">{
                if err := container.stdin.Close(); err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("%s: Error close stdin: %s", container.ID, err)
                }</span>
        }
        <span class="cov0" title="0">if err := container.stdout.CloseWriters(); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("%s: Error close stdout: %s", container.ID, err)
        }</span>
        <span class="cov0" title="0">if err := container.stderr.CloseWriters(); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("%s: Error close stderr: %s", container.ID, err)
        }</span>

        <span class="cov0" title="0">if container.ptyMaster != nil </span><span class="cov0" title="0">{
                if err := container.ptyMaster.Close(); err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("%s: Error closing Pty master: %s", container.ID, err)
                }</span>
        }

        <span class="cov0" title="0">if err := container.Unmount(); err != nil </span><span class="cov0" title="0">{
                log.Printf("%v: Failed to umount filesystem: %v", container.ID, err)
        }</span>
}

func (container *Container) kill(sig int) error <span class="cov0" title="0">{
        container.Lock()
        defer container.Unlock()

        if !container.State.IsRunning() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if output, err := exec.Command("lxc-kill", "-n", container.ID, strconv.Itoa(sig)).CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                log.Printf("error killing container %s (%s, %s)", utils.TruncateID(container.ID), output, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (container *Container) Kill() error <span class="cov0" title="0">{
        if !container.State.IsRunning() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 1. Send SIGKILL
        <span class="cov0" title="0">if err := container.kill(9); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 2. Wait for the process to die, in last resort, try to kill the process directly
        <span class="cov0" title="0">if err := container.WaitTimeout(10 * time.Second); err != nil </span><span class="cov0" title="0">{
                if container.cmd == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("lxc-kill failed, impossible to kill the container %s", utils.TruncateID(container.ID))
                }</span>
                <span class="cov0" title="0">log.Printf("Container %s failed to exit within 10 seconds of lxc-kill %s - trying direct SIGKILL", "SIGKILL", utils.TruncateID(container.ID))
                if err := container.cmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">container.Wait()
        return nil</span>
}

func (container *Container) Stop(seconds int) error <span class="cov0" title="0">{
        if !container.State.IsRunning() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 1. Send a SIGTERM
        <span class="cov0" title="0">if err := container.kill(15); err != nil </span><span class="cov0" title="0">{
                utils.Debugf("Error sending kill SIGTERM: %s", err)
                log.Print("Failed to send SIGTERM to the process, force killing")
                if err := container.kill(9); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 2. Wait for the process to exit on its own
        <span class="cov0" title="0">if err := container.WaitTimeout(time.Duration(seconds) * time.Second); err != nil </span><span class="cov0" title="0">{
                log.Printf("Container %v failed to exit within %d seconds of SIGTERM - using the force", container.ID, seconds)
                // 3. If it doesn't, then send SIGKILL
                if err := container.Kill(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (container *Container) Restart(seconds int) error <span class="cov0" title="0">{
        if err := container.Stop(seconds); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return container.Start()</span>
}

// Wait blocks until the container stops running, then returns its exit code.
func (container *Container) Wait() int <span class="cov0" title="0">{
        &lt;-container.waitLock
        return container.State.GetExitCode()
}</span>

func (container *Container) Resize(h, w int) error <span class="cov0" title="0">{
        pty, ok := container.ptyMaster.(*os.File)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("ptyMaster does not have Fd() method")
        }</span>
        <span class="cov0" title="0">return term.SetWinsize(pty.Fd(), &amp;term.Winsize{Height: uint16(h), Width: uint16(w)})</span>
}

func (container *Container) ExportRw() (archive.Archive, error) <span class="cov0" title="0">{
        if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if container.runtime == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Can't load storage driver for unregistered container %s", container.ID)
        }</span>

        <span class="cov0" title="0">return container.runtime.Diff(container)</span>
}

func (container *Container) Export() (archive.Archive, error) <span class="cov0" title="0">{
        if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return archive.Tar(container.RootfsPath(), archive.Uncompressed)</span>
}

func (container *Container) WaitTimeout(timeout time.Duration) error <span class="cov0" title="0">{
        done := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                container.Wait()
                done &lt;- true
        }</span>()

        <span class="cov0" title="0">select </span>{
        <span class="cov0" title="0">case &lt;-time.After(timeout):
                return fmt.Errorf("Timed Out")</span>
        <span class="cov0" title="0">case &lt;-done:
                return nil</span>
        }
}

func (container *Container) EnsureMounted() error <span class="cov0" title="0">{
        // FIXME: EnsureMounted is deprecated because drivers are now responsible
        // for re-entrant mounting in their Get() method.
        return container.Mount()
}</span>

func (container *Container) Mount() error <span class="cov0" title="0">{
        return container.runtime.Mount(container)
}</span>

func (container *Container) Changes() ([]archive.Change, error) <span class="cov0" title="0">{
        return container.runtime.Changes(container)
}</span>

func (container *Container) GetImage() (*Image, error) <span class="cov0" title="0">{
        if container.runtime == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Can't get image of unregistered container")
        }</span>
        <span class="cov0" title="0">return container.runtime.graph.Get(container.Image)</span>
}

func (container *Container) Unmount() error <span class="cov0" title="0">{
        var (
                err    error
                root   = container.RootfsPath()
                mounts = []string{
                        path.Join(root, "/.dockerinit"),
                        path.Join(root, "/.dockerenv"),
                        path.Join(root, "/etc/resolv.conf"),
                }
        )

        if container.HostnamePath != "" &amp;&amp; container.HostsPath != "" </span><span class="cov0" title="0">{
                mounts = append(mounts, path.Join(root, "/etc/hostname"), path.Join(root, "/etc/hosts"))
        }</span>

        <span class="cov0" title="0">for r := range container.Volumes </span><span class="cov0" title="0">{
                mounts = append(mounts, path.Join(root, r))
        }</span>

        <span class="cov0" title="0">for _, m := range mounts </span><span class="cov0" title="0">{
                if lastError := mount.Unmount(m); lastError != nil </span><span class="cov0" title="0">{
                        err = lastError
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return container.runtime.Unmount(container)</span>
}

func (container *Container) logPath(name string) string <span class="cov0" title="0">{
        return path.Join(container.root, fmt.Sprintf("%s-%s.log", container.ID, name))
}</span>

func (container *Container) ReadLog(name string) (io.Reader, error) <span class="cov0" title="0">{
        return os.Open(container.logPath(name))
}</span>

func (container *Container) hostConfigPath() string <span class="cov0" title="0">{
        return path.Join(container.root, "hostconfig.json")
}</span>

func (container *Container) jsonPath() string <span class="cov0" title="0">{
        return path.Join(container.root, "config.json")
}</span>

func (container *Container) EnvConfigPath() (string, error) <span class="cov0" title="0">{
        p := path.Join(container.root, "config.env")
        if _, err := os.Stat(p); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        f, err := os.Create(p)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">f.Close()</span>
                } <span class="cov0" title="0">else {
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">return p, nil</span>
}

func (container *Container) lxcConfigPath() string <span class="cov8" title="1">{
        return path.Join(container.root, "config.lxc")
}</span>

// This method must be exported to be used from the lxc template
func (container *Container) RootfsPath() string <span class="cov8" title="1">{
        return container.rootfs
}</span>

func validateID(id string) error <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid empty id")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSize, return real size, virtual size
func (container *Container) GetSize() (int64, int64) <span class="cov0" title="0">{
        var (
                sizeRw, sizeRootfs int64
                err                error
                driver             = container.runtime.driver
        )

        if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("Warning: failed to compute size of container rootfs %s: %s", container.ID, err)
                return sizeRw, sizeRootfs
        }</span>

        <span class="cov0" title="0">if differ, ok := container.runtime.driver.(graphdriver.Differ); ok </span><span class="cov0" title="0">{
                sizeRw, err = differ.DiffSize(container.ID)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Warning: driver %s couldn't return diff size of container %s: %s", driver, container.ID, err)
                        // FIXME: GetSize should return an error. Not changing it now in case
                        // there is a side-effect.
                        sizeRw = -1
                }</span>
        } <span class="cov0" title="0">else {
                changes, _ := container.Changes()
                if changes != nil </span><span class="cov0" title="0">{
                        sizeRw = archive.ChangesSize(container.RootfsPath(), changes)
                }</span> <span class="cov0" title="0">else {
                        sizeRw = -1
                }</span>
        }

        <span class="cov0" title="0">if _, err = os.Stat(container.RootfsPath()); err != nil </span><span class="cov0" title="0">{
                if sizeRootfs, err = utils.TreeSize(container.RootfsPath()); err != nil </span><span class="cov0" title="0">{
                        sizeRootfs = -1
                }</span>
        }
        <span class="cov0" title="0">return sizeRw, sizeRootfs</span>
}

func (container *Container) Copy(resource string) (archive.Archive, error) <span class="cov0" title="0">{
        if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var filter []string
        basePath := path.Join(container.RootfsPath(), resource)
        stat, err := os.Stat(basePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !stat.IsDir() </span><span class="cov0" title="0">{
                d, f := path.Split(basePath)
                basePath = d
                filter = []string{f}
        }</span> <span class="cov0" title="0">else {
                filter = []string{path.Base(basePath)}
                basePath = path.Dir(basePath)
        }</span>
        <span class="cov0" title="0">return archive.TarFilter(basePath, &amp;archive.TarOptions{
                Compression: archive.Uncompressed,
                Includes:    filter,
                Recursive:   true,
        })</span>
}

// Returns true if the container exposes a certain port
func (container *Container) Exposes(p Port) bool <span class="cov0" title="0">{
        _, exists := container.Config.ExposedPorts[p]
        return exists
}</span>

func (container *Container) GetPtyMaster() (*os.File, error) <span class="cov0" title="0">{
        if container.ptyMaster == nil </span><span class="cov0" title="0">{
                return nil, ErrNoTTY
        }</span>
        <span class="cov0" title="0">if pty, ok := container.ptyMaster.(*os.File); ok </span><span class="cov0" title="0">{
                return pty, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrNotATTY</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package docker

import (
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/graphdriver"
        "github.com/dotcloud/docker/utils"
        "io"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "runtime"
        "strings"
        "syscall"
        "time"
)

// A Graph is a store for versioned filesystem images and the relationship between them.
type Graph struct {
        Root    string
        idIndex *utils.TruncIndex
        driver  graphdriver.Driver
}

// NewGraph instantiates a new graph at the given root path in the filesystem.
// `root` will be created if it doesn't exist.
func NewGraph(root string, driver graphdriver.Driver) (*Graph, error) <span class="cov8" title="1">{
        abspath, err := filepath.Abs(root)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Create the root directory if it doesn't exists
        <span class="cov8" title="1">if err := os.MkdirAll(root, 0700); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">graph := &amp;Graph{
                Root:    abspath,
                idIndex: utils.NewTruncIndex(),
                driver:  driver,
        }
        if err := graph.restore(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return graph, nil</span>
}

func (graph *Graph) restore() error <span class="cov8" title="1">{
        dir, err := ioutil.ReadDir(graph.Root)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, v := range dir </span><span class="cov8" title="1">{
                id := v.Name()
                if graph.driver.Exists(id) </span><span class="cov0" title="0">{
                        graph.idIndex.Add(id)
                }</span>
        }
        <span class="cov8" title="1">utils.Debugf("Restored %d elements", len(dir))
        return nil</span>
}

// FIXME: Implement error subclass instead of looking at the error text
// Note: This is the way golang implements os.IsNotExists on Plan9
func (graph *Graph) IsNotExist(err error) bool <span class="cov0" title="0">{
        return err != nil &amp;&amp; (strings.Contains(err.Error(), "does not exist") || strings.Contains(err.Error(), "No such"))
}</span>

// Exists returns true if an image is registered at the given id.
// If the image doesn't exist or if an error is encountered, false is returned.
func (graph *Graph) Exists(id string) bool <span class="cov8" title="1">{
        if _, err := graph.Get(id); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Get returns the image with the given id, or an error if the image doesn't exist.
func (graph *Graph) Get(name string) (*Image, error) <span class="cov8" title="1">{
        id, err := graph.idIndex.Get(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // FIXME: return nil when the image doesn't exist, instead of an error
        <span class="cov8" title="1">img, err := LoadImage(graph.imageRoot(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if img.ID != id </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Image stored at '%s' has wrong id '%s'", id, img.ID)
        }</span>
        <span class="cov8" title="1">img.graph = graph

        if img.Size &lt; 0 </span><span class="cov0" title="0">{
                rootfs, err := graph.driver.Get(img.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Driver %s failed to get image rootfs %s: %s", graph.driver, img.ID, err)
                }</span>

                <span class="cov0" title="0">var size int64
                if img.Parent == "" </span><span class="cov0" title="0">{
                        if size, err = utils.TreeSize(rootfs); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } <span class="cov0" title="0">else {
                        parentFs, err := graph.driver.Get(img.Parent)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">changes, err := archive.ChangesDirs(rootfs, parentFs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">size = archive.ChangesSize(rootfs, changes)</span>
                }

                <span class="cov0" title="0">img.Size = size
                if err := img.SaveSize(graph.imageRoot(id)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return img, nil</span>
}

// Create creates a new image and registers it in the graph.
func (graph *Graph) Create(layerData archive.Archive, container *Container, comment, author string, config *Config) (*Image, error) <span class="cov0" title="0">{
        img := &amp;Image{
                ID:            GenerateID(),
                Comment:       comment,
                Created:       time.Now().UTC(),
                DockerVersion: VERSION,
                Author:        author,
                Config:        config,
                Architecture:  runtime.GOARCH,
                OS:            runtime.GOOS,
        }
        if container != nil </span><span class="cov0" title="0">{
                img.Parent = container.Image
                img.Container = container.ID
                img.ContainerConfig = *container.Config
        }</span>
        <span class="cov0" title="0">if err := graph.Register(nil, layerData, img); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return img, nil</span>
}

// Register imports a pre-existing image into the graph.
// FIXME: pass img as first argument
func (graph *Graph) Register(jsonData []byte, layerData archive.Archive, img *Image) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                // If any error occurs, remove the new dir from the driver.
                // Don't check for errors since the dir might not have been created.
                // FIXME: this leaves a possible race condition.
                if err != nil </span><span class="cov0" title="0">{
                        graph.driver.Remove(img.ID)
                }</span>
        }()
        <span class="cov8" title="1">if err := ValidateID(img.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // (This is a convenience to save time. Race conditions are taken care of by os.Rename)
        <span class="cov8" title="1">if graph.Exists(img.ID) </span><span class="cov0" title="0">{
                return fmt.Errorf("Image %s already exists", img.ID)
        }</span>

        // Ensure that the image root does not exist on the filesystem
        // when it is not registered in the graph.
        // This is common when you switch from one graph driver to another
        <span class="cov8" title="1">if err := os.RemoveAll(graph.imageRoot(img.ID)); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the driver has this ID but the graph doesn't, remove it from the driver to start fresh.
        // (the graph is the source of truth).
        // Ignore errors, since we don't know if the driver correctly returns ErrNotExist.
        // (FIXME: make that mandatory for drivers).
        <span class="cov8" title="1">graph.driver.Remove(img.ID)

        tmp, err := graph.Mktemp("")
        defer os.RemoveAll(tmp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Mktemp failed: %s", err)
        }</span>

        // Create root filesystem in the driver
        <span class="cov8" title="1">if err := graph.driver.Create(img.ID, img.Parent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Driver %s failed to create image rootfs %s: %s", graph.driver, img.ID, err)
        }</span>
        // Mount the root filesystem so we can apply the diff/layer
        <span class="cov8" title="1">rootfs, err := graph.driver.Get(img.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Driver %s failed to get image rootfs %s: %s", graph.driver, img.ID, err)
        }</span>
        <span class="cov8" title="1">img.graph = graph
        if err := StoreImage(img, jsonData, layerData, tmp, rootfs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Commit
        <span class="cov8" title="1">if err := os.Rename(tmp, graph.imageRoot(img.ID)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">graph.idIndex.Add(img.ID)
        return nil</span>
}

// TempLayerArchive creates a temporary archive of the given image's filesystem layer.
//   The archive is stored on disk and will be automatically deleted as soon as has been read.
//   If output is not nil, a human-readable progress bar will be written to it.
//   FIXME: does this belong in Graph? How about MktempFile, let the caller use it for archives?
func (graph *Graph) TempLayerArchive(id string, compression archive.Compression, sf *utils.StreamFormatter, output io.Writer) (*archive.TempArchive, error) <span class="cov0" title="0">{
        image, err := graph.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tmp, err := graph.Mktemp("")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">a, err := image.TarLayer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return archive.NewTempArchive(utils.ProgressReader(ioutil.NopCloser(a), 0, output, sf, false, utils.TruncateID(id), "Buffering to disk"), tmp)</span>
}

// Mktemp creates a temporary sub-directory inside the graph's filesystem.
func (graph *Graph) Mktemp(id string) (string, error) <span class="cov8" title="1">{
        dir := path.Join(graph.Root, "_tmp", GenerateID())
        if err := os.MkdirAll(dir, 0700); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return dir, nil</span>
}

// setupInitLayer populates a directory with mountpoints suitable
// for bind-mounting dockerinit into the container. The mountpoint is simply an
// empty file at /.dockerinit
//
// This extra layer is used by all containers as the top-most ro layer. It protects
// the container from unwanted side-effects on the rw layer.
func setupInitLayer(initLayer string) error <span class="cov0" title="0">{
        for pth, typ := range map[string]string{
                "/dev/pts":         "dir",
                "/dev/shm":         "dir",
                "/proc":            "dir",
                "/sys":             "dir",
                "/.dockerinit":     "file",
                "/.dockerenv":      "file",
                "/etc/resolv.conf": "file",
                "/etc/hosts":       "file",
                "/etc/hostname":    "file",
                // "var/run": "dir",
                // "var/lock": "dir",
        } </span><span class="cov0" title="0">{
                parts := strings.Split(pth, "/")
                prev := "/"
                for _, p := range parts[1:] </span><span class="cov0" title="0">{
                        prev = path.Join(prev, p)
                        syscall.Unlink(path.Join(initLayer, prev))
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(path.Join(initLayer, pth)); err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                switch typ </span>{
                                <span class="cov0" title="0">case "dir":
                                        if err := os.MkdirAll(path.Join(initLayer, pth), 0755); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                <span class="cov0" title="0">case "file":
                                        if err := os.MkdirAll(path.Join(initLayer, path.Dir(pth)), 0755); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">f, err := os.OpenFile(path.Join(initLayer, pth), os.O_CREATE, 0755)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">f.Close()</span>
                                }
                        } <span class="cov0" title="0">else {
                                return err
                        }</span>
                }
        }

        // Layer is ready to use, if it wasn't before.
        <span class="cov0" title="0">return nil</span>
}

// Check if given error is "not empty".
// Note: this is the way golang does it internally with os.IsNotExists.
func isNotEmpty(err error) bool <span class="cov0" title="0">{
        switch pe := err.(type) </span>{
        <span class="cov0" title="0">case nil:
                return false</span>
        <span class="cov0" title="0">case *os.PathError:
                err = pe.Err</span>
        <span class="cov0" title="0">case *os.LinkError:
                err = pe.Err</span>
        }
        <span class="cov0" title="0">return strings.Contains(err.Error(), " not empty")</span>
}

// Delete atomically removes an image from the graph.
func (graph *Graph) Delete(name string) error <span class="cov0" title="0">{
        id, err := graph.idIndex.Get(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tmp, err := graph.Mktemp("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">graph.idIndex.Delete(id)
        err = os.Rename(graph.imageRoot(id), tmp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Remove rootfs data from the driver
        <span class="cov0" title="0">graph.driver.Remove(id)
        // Remove the trashed image directory
        return os.RemoveAll(tmp)</span>
}

// Map returns a list of all images in the graph, addressable by ID.
func (graph *Graph) Map() (map[string]*Image, error) <span class="cov0" title="0">{
        images := make(map[string]*Image)
        err := graph.walkAll(func(image *Image) </span><span class="cov0" title="0">{
                images[image.ID] = image
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return images, nil</span>
}

// walkAll iterates over each image in the graph, and passes it to a handler.
// The walking order is undetermined.
func (graph *Graph) walkAll(handler func(*Image)) error <span class="cov0" title="0">{
        files, err := ioutil.ReadDir(graph.Root)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, st := range files </span><span class="cov0" title="0">{
                if img, err := graph.Get(st.Name()); err != nil </span><span class="cov0" title="0">{
                        // Skip image
                        continue</span>
                } <span class="cov0" title="0">else if handler != nil </span><span class="cov0" title="0">{
                        handler(img)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ByParent returns a lookup table of images by their parent.
// If an image of id ID has 3 children images, then the value for key ID
// will be a list of 3 images.
// If an image has no children, it will not have an entry in the table.
func (graph *Graph) ByParent() (map[string][]*Image, error) <span class="cov0" title="0">{
        byParent := make(map[string][]*Image)
        err := graph.walkAll(func(image *Image) </span><span class="cov0" title="0">{
                parent, err := graph.Get(image.Parent)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if children, exists := byParent[parent.ID]; exists </span><span class="cov0" title="0">{
                        byParent[parent.ID] = append(children, image)
                }</span> <span class="cov0" title="0">else {
                        byParent[parent.ID] = []*Image{image}
                }</span>
        })
        <span class="cov0" title="0">return byParent, err</span>
}

// Heads returns all heads in the graph, keyed by id.
// A head is an image which is not the parent of another image in the graph.
func (graph *Graph) Heads() (map[string]*Image, error) <span class="cov0" title="0">{
        heads := make(map[string]*Image)
        byParent, err := graph.ByParent()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = graph.walkAll(func(image *Image) </span><span class="cov0" title="0">{
                // If it's not in the byParent lookup table, then
                // it's not a parent -&gt; so it's a head!
                if _, exists := byParent[image.ID]; !exists </span><span class="cov0" title="0">{
                        heads[image.ID] = image
                }</span>
        })
        <span class="cov0" title="0">return heads, err</span>
}

func (graph *Graph) imageRoot(id string) string <span class="cov8" title="1">{
        return path.Join(graph.Root, id)
}</span>

func (graph *Graph) Driver() graphdriver.Driver <span class="cov0" title="0">{
        return graph.driver
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package docker

import (
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/graphdriver"
        "github.com/dotcloud/docker/utils"
        "io"
        "io/ioutil"
        "os"
        "path"
        "strconv"
        "strings"
        "time"
)

type Image struct {
        ID              string    `json:"id"`
        Parent          string    `json:"parent,omitempty"`
        Comment         string    `json:"comment,omitempty"`
        Created         time.Time `json:"created"`
        Container       string    `json:"container,omitempty"`
        ContainerConfig Config    `json:"container_config,omitempty"`
        DockerVersion   string    `json:"docker_version,omitempty"`
        Author          string    `json:"author,omitempty"`
        Config          *Config   `json:"config,omitempty"`
        Architecture    string    `json:"architecture,omitempty"`
        OS              string    `json:"os,omitempty"`
        graph           *Graph
        Size            int64
}

func LoadImage(root string) (*Image, error) <span class="cov8" title="1">{
        // Load the json data
        jsonData, err := ioutil.ReadFile(jsonPath(root))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">img := &amp;Image{}

        if err := json.Unmarshal(jsonData, img); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := ValidateID(img.ID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if buf, err := ioutil.ReadFile(path.Join(root, "layersize")); err != nil </span><span class="cov0" title="0">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // If the layersize file does not exist then set the size to a negative number
                // because a layer size of 0 (zero) is valid
                <span class="cov0" title="0">img.Size = -1</span>
        } <span class="cov8" title="1">else {
                size, err := strconv.Atoi(string(buf))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">img.Size = int64(size)</span>
        }

        <span class="cov8" title="1">return img, nil</span>
}

func StoreImage(img *Image, jsonData []byte, layerData archive.Archive, root, layer string) error <span class="cov8" title="1">{
        // Store the layer
        var (
                size   int64
                err    error
                driver = img.graph.driver
        )
        if err := os.MkdirAll(layer, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If layerData is not nil, unpack it into the new layer
        <span class="cov8" title="1">if layerData != nil </span><span class="cov8" title="1">{
                if differ, ok := driver.(graphdriver.Differ); ok </span><span class="cov8" title="1">{
                        if err := differ.ApplyDiff(img.ID, layerData); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if size, err = differ.DiffSize(img.ID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } <span class="cov0" title="0">else {
                        start := time.Now().UTC()
                        utils.Debugf("Start untar layer")
                        if err := archive.ApplyLayer(layer, layerData); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">utils.Debugf("Untar time: %vs", time.Now().UTC().Sub(start).Seconds())

                        if img.Parent == "" </span><span class="cov0" title="0">{
                                if size, err = utils.TreeSize(layer); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } <span class="cov0" title="0">else {
                                parent, err := driver.Get(img.Parent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">changes, err := archive.ChangesDirs(layer, parent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">size = archive.ChangesSize(layer, changes)</span>
                        }
                }
        }

        <span class="cov8" title="1">img.Size = size
        if err := img.SaveSize(root); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If raw json is provided, then use it
        <span class="cov8" title="1">if jsonData != nil </span><span class="cov0" title="0">{
                if err := ioutil.WriteFile(jsonPath(root), jsonData, 0600); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } <span class="cov8" title="1">else {
                if jsonData, err = json.Marshal(img); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := ioutil.WriteFile(jsonPath(root), jsonData, 0600); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SaveSize stores the current `size` value of `img` in the directory `root`.
func (img *Image) SaveSize(root string) error <span class="cov8" title="1">{
        if err := ioutil.WriteFile(path.Join(root, "layersize"), []byte(strconv.Itoa(int(img.Size))), 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error storing image size in %s/layersize: %s", root, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func jsonPath(root string) string <span class="cov8" title="1">{
        return path.Join(root, "json")
}</span>

// TarLayer returns a tar archive of the image's filesystem layer.
func (img *Image) TarLayer() (archive.Archive, error) <span class="cov0" title="0">{
        if img.graph == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Can't load storage driver for unregistered image %s", img.ID)
        }</span>
        <span class="cov0" title="0">driver := img.graph.driver
        if differ, ok := driver.(graphdriver.Differ); ok </span><span class="cov0" title="0">{
                return differ.Diff(img.ID)
        }</span>

        <span class="cov0" title="0">imgFs, err := driver.Get(img.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if img.Parent == "" </span><span class="cov0" title="0">{
                return archive.Tar(imgFs, archive.Uncompressed)
        }</span> <span class="cov0" title="0">else {
                parentFs, err := driver.Get(img.Parent)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">changes, err := archive.ChangesDirs(imgFs, parentFs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return archive.ExportChanges(imgFs, changes)</span>
        }
}

func ValidateID(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Image id can't be empty")
        }</span>
        <span class="cov8" title="1">if strings.Contains(id, ":") </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid character in image id: ':'")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func GenerateID() string <span class="cov8" title="1">{
        id := make([]byte, 32)
        _, err := io.ReadFull(rand.Reader, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err) // This shouldn't happen
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(id)</span>
}

// Image includes convenience proxy functions to its graph
// These functions will return an error if the image is not registered
// (ie. if image.graph == nil)
func (img *Image) History() ([]*Image, error) <span class="cov0" title="0">{
        var parents []*Image
        if err := img.WalkHistory(
                func(img *Image) error {
                        parents = append(parents, img)
                        return nil
                },
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return parents, nil</span>
}

func (img *Image) WalkHistory(handler func(*Image) error) (err error) <span class="cov0" title="0">{
        currentImg := img
        for currentImg != nil </span><span class="cov0" title="0">{
                if handler != nil </span><span class="cov0" title="0">{
                        if err := handler(currentImg); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">currentImg, err = currentImg.GetParent()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error while getting parent image: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (img *Image) GetParent() (*Image, error) <span class="cov0" title="0">{
        if img.Parent == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if img.graph == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Can't lookup parent of unregistered image")
        }</span>
        <span class="cov0" title="0">return img.graph.Get(img.Parent)</span>
}

func (img *Image) root() (string, error) <span class="cov0" title="0">{
        if img.graph == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Can't lookup root of unregistered image")
        }</span>
        <span class="cov0" title="0">return img.graph.imageRoot(img.ID), nil</span>
}

func (img *Image) getParentsSize(size int64) int64 <span class="cov0" title="0">{
        parentImage, err := img.GetParent()
        if err != nil || parentImage == nil </span><span class="cov0" title="0">{
                return size
        }</span>
        <span class="cov0" title="0">size += parentImage.Size
        return parentImage.getParentsSize(size)</span>
}

// Depth returns the number of parents for a
// current image
func (img *Image) Depth() (int, error) <span class="cov0" title="0">{
        var (
                count  = 0
                parent = img
                err    error
        )

        for parent != nil </span><span class="cov0" title="0">{
                count++
                parent, err = parent.GetParent()
                if err != nil </span><span class="cov0" title="0">{
                        return -1, err
                }</span>
        }
        <span class="cov0" title="0">return count, nil</span>
}

// Build an Image object from raw json data
func NewImgJSON(src []byte) (*Image, error) <span class="cov0" title="0">{
        ret := &amp;Image{}

        utils.Debugf("Json string: {%s}", src)
        // FIXME: Is there a cleaner way to "purify" the input json?
        if err := json.Unmarshal(src, ret); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package docker

import (
        "fmt"
        "github.com/dotcloud/docker/pkg/iptables"
        "path"
        "strings"
)

type Link struct {
        ParentIP         string
        ChildIP          string
        Name             string
        BridgeInterface  string
        ChildEnvironment []string
        Ports            []Port
        IsEnabled        bool
}

func NewLink(parent, child *Container, name, bridgeInterface string) (*Link, error) <span class="cov8" title="1">{
        if parent.ID == child.ID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Cannot link to self: %s == %s", parent.ID, child.ID)
        }</span>
        <span class="cov8" title="1">if !child.State.IsRunning() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Cannot link to a non running container: %s AS %s", child.Name, name)
        }</span>

        <span class="cov8" title="1">ports := make([]Port, len(child.Config.ExposedPorts))
        var i int
        for p := range child.Config.ExposedPorts </span><span class="cov8" title="1">{
                ports[i] = p
                i++
        }</span>

        <span class="cov8" title="1">l := &amp;Link{
                BridgeInterface:  bridgeInterface,
                Name:             name,
                ChildIP:          child.NetworkSettings.IPAddress,
                ParentIP:         parent.NetworkSettings.IPAddress,
                ChildEnvironment: child.Config.Env,
                Ports:            ports,
        }
        return l, nil</span>

}

func (l *Link) Alias() string <span class="cov8" title="1">{
        _, alias := path.Split(l.Name)
        return alias
}</span>

func (l *Link) ToEnv() []string <span class="cov8" title="1">{
        env := []string{}
        alias := strings.ToUpper(l.Alias())

        if p := l.getDefaultPort(); p != nil </span><span class="cov8" title="1">{
                env = append(env, fmt.Sprintf("%s_PORT=%s://%s:%s", alias, p.Proto(), l.ChildIP, p.Port()))
        }</span>

        // Load exposed ports into the environment
        <span class="cov8" title="1">for _, p := range l.Ports </span><span class="cov8" title="1">{
                env = append(env, fmt.Sprintf("%s_PORT_%s_%s=%s://%s:%s", alias, p.Port(), strings.ToUpper(p.Proto()), p.Proto(), l.ChildIP, p.Port()))
                env = append(env, fmt.Sprintf("%s_PORT_%s_%s_ADDR=%s", alias, p.Port(), strings.ToUpper(p.Proto()), l.ChildIP))
                env = append(env, fmt.Sprintf("%s_PORT_%s_%s_PORT=%s", alias, p.Port(), strings.ToUpper(p.Proto()), p.Port()))
                env = append(env, fmt.Sprintf("%s_PORT_%s_%s_PROTO=%s", alias, p.Port(), strings.ToUpper(p.Proto()), p.Proto()))
        }</span>

        // Load the linked container's name into the environment
        <span class="cov8" title="1">env = append(env, fmt.Sprintf("%s_NAME=%s", alias, l.Name))

        if l.ChildEnvironment != nil </span><span class="cov8" title="1">{
                for _, v := range l.ChildEnvironment </span><span class="cov8" title="1">{
                        parts := strings.Split(v, "=")
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Ignore a few variables that are added during docker build
                        <span class="cov8" title="1">if parts[0] == "HOME" || parts[0] == "PATH" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">env = append(env, fmt.Sprintf("%s_ENV_%s=%s", alias, parts[0], parts[1]))</span>
                }
        }
        <span class="cov8" title="1">return env</span>
}

// Default port rules
func (l *Link) getDefaultPort() *Port <span class="cov8" title="1">{
        var p Port
        i := len(l.Ports)

        if i == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> <span class="cov8" title="1">else if i &gt; 1 </span><span class="cov0" title="0">{
                sortPorts(l.Ports, func(ip, jp Port) bool </span><span class="cov0" title="0">{
                        // If the two ports have the same number, tcp takes priority
                        // Sort in desc order
                        return ip.Int() &lt; jp.Int() || (ip.Int() == jp.Int() &amp;&amp; strings.ToLower(ip.Proto()) == "tcp")
                }</span>)
        }
        <span class="cov8" title="1">p = l.Ports[0]
        return &amp;p</span>
}

func (l *Link) Enable() error <span class="cov0" title="0">{
        if err := l.toggle("-I", false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">l.IsEnabled = true
        return nil</span>
}

func (l *Link) Disable() <span class="cov0" title="0">{
        // We do not care about errors here because the link may not
        // exist in iptables
        l.toggle("-D", true)

        l.IsEnabled = false
}</span>

func (l *Link) toggle(action string, ignoreErrors bool) error <span class="cov0" title="0">{
        for _, p := range l.Ports </span><span class="cov0" title="0">{
                if output, err := iptables.Raw(action, "FORWARD",
                        "-i", l.BridgeInterface, "-o", l.BridgeInterface,
                        "-p", p.Proto(),
                        "-s", l.ParentIP,
                        "--dport", p.Port(),
                        "-d", l.ChildIP,
                        "-j", "ACCEPT"); !ignoreErrors &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> <span class="cov0" title="0">else if len(output) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error toggle iptables forward: %s", output)
                }</span>

                <span class="cov0" title="0">if output, err := iptables.Raw(action, "FORWARD",
                        "-i", l.BridgeInterface, "-o", l.BridgeInterface,
                        "-p", p.Proto(),
                        "-s", l.ChildIP,
                        "--sport", p.Port(),
                        "-d", l.ParentIP,
                        "-j", "ACCEPT"); !ignoreErrors &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> <span class="cov0" title="0">else if len(output) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error toggle iptables forward: %s", output)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package docker

import (
        "strings"
        "text/template"
)

const LxcTemplate = `
{{if .Config.NetworkDisabled}}
# network is disabled (-n=false)
lxc.network.type = empty
{{else}}
# network configuration
lxc.network.type = veth
lxc.network.link = {{.NetworkSettings.Bridge}}
lxc.network.name = eth0
{{end}}

# root filesystem
{{$ROOTFS := .RootfsPath}}
lxc.rootfs = {{$ROOTFS}}

# use a dedicated pts for the container (and limit the number of pseudo terminal
# available)
lxc.pts = 1024

# disable the main console
lxc.console = none

# no controlling tty at all
lxc.tty = 1

{{if (getHostConfig .).Privileged}}
lxc.cgroup.devices.allow = a 
{{else}}
# no implicit access to devices
lxc.cgroup.devices.deny = a

# /dev/null and zero
lxc.cgroup.devices.allow = c 1:3 rwm
lxc.cgroup.devices.allow = c 1:5 rwm

# consoles
lxc.cgroup.devices.allow = c 5:1 rwm
lxc.cgroup.devices.allow = c 5:0 rwm
lxc.cgroup.devices.allow = c 4:0 rwm
lxc.cgroup.devices.allow = c 4:1 rwm

# /dev/urandom,/dev/random
lxc.cgroup.devices.allow = c 1:9 rwm
lxc.cgroup.devices.allow = c 1:8 rwm

# /dev/pts/ - pts namespaces are "coming soon"
lxc.cgroup.devices.allow = c 136:* rwm
lxc.cgroup.devices.allow = c 5:2 rwm

# tuntap
lxc.cgroup.devices.allow = c 10:200 rwm

# fuse
#lxc.cgroup.devices.allow = c 10:229 rwm

# rtc
#lxc.cgroup.devices.allow = c 254:0 rwm
{{end}}

# standard mount point
# Use mnt.putold as per https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/986385
lxc.pivotdir = lxc_putold

# NOTICE: These mounts must be applied within the namespace

#  WARNING: procfs is a known attack vector and should probably be disabled
#           if your userspace allows it. eg. see http://blog.zx2c4.com/749
lxc.mount.entry = proc {{escapeFstabSpaces $ROOTFS}}/proc proc nosuid,nodev,noexec 0 0

# WARNING: sysfs is a known attack vector and should probably be disabled
# if your userspace allows it. eg. see http://bit.ly/T9CkqJ
lxc.mount.entry = sysfs {{escapeFstabSpaces $ROOTFS}}/sys sysfs nosuid,nodev,noexec 0 0

lxc.mount.entry = devpts {{escapeFstabSpaces $ROOTFS}}/dev/pts devpts newinstance,ptmxmode=0666,nosuid,noexec 0 0
lxc.mount.entry = shm {{escapeFstabSpaces $ROOTFS}}/dev/shm tmpfs size=65536k,nosuid,nodev,noexec 0 0

{{if (getHostConfig .).Privileged}}
{{if (getCapabilities .).AppArmor}}
lxc.aa_profile = unconfined
{{else}}
#lxc.aa_profile = unconfined
{{end}}
{{end}}

# limits
{{if .Config.Memory}}
lxc.cgroup.memory.limit_in_bytes = {{.Config.Memory}}
lxc.cgroup.memory.soft_limit_in_bytes = {{.Config.Memory}}
{{with $memSwap := getMemorySwap .Config}}
lxc.cgroup.memory.memsw.limit_in_bytes = {{$memSwap}}
{{end}}
{{end}}
{{if .Config.CpuShares}}
lxc.cgroup.cpu.shares = {{.Config.CpuShares}}
{{end}}

{{if (getHostConfig .).LxcConf}}
{{range $pair := (getHostConfig .).LxcConf}}
{{$pair.Key}} = {{$pair.Value}}
{{end}}
{{end}}
`

var LxcTemplateCompiled *template.Template

// Escape spaces in strings according to the fstab documentation, which is the
// format for "lxc.mount.entry" lines in lxc.conf. See also "man 5 fstab".
func escapeFstabSpaces(field string) string <span class="cov8" title="1">{
        return strings.Replace(field, " ", "\\040", -1)
}</span>

func getMemorySwap(config *Config) int64 <span class="cov8" title="1">{
        // By default, MemorySwap is set to twice the size of RAM.
        // If you want to omit MemorySwap, set it to `-1'.
        if config.MemorySwap &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return config.Memory * 2</span>
}

func getHostConfig(container *Container) *HostConfig <span class="cov8" title="1">{
        return container.hostConfig
}</span>

func getCapabilities(container *Container) *Capabilities <span class="cov0" title="0">{
        return container.runtime.capabilities
}</span>

func init() <span class="cov8" title="1">{
        var err error
        funcMap := template.FuncMap{
                "getMemorySwap":     getMemorySwap,
                "getHostConfig":     getHostConfig,
                "getCapabilities":   getCapabilities,
                "escapeFstabSpaces": escapeFstabSpaces,
        }
        LxcTemplateCompiled, err = template.New("lxc").Funcs(funcMap).Parse(LxcTemplate)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package docker

import (
        "encoding/binary"
        "errors"
        "fmt"
        "github.com/dotcloud/docker/pkg/iptables"
        "github.com/dotcloud/docker/pkg/netlink"
        "github.com/dotcloud/docker/proxy"
        "github.com/dotcloud/docker/utils"
        "log"
        "net"
        "strconv"
        "sync"
        "syscall"
        "unsafe"
)

const (
        DefaultNetworkBridge = "docker0"
        DisableNetworkBridge = "none"
        DefaultNetworkMtu    = 1500
        portRangeStart       = 49153
        portRangeEnd         = 65535
        siocBRADDBR          = 0x89a0
)

// Calculates the first and last IP addresses in an IPNet
func networkRange(network *net.IPNet) (net.IP, net.IP) <span class="cov8" title="1">{
        netIP := network.IP.To4()
        firstIP := netIP.Mask(network.Mask)
        lastIP := net.IPv4(0, 0, 0, 0).To4()
        for i := 0; i &lt; len(lastIP); i++ </span><span class="cov8" title="1">{
                lastIP[i] = netIP[i] | ^network.Mask[i]
        }</span>
        <span class="cov8" title="1">return firstIP, lastIP</span>
}

// Detects overlap between one IPNet and another
func networkOverlaps(netX *net.IPNet, netY *net.IPNet) bool <span class="cov8" title="1">{
        firstIP, _ := networkRange(netX)
        if netY.Contains(firstIP) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">firstIP, _ = networkRange(netY)
        if netX.Contains(firstIP) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Converts a 4 bytes IP into a 32 bit integer
func ipToInt(ip net.IP) int32 <span class="cov8" title="1">{
        return int32(binary.BigEndian.Uint32(ip.To4()))
}</span>

// Converts 32 bit integer into a 4 bytes IP address
func intToIP(n int32) net.IP <span class="cov8" title="1">{
        b := make([]byte, 4)
        binary.BigEndian.PutUint32(b, uint32(n))
        return net.IP(b)
}</span>

// Given a netmask, calculates the number of available hosts
func networkSize(mask net.IPMask) int32 <span class="cov8" title="1">{
        m := net.IPv4Mask(0, 0, 0, 0)
        for i := 0; i &lt; net.IPv4len; i++ </span><span class="cov8" title="1">{
                m[i] = ^mask[i]
        }</span>

        <span class="cov8" title="1">return int32(binary.BigEndian.Uint32(m)) + 1</span>
}

func checkRouteOverlaps(networks []*net.IPNet, dockerNetwork *net.IPNet) error <span class="cov8" title="1">{
        for _, network := range networks </span><span class="cov8" title="1">{
                if networkOverlaps(dockerNetwork, network) </span><span class="cov8" title="1">{
                        return fmt.Errorf("Network %s is already routed: '%s'", dockerNetwork, network)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func checkNameserverOverlaps(nameservers []string, dockerNetwork *net.IPNet) error <span class="cov8" title="1">{
        if len(nameservers) &gt; 0 </span><span class="cov8" title="1">{
                for _, ns := range nameservers </span><span class="cov8" title="1">{
                        _, nsNetwork, err := net.ParseCIDR(ns)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if networkOverlaps(dockerNetwork, nsNetwork) </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s overlaps nameserver %s", dockerNetwork, nsNetwork)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// CreateBridgeIface creates a network bridge interface on the host system with the name `ifaceName`,
// and attempts to configure it with an address which doesn't conflict with any other interface on the host.
// If it can't find an address which doesn't conflict, it will return an error.
func CreateBridgeIface(config *DaemonConfig) error <span class="cov0" title="0">{
        addrs := []string{
                // Here we don't follow the convention of using the 1st IP of the range for the gateway.
                // This is to use the same gateway IPs as the /24 ranges, which predate the /16 ranges.
                // In theory this shouldn't matter - in practice there's bound to be a few scripts relying
                // on the internal addressing or other stupid things like that.
                // The shouldn't, but hey, let's not break them unless we really have to.
                "172.17.42.1/16", // Don't use 172.16.0.0/16, it conflicts with EC2 DNS 172.16.0.23
                "10.0.42.1/16",   // Don't even try using the entire /8, that's too intrusive
                "10.1.42.1/16",
                "10.42.42.1/16",
                "172.16.42.1/24",
                "172.16.43.1/24",
                "172.16.44.1/24",
                "10.0.42.1/24",
                "10.0.43.1/24",
                "192.168.42.1/24",
                "192.168.43.1/24",
                "192.168.44.1/24",
        }

        nameservers := []string{}
        resolvConf, _ := utils.GetResolvConf()
        // we don't check for an error here, because we don't really care
        // if we can't read /etc/resolv.conf. So instead we skip the append
        // if resolvConf is nil. It either doesn't exist, or we can't read it
        // for some reason.
        if resolvConf != nil </span><span class="cov0" title="0">{
                nameservers = append(nameservers, utils.GetNameserversAsCIDR(resolvConf)...)
        }</span>

        <span class="cov0" title="0">var ifaceAddr string
        if len(config.BridgeIp) != 0 </span><span class="cov0" title="0">{
                _, _, err := net.ParseCIDR(config.BridgeIp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">ifaceAddr = config.BridgeIp</span>
        } <span class="cov0" title="0">else {
                for _, addr := range addrs </span><span class="cov0" title="0">{
                        _, dockerNetwork, err := net.ParseCIDR(addr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">routes, err := netlink.NetworkGetRoutes()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := checkRouteOverlaps(routes, dockerNetwork); err == nil </span><span class="cov0" title="0">{
                                if err := checkNameserverOverlaps(nameservers, dockerNetwork); err == nil </span><span class="cov0" title="0">{
                                        ifaceAddr = addr
                                        break</span>
                                }
                        } <span class="cov0" title="0">else {
                                utils.Debugf("%s: %s", addr, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ifaceAddr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Could not find a free IP address range for interface '%s'. Please configure its address manually and run 'docker -b %s'", config.BridgeIface, config.BridgeIface)
        }</span>
        <span class="cov0" title="0">utils.Debugf("Creating bridge %s with network %s", config.BridgeIface, ifaceAddr)

        if err := createBridgeIface(config.BridgeIface); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">iface, err := net.InterfaceByName(config.BridgeIface)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ipAddr, ipNet, err := net.ParseCIDR(ifaceAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if netlink.NetworkLinkAddIp(iface, ipAddr, ipNet); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to add private network: %s", err)
        }</span>
        <span class="cov0" title="0">if err := netlink.NetworkLinkUp(iface); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to start network bridge: %s", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Create the actual bridge device.  This is more backward-compatible than
// netlink.NetworkLinkAdd and works on RHEL 6.
func createBridgeIface(name string) error <span class="cov0" title="0">{
        s, err := syscall.Socket(syscall.AF_INET6, syscall.SOCK_STREAM, syscall.IPPROTO_IP)
        if err != nil </span><span class="cov0" title="0">{
                utils.Debugf("Bridge socket creation failed IPv6 probably not enabled: %v", err)
                s, err = syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_IP)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error creating bridge creation socket: %s", err)
                }</span>
        }
        <span class="cov0" title="0">defer syscall.Close(s)

        nameBytePtr, err := syscall.BytePtrFromString(name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error converting bridge name %s to byte array: %s", name, err)
        }</span>

        <span class="cov0" title="0">if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, uintptr(s), siocBRADDBR, uintptr(unsafe.Pointer(nameBytePtr))); err != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Error creating bridge: %s", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Return the IPv4 address of a network interface
func getIfaceAddr(name string) (net.Addr, error) <span class="cov0" title="0">{
        iface, err := net.InterfaceByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">addrs, err := iface.Addrs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var addrs4 []net.Addr
        for _, addr := range addrs </span><span class="cov0" title="0">{
                ip := (addr.(*net.IPNet)).IP
                if ip4 := ip.To4(); len(ip4) == net.IPv4len </span><span class="cov0" title="0">{
                        addrs4 = append(addrs4, addr)
                }</span>
        }
        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case len(addrs4) == 0:
                return nil, fmt.Errorf("Interface %v has no IP addresses", name)</span>
        <span class="cov0" title="0">case len(addrs4) &gt; 1:
                fmt.Printf("Interface %v has more than 1 IPv4 address. Defaulting to using %v\n",
                        name, (addrs4[0].(*net.IPNet)).IP)</span>
        }
        <span class="cov0" title="0">return addrs4[0], nil</span>
}

// Port mapper takes care of mapping external ports to containers by setting
// up iptables rules.
// It keeps track of all mappings and is able to unmap at will
type PortMapper struct {
        tcpMapping map[string]*net.TCPAddr
        tcpProxies map[string]proxy.Proxy
        udpMapping map[string]*net.UDPAddr
        udpProxies map[string]proxy.Proxy

        iptables         *iptables.Chain
        defaultIp        net.IP
        proxyFactoryFunc func(net.Addr, net.Addr) (proxy.Proxy, error)
}

func (mapper *PortMapper) Map(ip net.IP, port int, backendAddr net.Addr) error <span class="cov8" title="1">{

        if _, isTCP := backendAddr.(*net.TCPAddr); isTCP </span><span class="cov8" title="1">{
                mapKey := (&amp;net.TCPAddr{Port: port, IP: ip}).String()
                if _, exists := mapper.tcpProxies[mapKey]; exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("TCP Port %s is already in use", mapKey)
                }</span>
                <span class="cov8" title="1">backendPort := backendAddr.(*net.TCPAddr).Port
                backendIP := backendAddr.(*net.TCPAddr).IP
                if mapper.iptables != nil </span><span class="cov0" title="0">{
                        if err := mapper.iptables.Forward(iptables.Add, ip, port, "tcp", backendIP.String(), backendPort); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">mapper.tcpMapping[mapKey] = backendAddr.(*net.TCPAddr)
                proxy, err := mapper.proxyFactoryFunc(&amp;net.TCPAddr{IP: ip, Port: port}, backendAddr)
                if err != nil </span><span class="cov0" title="0">{
                        mapper.Unmap(ip, port, "tcp")
                        return err
                }</span>
                <span class="cov8" title="1">mapper.tcpProxies[mapKey] = proxy
                go proxy.Run()</span>
        } <span class="cov0" title="0">else {
                mapKey := (&amp;net.UDPAddr{Port: port, IP: ip}).String()
                if _, exists := mapper.udpProxies[mapKey]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("UDP: Port %s is already in use", mapKey)
                }</span>
                <span class="cov0" title="0">backendPort := backendAddr.(*net.UDPAddr).Port
                backendIP := backendAddr.(*net.UDPAddr).IP
                if mapper.iptables != nil </span><span class="cov0" title="0">{
                        if err := mapper.iptables.Forward(iptables.Add, ip, port, "udp", backendIP.String(), backendPort); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">mapper.udpMapping[mapKey] = backendAddr.(*net.UDPAddr)
                proxy, err := mapper.proxyFactoryFunc(&amp;net.UDPAddr{IP: ip, Port: port}, backendAddr)
                if err != nil </span><span class="cov0" title="0">{
                        mapper.Unmap(ip, port, "udp")
                        return err
                }</span>
                <span class="cov0" title="0">mapper.udpProxies[mapKey] = proxy
                go proxy.Run()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (mapper *PortMapper) Unmap(ip net.IP, port int, proto string) error <span class="cov8" title="1">{
        if proto == "tcp" </span><span class="cov8" title="1">{
                mapKey := (&amp;net.TCPAddr{Port: port, IP: ip}).String()
                backendAddr, ok := mapper.tcpMapping[mapKey]
                if !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("Port tcp/%s is not mapped", mapKey)
                }</span>
                <span class="cov8" title="1">if proxy, exists := mapper.tcpProxies[mapKey]; exists </span><span class="cov8" title="1">{
                        proxy.Close()
                        delete(mapper.tcpProxies, mapKey)
                }</span>
                <span class="cov8" title="1">if mapper.iptables != nil </span><span class="cov0" title="0">{
                        if err := mapper.iptables.Forward(iptables.Delete, ip, port, proto, backendAddr.IP.String(), backendAddr.Port); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">delete(mapper.tcpMapping, mapKey)</span>
        } <span class="cov0" title="0">else {
                mapKey := (&amp;net.UDPAddr{Port: port, IP: ip}).String()
                backendAddr, ok := mapper.udpMapping[mapKey]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("Port udp/%s is not mapped", mapKey)
                }</span>
                <span class="cov0" title="0">if proxy, exists := mapper.udpProxies[mapKey]; exists </span><span class="cov0" title="0">{
                        proxy.Close()
                        delete(mapper.udpProxies, mapKey)
                }</span>
                <span class="cov0" title="0">if mapper.iptables != nil </span><span class="cov0" title="0">{
                        if err := mapper.iptables.Forward(iptables.Delete, ip, port, proto, backendAddr.IP.String(), backendAddr.Port); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">delete(mapper.udpMapping, mapKey)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func newPortMapper(config *DaemonConfig) (*PortMapper, error) <span class="cov0" title="0">{
        // We can always try removing the iptables
        if err := iptables.RemoveExistingChain("DOCKER"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var chain *iptables.Chain
        if config.EnableIptables </span><span class="cov0" title="0">{
                var err error
                chain, err = iptables.NewChain("DOCKER", config.BridgeIface)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to create DOCKER chain: %s", err)
                }</span>
        }

        <span class="cov0" title="0">mapper := &amp;PortMapper{
                tcpMapping:       make(map[string]*net.TCPAddr),
                tcpProxies:       make(map[string]proxy.Proxy),
                udpMapping:       make(map[string]*net.UDPAddr),
                udpProxies:       make(map[string]proxy.Proxy),
                iptables:         chain,
                defaultIp:        config.DefaultIp,
                proxyFactoryFunc: proxy.NewProxy,
        }
        return mapper, nil</span>
}

// Port allocator: Automatically allocate and release networking ports
type PortAllocator struct {
        sync.Mutex
        inUse    map[string]struct{}
        fountain chan int
        quit     chan bool
}

func (alloc *PortAllocator) runFountain() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                for port := portRangeStart; port &lt; portRangeEnd; port++ </span><span class="cov8" title="1">{
                        select </span>{
                        <span class="cov8" title="1">case alloc.fountain &lt;- port:</span>
                        <span class="cov0" title="0">case quit := &lt;-alloc.quit:
                                if quit </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

// FIXME: Release can no longer fail, change its prototype to reflect that.
func (alloc *PortAllocator) Release(addr net.IP, port int) error <span class="cov8" title="1">{
        mapKey := (&amp;net.TCPAddr{Port: port, IP: addr}).String()
        utils.Debugf("Releasing %d", port)
        alloc.Lock()
        delete(alloc.inUse, mapKey)
        alloc.Unlock()
        return nil
}</span>

func (alloc *PortAllocator) Acquire(addr net.IP, port int) (int, error) <span class="cov8" title="1">{
        mapKey := (&amp;net.TCPAddr{Port: port, IP: addr}).String()
        utils.Debugf("Acquiring %s", mapKey)
        if port == 0 </span><span class="cov8" title="1">{
                // Allocate a port from the fountain
                for port := range alloc.fountain </span><span class="cov8" title="1">{
                        if _, err := alloc.Acquire(addr, port); err == nil </span><span class="cov8" title="1">{
                                return port, nil
                        }</span>
                }
                <span class="cov0" title="0">return -1, fmt.Errorf("Port generator ended unexpectedly")</span>
        }
        <span class="cov8" title="1">alloc.Lock()
        defer alloc.Unlock()
        if _, inUse := alloc.inUse[mapKey]; inUse </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("Port already in use: %d", port)
        }</span>
        <span class="cov8" title="1">alloc.inUse[mapKey] = struct{}{}
        return port, nil</span>
}

func (alloc *PortAllocator) Close() error <span class="cov0" title="0">{
        alloc.quit &lt;- true
        close(alloc.quit)
        close(alloc.fountain)
        return nil
}</span>

func newPortAllocator() (*PortAllocator, error) <span class="cov8" title="1">{
        allocator := &amp;PortAllocator{
                inUse:    make(map[string]struct{}),
                fountain: make(chan int),
                quit:     make(chan bool),
        }
        go allocator.runFountain()
        return allocator, nil
}</span>

// IP allocator: Automatically allocate and release networking ports
type IPAllocator struct {
        network       *net.IPNet
        queueAlloc    chan allocatedIP
        queueReleased chan net.IP
        inUse         map[int32]struct{}
        quit          chan bool
}

type allocatedIP struct {
        ip  net.IP
        err error
}

func (alloc *IPAllocator) run() <span class="cov8" title="1">{
        firstIP, _ := networkRange(alloc.network)
        ipNum := ipToInt(firstIP)
        ownIP := ipToInt(alloc.network.IP)
        size := networkSize(alloc.network.Mask)

        pos := int32(1)
        max := size - 2 // -1 for the broadcast address, -1 for the gateway address
        for </span><span class="cov8" title="1">{
                var (
                        newNum int32
                        inUse  bool
                )

                // Find first unused IP, give up after one whole round
                for attempt := int32(0); attempt &lt; max; attempt++ </span><span class="cov8" title="1">{
                        newNum = ipNum + pos

                        pos = pos%max + 1

                        // The network's IP is never okay to use
                        if newNum == ownIP </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if _, inUse = alloc.inUse[newNum]; !inUse </span><span class="cov8" title="1">{
                                // We found an unused IP
                                break</span>
                        }
                }

                <span class="cov8" title="1">ip := allocatedIP{ip: intToIP(newNum)}
                if inUse </span><span class="cov8" title="1">{
                        ip.err = errors.New("No unallocated IP available")
                }</span>

                <span class="cov8" title="1">select </span>{
                <span class="cov0" title="0">case quit := &lt;-alloc.quit:
                        if quit </span><span class="cov0" title="0">{
                                return
                        }</span>
                <span class="cov8" title="1">case alloc.queueAlloc &lt;- ip:
                        alloc.inUse[newNum] = struct{}{}</span>
                <span class="cov8" title="1">case released := &lt;-alloc.queueReleased:
                        r := ipToInt(released)
                        delete(alloc.inUse, r)

                        if inUse </span><span class="cov8" title="1">{
                                // If we couldn't allocate a new IP, the released one
                                // will be the only free one now, so instantly use it
                                // next time
                                pos = r - ipNum
                        }</span> <span class="cov8" title="1">else {
                                // Use same IP as last time
                                if pos == 1 </span><span class="cov0" title="0">{
                                        pos = max
                                }</span> <span class="cov8" title="1">else {
                                        pos--
                                }</span>
                        }
                }
        }
}

func (alloc *IPAllocator) Acquire() (net.IP, error) <span class="cov8" title="1">{
        ip := &lt;-alloc.queueAlloc
        return ip.ip, ip.err
}</span>

func (alloc *IPAllocator) Release(ip net.IP) <span class="cov8" title="1">{
        alloc.queueReleased &lt;- ip
}</span>

func (alloc *IPAllocator) Close() error <span class="cov0" title="0">{
        alloc.quit &lt;- true
        close(alloc.quit)
        close(alloc.queueAlloc)
        close(alloc.queueReleased)
        return nil
}</span>

func newIPAllocator(network *net.IPNet) *IPAllocator <span class="cov8" title="1">{
        alloc := &amp;IPAllocator{
                network:       network,
                queueAlloc:    make(chan allocatedIP),
                queueReleased: make(chan net.IP),
                inUse:         make(map[int32]struct{}),
                quit:          make(chan bool),
        }

        go alloc.run()

        return alloc
}</span>

// Network interface represents the networking stack of a container
type NetworkInterface struct {
        IPNet   net.IPNet
        Gateway net.IP

        manager  *NetworkManager
        extPorts []*Nat
        disabled bool
}

// Allocate an external port and map it to the interface
func (iface *NetworkInterface) AllocatePort(port Port, binding PortBinding) (*Nat, error) <span class="cov0" title="0">{

        if iface.disabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Trying to allocate port for interface %v, which is disabled", iface) // FIXME
        }</span>

        <span class="cov0" title="0">ip := iface.manager.portMapper.defaultIp

        if binding.HostIp != "" </span><span class="cov0" title="0">{
                ip = net.ParseIP(binding.HostIp)
        }</span> <span class="cov0" title="0">else {
                binding.HostIp = ip.String()
        }</span>

        <span class="cov0" title="0">nat := &amp;Nat{
                Port:    port,
                Binding: binding,
        }

        containerPort, err := parsePort(port.Port())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">hostPort, _ := parsePort(nat.Binding.HostPort)

        if nat.Port.Proto() == "tcp" </span><span class="cov0" title="0">{
                extPort, err := iface.manager.tcpPortAllocator.Acquire(ip, hostPort)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">backend := &amp;net.TCPAddr{IP: iface.IPNet.IP, Port: containerPort}
                if err := iface.manager.portMapper.Map(ip, extPort, backend); err != nil </span><span class="cov0" title="0">{
                        iface.manager.tcpPortAllocator.Release(ip, extPort)
                        return nil, err
                }</span>
                <span class="cov0" title="0">nat.Binding.HostPort = strconv.Itoa(extPort)</span>
        } <span class="cov0" title="0">else {
                extPort, err := iface.manager.udpPortAllocator.Acquire(ip, hostPort)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">backend := &amp;net.UDPAddr{IP: iface.IPNet.IP, Port: containerPort}
                if err := iface.manager.portMapper.Map(ip, extPort, backend); err != nil </span><span class="cov0" title="0">{
                        iface.manager.udpPortAllocator.Release(ip, extPort)
                        return nil, err
                }</span>
                <span class="cov0" title="0">nat.Binding.HostPort = strconv.Itoa(extPort)</span>
        }
        <span class="cov0" title="0">iface.extPorts = append(iface.extPorts, nat)

        return nat, nil</span>
}

type Nat struct {
        Port    Port
        Binding PortBinding
}

func (n *Nat) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s:%s/%s", n.Binding.HostIp, n.Binding.HostPort, n.Port.Port(), n.Port.Proto())
}</span>

// Release: Network cleanup - release all resources
func (iface *NetworkInterface) Release() <span class="cov0" title="0">{
        if iface.disabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, nat := range iface.extPorts </span><span class="cov0" title="0">{
                hostPort, err := parsePort(nat.Binding.HostPort)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Unable to get host port: %s", err)
                        continue</span>
                }
                <span class="cov0" title="0">ip := net.ParseIP(nat.Binding.HostIp)
                utils.Debugf("Unmaping %s/%s:%s", nat.Port.Proto, ip.String(), nat.Binding.HostPort)
                if err := iface.manager.portMapper.Unmap(ip, hostPort, nat.Port.Proto()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Unable to unmap port %s: %s", nat, err)
                }</span>

                <span class="cov0" title="0">if nat.Port.Proto() == "tcp" </span><span class="cov0" title="0">{
                        if err := iface.manager.tcpPortAllocator.Release(ip, hostPort); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Unable to release port %s", nat)
                        }</span>
                } <span class="cov0" title="0">else if nat.Port.Proto() == "udp" </span><span class="cov0" title="0">{
                        if err := iface.manager.udpPortAllocator.Release(ip, hostPort); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Unable to release port %s: %s", nat, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">iface.manager.ipAllocator.Release(iface.IPNet.IP)</span>
}

// Network Manager manages a set of network interfaces
// Only *one* manager per host machine should be used
type NetworkManager struct {
        bridgeIface   string
        bridgeNetwork *net.IPNet

        ipAllocator      *IPAllocator
        tcpPortAllocator *PortAllocator
        udpPortAllocator *PortAllocator
        portMapper       *PortMapper

        disabled bool
}

// Allocate a network interface
func (manager *NetworkManager) Allocate() (*NetworkInterface, error) <span class="cov0" title="0">{

        if manager.disabled </span><span class="cov0" title="0">{
                return &amp;NetworkInterface{disabled: true}, nil
        }</span>

        <span class="cov0" title="0">var ip net.IP
        var err error

        ip, err = manager.ipAllocator.Acquire()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // avoid duplicate IP
        <span class="cov0" title="0">ipNum := ipToInt(ip)
        firstIP := manager.ipAllocator.network.IP.To4().Mask(manager.ipAllocator.network.Mask)
        firstIPNum := ipToInt(firstIP) + 1

        if firstIPNum == ipNum </span><span class="cov0" title="0">{
                ip, err = manager.ipAllocator.Acquire()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">iface := &amp;NetworkInterface{
                IPNet:   net.IPNet{IP: ip, Mask: manager.bridgeNetwork.Mask},
                Gateway: manager.bridgeNetwork.IP,
                manager: manager,
        }
        return iface, nil</span>
}

func (manager *NetworkManager) Close() error <span class="cov0" title="0">{
        if manager.disabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err1 := manager.tcpPortAllocator.Close()
        err2 := manager.udpPortAllocator.Close()
        err3 := manager.ipAllocator.Close()
        if err1 != nil </span><span class="cov0" title="0">{
                return err1
        }</span>
        <span class="cov0" title="0">if err2 != nil </span><span class="cov0" title="0">{
                return err2
        }</span>
        <span class="cov0" title="0">return err3</span>
}

func newNetworkManager(config *DaemonConfig) (*NetworkManager, error) <span class="cov0" title="0">{
        if config.BridgeIface == DisableNetworkBridge </span><span class="cov0" title="0">{
                manager := &amp;NetworkManager{
                        disabled: true,
                }
                return manager, nil
        }</span>

        <span class="cov0" title="0">addr, err := getIfaceAddr(config.BridgeIface)
        if err != nil </span><span class="cov0" title="0">{
                // If the iface is not found, try to create it
                if err := CreateBridgeIface(config); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">addr, err = getIfaceAddr(config.BridgeIface)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">network := addr.(*net.IPNet)

        // Configure iptables for link support
        if config.EnableIptables </span><span class="cov0" title="0">{

                // Enable NAT
                natArgs := []string{"POSTROUTING", "-t", "nat", "-s", addr.String(), "!", "-d", addr.String(), "-j", "MASQUERADE"}

                if !iptables.Exists(natArgs...) </span><span class="cov0" title="0">{
                        if output, err := iptables.Raw(append([]string{"-A"}, natArgs...)...); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Unable to enable network bridge NAT: %s", err)
                        }</span> <span class="cov0" title="0">else if len(output) != 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error iptables postrouting: %s", output)
                        }</span>
                }

                // Accept incoming packets for existing connections
                <span class="cov0" title="0">existingArgs := []string{"FORWARD", "-o", config.BridgeIface, "-m", "conntrack", "--ctstate", "RELATED,ESTABLISHED", "-j", "ACCEPT"}

                if !iptables.Exists(existingArgs...) </span><span class="cov0" title="0">{
                        if output, err := iptables.Raw(append([]string{"-I"}, existingArgs...)...); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Unable to allow incoming packets: %s", err)
                        }</span> <span class="cov0" title="0">else if len(output) != 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error iptables allow incoming: %s", output)
                        }</span>
                }

                // Accept all non-intercontainer outgoing packets
                <span class="cov0" title="0">outgoingArgs := []string{"FORWARD", "-i", config.BridgeIface, "!", "-o", config.BridgeIface, "-j", "ACCEPT"}

                if !iptables.Exists(outgoingArgs...) </span><span class="cov0" title="0">{
                        if output, err := iptables.Raw(append([]string{"-I"}, outgoingArgs...)...); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Unable to allow outgoing packets: %s", err)
                        }</span> <span class="cov0" title="0">else if len(output) != 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error iptables allow outgoing: %s", output)
                        }</span>
                }

                <span class="cov0" title="0">args := []string{"FORWARD", "-i", config.BridgeIface, "-o", config.BridgeIface, "-j"}
                acceptArgs := append(args, "ACCEPT")
                dropArgs := append(args, "DROP")

                if !config.InterContainerCommunication </span><span class="cov0" title="0">{
                        iptables.Raw(append([]string{"-D"}, acceptArgs...)...)
                        if !iptables.Exists(dropArgs...) </span><span class="cov0" title="0">{
                                utils.Debugf("Disable inter-container communication")
                                if output, err := iptables.Raw(append([]string{"-I"}, dropArgs...)...); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("Unable to prevent intercontainer communication: %s", err)
                                }</span> <span class="cov0" title="0">else if len(output) != 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("Error disabling intercontainer communication: %s", output)
                                }</span>
                        }
                } <span class="cov0" title="0">else {
                        iptables.Raw(append([]string{"-D"}, dropArgs...)...)
                        if !iptables.Exists(acceptArgs...) </span><span class="cov0" title="0">{
                                utils.Debugf("Enable inter-container communication")
                                if output, err := iptables.Raw(append([]string{"-I"}, acceptArgs...)...); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("Unable to allow intercontainer communication: %s", err)
                                }</span> <span class="cov0" title="0">else if len(output) != 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("Error enabling intercontainer communication: %s", output)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">ipAllocator := newIPAllocator(network)

        tcpPortAllocator, err := newPortAllocator()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">udpPortAllocator, err := newPortAllocator()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">portMapper, err := newPortMapper(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">manager := &amp;NetworkManager{
                bridgeIface:      config.BridgeIface,
                bridgeNetwork:    network,
                ipAllocator:      ipAllocator,
                tcpPortAllocator: tcpPortAllocator,
                udpPortAllocator: udpPortAllocator,
                portMapper:       portMapper,
        }

        return manager, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package docker

import (
        "fmt"
        "github.com/dotcloud/docker/utils"
        "os"
        "path/filepath"
        "regexp"
        "strings"
)

// ListOpts type
type ListOpts struct {
        values    []string
        validator ValidatorFctType
}

func NewListOpts(validator ValidatorFctType) ListOpts <span class="cov8" title="1">{
        return ListOpts{
                validator: validator,
        }
}</span>

func (opts *ListOpts) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v", []string(opts.values))
}</span>

// Set validates if needed the input value and add it to the
// internal slice.
func (opts *ListOpts) Set(value string) error <span class="cov8" title="1">{
        if opts.validator != nil </span><span class="cov8" title="1">{
                v, err := opts.validator(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">value = v</span>
        }
        <span class="cov8" title="1">opts.values = append(opts.values, value)
        return nil</span>
}

// Delete remove the given element from the slice.
func (opts *ListOpts) Delete(key string) <span class="cov8" title="1">{
        for i, k := range opts.values </span><span class="cov8" title="1">{
                if k == key </span><span class="cov8" title="1">{
                        opts.values = append(opts.values[:i], opts.values[i+1:]...)
                        return
                }</span>
        }
}

// GetMap returns the content of values in a map in order to avoid
// duplicates.
// FIXME: can we remove this?
func (opts *ListOpts) GetMap() map[string]struct{} <span class="cov8" title="1">{
        ret := make(map[string]struct{})
        for _, k := range opts.values </span><span class="cov8" title="1">{
                ret[k] = struct{}{}
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// GetAll returns the values' slice.
// FIXME: Can we remove this?
func (opts *ListOpts) GetAll() []string <span class="cov8" title="1">{
        return opts.values
}</span>

// Get checks the existence of the given key.
func (opts *ListOpts) Get(key string) bool <span class="cov8" title="1">{
        for _, k := range opts.values </span><span class="cov8" title="1">{
                if k == key </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Len returns the amount of element in the slice.
func (opts *ListOpts) Len() int <span class="cov8" title="1">{
        return len(opts.values)
}</span>

// Validators
type ValidatorFctType func(val string) (string, error)

func ValidateAttach(val string) (string, error) <span class="cov8" title="1">{
        if val != "stdin" &amp;&amp; val != "stdout" &amp;&amp; val != "stderr" </span><span class="cov8" title="1">{
                return val, fmt.Errorf("Unsupported stream name: %s", val)
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

func ValidateLink(val string) (string, error) <span class="cov8" title="1">{
        if _, err := parseLink(val); err != nil </span><span class="cov8" title="1">{
                return val, err
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

func ValidatePath(val string) (string, error) <span class="cov8" title="1">{
        var containerPath string

        if strings.Count(val, ":") &gt; 2 </span><span class="cov8" title="1">{
                return val, fmt.Errorf("bad format for volumes: %s", val)
        }</span>

        <span class="cov8" title="1">splited := strings.SplitN(val, ":", 2)
        if len(splited) == 1 </span><span class="cov8" title="1">{
                containerPath = splited[0]
                val = filepath.Clean(splited[0])
        }</span> <span class="cov8" title="1">else {
                containerPath = splited[1]
                val = fmt.Sprintf("%s:%s", splited[0], filepath.Clean(splited[1]))
        }</span>

        <span class="cov8" title="1">if !filepath.IsAbs(containerPath) </span><span class="cov8" title="1">{
                return val, fmt.Errorf("%s is not an absolute path", containerPath)
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

func ValidateEnv(val string) (string, error) <span class="cov0" title="0">{
        arr := strings.Split(val, "=")
        if len(arr) &gt; 1 </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s=%s", val, os.Getenv(val)), nil</span>
}

func ValidateHost(val string) (string, error) <span class="cov0" title="0">{
        host, err := utils.ParseHost(DEFAULTHTTPHOST, DEFAULTHTTPPORT, DEFAULTUNIXSOCKET, val)
        if err != nil </span><span class="cov0" title="0">{
                return val, err
        }</span>
        <span class="cov0" title="0">return host, nil</span>
}

func ValidateIp4Address(val string) (string, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(`^(([0-9]+\.){3}([0-9]+))\s*$`)
        var ns = re.FindSubmatch([]byte(val))
        if len(ns) &gt; 0 </span><span class="cov8" title="1">{
                return string(ns[1]), nil
        }</span>
        <span class="cov8" title="1">return "", fmt.Errorf("%s is not an ip4 address", val)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package docker

import (
        "container/list"
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/cgroups"
        "github.com/dotcloud/docker/graphdriver"
        "github.com/dotcloud/docker/graphdriver/aufs"
        _ "github.com/dotcloud/docker/graphdriver/devmapper"
        _ "github.com/dotcloud/docker/graphdriver/vfs"
        "github.com/dotcloud/docker/pkg/graphdb"
        "github.com/dotcloud/docker/utils"
        "io"
        "io/ioutil"
        "log"
        "os"
        "os/exec"
        "path"
        "regexp"
        "sort"
        "strings"
        "sync"
        "time"
)

// Set the max depth to the aufs default that most
// kernels are compiled with
// For more information see: http://sourceforge.net/p/aufs/aufs3-standalone/ci/aufs3.12/tree/config.mk
const MaxImageDepth = 127

var (
        defaultDns                = []string{"8.8.8.8", "8.8.4.4"}
        validContainerNameChars   = `[a-zA-Z0-9_.-]`
        validContainerNamePattern = regexp.MustCompile(`^/?` + validContainerNameChars + `+$`)
)

type Capabilities struct {
        MemoryLimit            bool
        SwapLimit              bool
        IPv4ForwardingDisabled bool
        AppArmor               bool
}

type Runtime struct {
        repository     string
        sysInitPath    string
        containers     *list.List
        networkManager *NetworkManager
        graph          *Graph
        repositories   *TagStore
        idIndex        *utils.TruncIndex
        capabilities   *Capabilities
        volumes        *Graph
        srv            *Server
        config         *DaemonConfig
        containerGraph *graphdb.Database
        driver         graphdriver.Driver
}

// List returns an array of all containers registered in the runtime.
func (runtime *Runtime) List() []*Container <span class="cov0" title="0">{
        containers := new(History)
        for e := runtime.containers.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                containers.Add(e.Value.(*Container))
        }</span>
        <span class="cov0" title="0">return *containers</span>
}

func (runtime *Runtime) getContainerElement(id string) *list.Element <span class="cov0" title="0">{
        for e := runtime.containers.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                container := e.Value.(*Container)
                if container.ID == id </span><span class="cov0" title="0">{
                        return e
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Get looks for a container by the specified ID or name, and returns it.
// If the container is not found, or if an error occurs, nil is returned.
func (runtime *Runtime) Get(name string) *Container <span class="cov0" title="0">{
        if c, _ := runtime.GetByName(name); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>

        <span class="cov0" title="0">id, err := runtime.idIndex.Get(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">e := runtime.getContainerElement(id)
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return e.Value.(*Container)</span>
}

// Exists returns a true if a container of the specified ID or name exists,
// false otherwise.
func (runtime *Runtime) Exists(id string) bool <span class="cov0" title="0">{
        return runtime.Get(id) != nil
}</span>

func (runtime *Runtime) containerRoot(id string) string <span class="cov0" title="0">{
        return path.Join(runtime.repository, id)
}</span>

// Load reads the contents of a container from disk
// This is typically done at startup.
func (runtime *Runtime) load(id string) (*Container, error) <span class="cov0" title="0">{
        container := &amp;Container{root: runtime.containerRoot(id)}
        if err := container.FromDisk(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if container.ID != id </span><span class="cov0" title="0">{
                return container, fmt.Errorf("Container %s is stored at %s", container.ID, id)
        }</span>
        <span class="cov0" title="0">if container.State.IsRunning() </span><span class="cov0" title="0">{
                container.State.SetGhost(true)
        }</span>
        <span class="cov0" title="0">return container, nil</span>
}

// Register makes a container object usable by the runtime as &lt;container.ID&gt;
func (runtime *Runtime) Register(container *Container) error <span class="cov0" title="0">{
        if container.runtime != nil || runtime.Exists(container.ID) </span><span class="cov0" title="0">{
                return fmt.Errorf("Container is already loaded")
        }</span>
        <span class="cov0" title="0">if err := validateID(container.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := runtime.ensureName(container); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the root filesystem from the driver
        <span class="cov0" title="0">rootfs, err := runtime.driver.Get(container.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting container filesystem %s from driver %s: %s", container.ID, runtime.driver, err)
        }</span>
        <span class="cov0" title="0">container.rootfs = rootfs

        container.runtime = runtime

        // Attach to stdout and stderr
        container.stderr = utils.NewWriteBroadcaster()
        container.stdout = utils.NewWriteBroadcaster()
        // Attach to stdin
        if container.Config.OpenStdin </span><span class="cov0" title="0">{
                container.stdin, container.stdinPipe = io.Pipe()
        }</span> <span class="cov0" title="0">else {
                container.stdinPipe = utils.NopWriteCloser(ioutil.Discard) // Silently drop stdin
        }</span>
        // done
        <span class="cov0" title="0">runtime.containers.PushBack(container)
        runtime.idIndex.Add(container.ID)

        // FIXME: if the container is supposed to be running but is not, auto restart it?
        //        if so, then we need to restart monitor and init a new lock
        // If the container is supposed to be running, make sure of it
        if container.State.IsRunning() </span><span class="cov0" title="0">{
                output, err := exec.Command("lxc-info", "-n", container.ID).CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !strings.Contains(string(output), "RUNNING") </span><span class="cov0" title="0">{
                        utils.Debugf("Container %s was supposed to be running but is not.", container.ID)
                        if runtime.config.AutoRestart </span><span class="cov0" title="0">{
                                utils.Debugf("Restarting")
                                container.State.SetGhost(false)
                                container.State.SetStopped(0)
                                if err := container.Start(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } <span class="cov0" title="0">else {
                                utils.Debugf("Marking as stopped")
                                container.State.SetStopped(-127)
                                if err := container.ToDisk(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } <span class="cov0" title="0">else {
                        utils.Debugf("Reconnecting to container %v", container.ID)

                        if err := container.allocateNetwork(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">container.waitLock = make(chan struct{})
                        go container.monitor()</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (runtime *Runtime) ensureName(container *Container) error <span class="cov0" title="0">{
        if container.Name == "" </span><span class="cov0" title="0">{
                name, err := generateRandomName(runtime)
                if err != nil </span><span class="cov0" title="0">{
                        name = utils.TruncateID(container.ID)
                }</span>
                <span class="cov0" title="0">container.Name = name

                if err := container.ToDisk(); err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error saving container name %s", err)
                }</span>
                <span class="cov0" title="0">if !runtime.containerGraph.Exists(name) </span><span class="cov0" title="0">{
                        if _, err := runtime.containerGraph.Set(name, container.ID); err != nil </span><span class="cov0" title="0">{
                                utils.Debugf("Setting default id - %s", err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (runtime *Runtime) LogToDisk(src *utils.WriteBroadcaster, dst, stream string) error <span class="cov0" title="0">{
        log, err := os.OpenFile(dst, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">src.AddWriter(log, stream)
        return nil</span>
}

// Destroy unregisters a container from the runtime and cleanly removes its contents from the filesystem.
func (runtime *Runtime) Destroy(container *Container) error <span class="cov0" title="0">{
        if container == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("The given container is &lt;nil&gt;")
        }</span>

        <span class="cov0" title="0">element := runtime.getContainerElement(container.ID)
        if element == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Container %v not found - maybe it was already destroyed?", container.ID)
        }</span>

        <span class="cov0" title="0">if err := container.Stop(3); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := runtime.driver.Remove(container.ID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Driver %s failed to remove root filesystem %s: %s", runtime.driver, container.ID, err)
        }</span>

        <span class="cov0" title="0">initID := fmt.Sprintf("%s-init", container.ID)
        if err := runtime.driver.Remove(initID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Driver %s failed to remove init filesystem %s: %s", runtime.driver, initID, err)
        }</span>

        <span class="cov0" title="0">if _, err := runtime.containerGraph.Purge(container.ID); err != nil </span><span class="cov0" title="0">{
                utils.Debugf("Unable to remove container from link graph: %s", err)
        }</span>

        // Deregister the container before removing its directory, to avoid race conditions
        <span class="cov0" title="0">runtime.idIndex.Delete(container.ID)
        runtime.containers.Remove(element)
        if err := os.RemoveAll(container.root); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to remove filesystem for %v: %v", container.ID, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (runtime *Runtime) restore() error <span class="cov0" title="0">{
        if os.Getenv("DEBUG") == "" &amp;&amp; os.Getenv("TEST") == "" </span><span class="cov0" title="0">{
                fmt.Printf("Loading containers: ")
        }</span>
        <span class="cov0" title="0">dir, err := ioutil.ReadDir(runtime.repository)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">containers := make(map[string]*Container)
        currentDriver := runtime.driver.String()

        for _, v := range dir </span><span class="cov0" title="0">{
                id := v.Name()
                container, err := runtime.load(id)
                if os.Getenv("DEBUG") == "" &amp;&amp; os.Getenv("TEST") == "" </span><span class="cov0" title="0">{
                        fmt.Print(".")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Failed to load container %v: %v", id, err)
                        continue</span>
                }

                // Ignore the container if it does not support the current driver being used by the graph
                <span class="cov0" title="0">if container.Driver == "" &amp;&amp; currentDriver == "aufs" || container.Driver == currentDriver </span><span class="cov0" title="0">{
                        utils.Debugf("Loaded container %v", container.ID)
                        containers[container.ID] = container
                }</span> <span class="cov0" title="0">else {
                        utils.Debugf("Cannot load container %s because it was created with another graph driver.", container.ID)
                }</span>
        }

        <span class="cov0" title="0">register := func(container *Container) </span><span class="cov0" title="0">{
                if err := runtime.Register(container); err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Failed to register container %s: %s", container.ID, err)
                }</span>
        }

        <span class="cov0" title="0">if entities := runtime.containerGraph.List("/", -1); entities != nil </span><span class="cov0" title="0">{
                for _, p := range entities.Paths() </span><span class="cov0" title="0">{
                        if os.Getenv("DEBUG") == "" &amp;&amp; os.Getenv("TEST") == "" </span><span class="cov0" title="0">{
                                fmt.Print(".")
                        }</span>
                        <span class="cov0" title="0">e := entities[p]
                        if container, ok := containers[e.ID()]; ok </span><span class="cov0" title="0">{
                                register(container)
                                delete(containers, e.ID())
                        }</span>
                }
        }

        // Any containers that are left over do not exist in the graph
        <span class="cov0" title="0">for _, container := range containers </span><span class="cov0" title="0">{
                // Try to set the default name for a container if it exists prior to links
                container.Name, err = generateRandomName(runtime)
                if err != nil </span><span class="cov0" title="0">{
                        container.Name = utils.TruncateID(container.ID)
                }</span>

                <span class="cov0" title="0">if _, err := runtime.containerGraph.Set(container.Name, container.ID); err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Setting default id - %s", err)
                }</span>
                <span class="cov0" title="0">register(container)</span>
        }

        <span class="cov0" title="0">if os.Getenv("DEBUG") == "" &amp;&amp; os.Getenv("TEST") == "" </span><span class="cov0" title="0">{
                fmt.Printf(": done.\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FIXME: comment please!
func (runtime *Runtime) UpdateCapabilities(quiet bool) <span class="cov0" title="0">{
        if cgroupMemoryMountpoint, err := cgroups.FindCgroupMountpoint("memory"); err != nil </span><span class="cov0" title="0">{
                if !quiet </span><span class="cov0" title="0">{
                        log.Printf("WARNING: %s\n", err)
                }</span>
        } <span class="cov0" title="0">else {
                _, err1 := ioutil.ReadFile(path.Join(cgroupMemoryMountpoint, "memory.limit_in_bytes"))
                _, err2 := ioutil.ReadFile(path.Join(cgroupMemoryMountpoint, "memory.soft_limit_in_bytes"))
                runtime.capabilities.MemoryLimit = err1 == nil &amp;&amp; err2 == nil
                if !runtime.capabilities.MemoryLimit &amp;&amp; !quiet </span><span class="cov0" title="0">{
                        log.Printf("WARNING: Your kernel does not support cgroup memory limit.")
                }</span>

                <span class="cov0" title="0">_, err = ioutil.ReadFile(path.Join(cgroupMemoryMountpoint, "memory.memsw.limit_in_bytes"))
                runtime.capabilities.SwapLimit = err == nil
                if !runtime.capabilities.SwapLimit &amp;&amp; !quiet </span><span class="cov0" title="0">{
                        log.Printf("WARNING: Your kernel does not support cgroup swap limit.")
                }</span>
        }

        <span class="cov0" title="0">content, err3 := ioutil.ReadFile("/proc/sys/net/ipv4/ip_forward")
        runtime.capabilities.IPv4ForwardingDisabled = err3 != nil || len(content) == 0 || content[0] != '1'
        if runtime.capabilities.IPv4ForwardingDisabled &amp;&amp; !quiet </span><span class="cov0" title="0">{
                log.Printf("WARNING: IPv4 forwarding is disabled.")
        }</span>

        // Check if AppArmor seems to be enabled on this system.
        <span class="cov0" title="0">if _, err := os.Stat("/sys/kernel/security/apparmor"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                utils.Debugf("/sys/kernel/security/apparmor not found; assuming AppArmor is not enabled.")
                runtime.capabilities.AppArmor = false
        }</span> <span class="cov0" title="0">else {
                utils.Debugf("/sys/kernel/security/apparmor found; assuming AppArmor is enabled.")
                runtime.capabilities.AppArmor = true
        }</span>
}

// Create creates a new container from the given configuration with a given name.
func (runtime *Runtime) Create(config *Config, name string) (*Container, []string, error) <span class="cov0" title="0">{
        // Lookup image
        img, err := runtime.repositories.LookupImage(config.Image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // We add 2 layers to the depth because the container's rw and
        // init layer add to the restriction
        <span class="cov0" title="0">depth, err := img.Depth()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">if depth+2 &gt;= MaxImageDepth </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Cannot create container with more than %d parents", MaxImageDepth)
        }</span>

        <span class="cov0" title="0">checkDeprecatedExpose := func(config *Config) bool </span><span class="cov0" title="0">{
                if config != nil </span><span class="cov0" title="0">{
                        if config.PortSpecs != nil </span><span class="cov0" title="0">{
                                for _, p := range config.PortSpecs </span><span class="cov0" title="0">{
                                        if strings.Contains(p, ":") </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov0" title="0">warnings := []string{}
        if checkDeprecatedExpose(img.Config) || checkDeprecatedExpose(config) </span><span class="cov0" title="0">{
                warnings = append(warnings, "The mapping to public ports on your host has been deprecated. Use -p to publish the ports.")
        }</span>

        <span class="cov0" title="0">if img.Config != nil </span><span class="cov0" title="0">{
                if err := MergeConfig(config, img.Config); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov0" title="0">if len(config.Entrypoint) != 0 &amp;&amp; config.Cmd == nil </span><span class="cov0" title="0">{
                config.Cmd = []string{}
        }</span> <span class="cov0" title="0">else if config.Cmd == nil || len(config.Cmd) == 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("No command specified")
        }</span>

        // Generate id
        <span class="cov0" title="0">id := GenerateID()

        if name == "" </span><span class="cov0" title="0">{
                name, err = generateRandomName(runtime)
                if err != nil </span><span class="cov0" title="0">{
                        name = utils.TruncateID(id)
                }</span>
        } <span class="cov0" title="0">else {
                if !validContainerNamePattern.MatchString(name) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("Invalid container name (%s), only %s are allowed", name, validContainerNameChars)
                }</span>
        }

        <span class="cov0" title="0">if name[0] != '/' </span><span class="cov0" title="0">{
                name = "/" + name
        }</span>

        // Set the enitity in the graph using the default name specified
        <span class="cov0" title="0">if _, err := runtime.containerGraph.Set(name, id); err != nil </span><span class="cov0" title="0">{
                if !strings.HasSuffix(err.Error(), "name are not unique") </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">conflictingContainer, err := runtime.GetByName(name)
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "Could not find entity") </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>

                        // Remove name and continue starting the container
                        <span class="cov0" title="0">if err := runtime.containerGraph.Delete(name); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                } <span class="cov0" title="0">else {
                        nameAsKnownByUser := strings.TrimPrefix(name, "/")
                        return nil, nil, fmt.Errorf(
                                "Conflict, The name %s is already assigned to %s. You have to delete (or rename) that container to be able to assign %s to a container again.", nameAsKnownByUser,
                                utils.TruncateID(conflictingContainer.ID), nameAsKnownByUser)
                }</span>
        }

        // Generate default hostname
        // FIXME: the lxc template no longer needs to set a default hostname
        <span class="cov0" title="0">if config.Hostname == "" </span><span class="cov0" title="0">{
                config.Hostname = id[:12]
        }</span>

        <span class="cov0" title="0">var args []string
        var entrypoint string

        if len(config.Entrypoint) != 0 </span><span class="cov0" title="0">{
                entrypoint = config.Entrypoint[0]
                args = append(config.Entrypoint[1:], config.Cmd...)
        }</span> <span class="cov0" title="0">else {
                entrypoint = config.Cmd[0]
                args = config.Cmd[1:]
        }</span>

        <span class="cov0" title="0">container := &amp;Container{
                // FIXME: we should generate the ID here instead of receiving it as an argument
                ID:              id,
                Created:         time.Now().UTC(),
                Path:            entrypoint,
                Args:            args, //FIXME: de-duplicate from config
                Config:          config,
                hostConfig:      &amp;HostConfig{},
                Image:           img.ID, // Always use the resolved image id
                NetworkSettings: &amp;NetworkSettings{},
                Name:            name,
                Driver:          runtime.driver.String(),
        }
        container.root = runtime.containerRoot(container.ID)
        // Step 1: create the container directory.
        // This doubles as a barrier to avoid race conditions.
        if err := os.Mkdir(container.root, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">initID := fmt.Sprintf("%s-init", container.ID)
        if err := runtime.driver.Create(initID, img.ID); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">initPath, err := runtime.driver.Get(initID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if err := setupInitLayer(initPath); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">if err := runtime.driver.Create(container.ID, initID); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">resolvConf, err := utils.GetResolvConf()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">if len(config.Dns) == 0 &amp;&amp; len(runtime.config.Dns) == 0 &amp;&amp; utils.CheckLocalDns(resolvConf) </span><span class="cov0" title="0">{
                //"WARNING: Docker detected local DNS server on resolv.conf. Using default external servers: %v", defaultDns
                runtime.config.Dns = defaultDns
        }</span>

        // If custom dns exists, then create a resolv.conf for the container
        <span class="cov0" title="0">if len(config.Dns) &gt; 0 || len(runtime.config.Dns) &gt; 0 </span><span class="cov0" title="0">{
                var dns []string
                if len(config.Dns) &gt; 0 </span><span class="cov0" title="0">{
                        dns = config.Dns
                }</span> <span class="cov0" title="0">else {
                        dns = runtime.config.Dns
                }</span>
                <span class="cov0" title="0">container.ResolvConfPath = path.Join(container.root, "resolv.conf")
                f, err := os.Create(container.ResolvConfPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">defer f.Close()
                for _, dns := range dns </span><span class="cov0" title="0">{
                        if _, err := f.Write([]byte("nameserver " + dns + "\n")); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                }
        } <span class="cov0" title="0">else {
                container.ResolvConfPath = "/etc/resolv.conf"
        }</span>

        // Step 2: save the container json
        <span class="cov0" title="0">if err := container.ToDisk(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Step 3: register the container
        <span class="cov0" title="0">if err := runtime.Register(container); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return container, warnings, nil</span>
}

// Commit creates a new filesystem image from the current state of a container.
// The image can optionally be tagged into a repository
func (runtime *Runtime) Commit(container *Container, repository, tag, comment, author string, config *Config) (*Image, error) <span class="cov0" title="0">{
        // FIXME: freeze the container before copying it to avoid data corruption?
        // FIXME: this shouldn't be in commands.
        if err := container.EnsureMounted(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rwTar, err := container.ExportRw()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Create a new image from the container's base layers + a new layer from container changes
        <span class="cov0" title="0">img, err := runtime.graph.Create(rwTar, container, comment, author, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Register the image if needed
        <span class="cov0" title="0">if repository != "" </span><span class="cov0" title="0">{
                if err := runtime.repositories.Set(repository, tag, img.ID, true); err != nil </span><span class="cov0" title="0">{
                        return img, err
                }</span>
        }
        <span class="cov0" title="0">return img, nil</span>
}

func getFullName(name string) (string, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Container name cannot be empty")
        }</span>
        <span class="cov8" title="1">if name[0] != '/' </span><span class="cov8" title="1">{
                name = "/" + name
        }</span>
        <span class="cov8" title="1">return name, nil</span>
}

func (runtime *Runtime) GetByName(name string) (*Container, error) <span class="cov0" title="0">{
        fullName, err := getFullName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">entity := runtime.containerGraph.Get(fullName)
        if entity == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not find entity for %s", name)
        }</span>
        <span class="cov0" title="0">e := runtime.getContainerElement(entity.ID())
        if e == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not find container for entity id %s", entity.ID())
        }</span>
        <span class="cov0" title="0">return e.Value.(*Container), nil</span>
}

func (runtime *Runtime) Children(name string) (map[string]*Container, error) <span class="cov0" title="0">{
        name, err := getFullName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">children := make(map[string]*Container)

        err = runtime.containerGraph.Walk(name, func(p string, e *graphdb.Entity) error </span><span class="cov0" title="0">{
                c := runtime.Get(e.ID())
                if c == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Could not get container for name %s and id %s", e.ID(), p)
                }</span>
                <span class="cov0" title="0">children[p] = c
                return nil</span>
        }, 0)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return children, nil</span>
}

func (runtime *Runtime) RegisterLink(parent, child *Container, alias string) error <span class="cov0" title="0">{
        fullName := path.Join(parent.Name, alias)
        if !runtime.containerGraph.Exists(fullName) </span><span class="cov0" title="0">{
                _, err := runtime.containerGraph.Set(fullName, child.ID)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FIXME: harmonize with NewGraph()
func NewRuntime(config *DaemonConfig) (*Runtime, error) <span class="cov0" title="0">{
        runtime, err := NewRuntimeFromDirectory(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">runtime.UpdateCapabilities(false)
        return runtime, nil</span>
}

func NewRuntimeFromDirectory(config *DaemonConfig) (*Runtime, error) <span class="cov0" title="0">{

        // Set the default driver
        graphdriver.DefaultDriver = config.GraphDriver

        // Load storage driver
        driver, err := graphdriver.New(config.Root)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">utils.Debugf("Using graph driver %s", driver)

        runtimeRepo := path.Join(config.Root, "containers")

        if err := os.MkdirAll(runtimeRepo, 0700); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if ad, ok := driver.(*aufs.Driver); ok </span><span class="cov0" title="0">{
                utils.Debugf("Migrating existing containers")
                if err := ad.Migrate(config.Root, setupInitLayer); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">utils.Debugf("Escaping AppArmor confinement")
        if err := linkLxcStart(config.Root); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">utils.Debugf("Creating images graph")
        g, err := NewGraph(path.Join(config.Root, "graph"), driver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We don't want to use a complex driver like aufs or devmapper
        // for volumes, just a plain filesystem
        <span class="cov0" title="0">volumesDriver, err := graphdriver.GetDriver("vfs", config.Root)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">utils.Debugf("Creating volumes graph")
        volumes, err := NewGraph(path.Join(config.Root, "volumes"), volumesDriver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">utils.Debugf("Creating repository list")
        repositories, err := NewTagStore(path.Join(config.Root, "repositories-"+driver.String()), g)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Couldn't create Tag store: %s", err)
        }</span>
        <span class="cov0" title="0">if config.BridgeIface == "" </span><span class="cov0" title="0">{
                config.BridgeIface = DefaultNetworkBridge
        }</span>
        <span class="cov0" title="0">netManager, err := newNetworkManager(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">graphdbPath := path.Join(config.Root, "linkgraph.db")
        graph, err := graphdb.NewSqliteConn(graphdbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">localCopy := path.Join(config.Root, "init", fmt.Sprintf("dockerinit-%s", VERSION))
        sysInitPath := utils.DockerInitPath(localCopy)
        if sysInitPath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not locate dockerinit: This usually means docker was built incorrectly. See http://docs.docker.io/en/latest/contributing/devenvironment for official build instructions.")
        }</span>

        <span class="cov0" title="0">if sysInitPath != localCopy </span><span class="cov0" title="0">{
                // When we find a suitable dockerinit binary (even if it's our local binary), we copy it into config.Root at localCopy for future use (so that the original can go away without that being a problem, for example during a package upgrade).
                if err := os.Mkdir(path.Dir(localCopy), 0700); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if _, err := utils.CopyFile(sysInitPath, localCopy); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := os.Chmod(localCopy, 0700); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">sysInitPath = localCopy</span>
        }

        <span class="cov0" title="0">runtime := &amp;Runtime{
                repository:     runtimeRepo,
                containers:     list.New(),
                networkManager: netManager,
                graph:          g,
                repositories:   repositories,
                idIndex:        utils.NewTruncIndex(),
                capabilities:   &amp;Capabilities{},
                volumes:        volumes,
                config:         config,
                containerGraph: graph,
                driver:         driver,
                sysInitPath:    sysInitPath,
        }

        if err := runtime.restore(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return runtime, nil</span>
}

func (runtime *Runtime) Close() error <span class="cov0" title="0">{
        errorsStrings := []string{}
        if err := runtime.networkManager.Close(); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("runtime.networkManager.Close(): %s", err.Error())
                errorsStrings = append(errorsStrings, err.Error())
        }</span>
        <span class="cov0" title="0">if err := runtime.driver.Cleanup(); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("runtime.driver.Cleanup(): %s", err.Error())
                errorsStrings = append(errorsStrings, err.Error())
        }</span>
        <span class="cov0" title="0">if err := runtime.containerGraph.Close(); err != nil </span><span class="cov0" title="0">{
                utils.Errorf("runtime.containerGraph.Close(): %s", err.Error())
                errorsStrings = append(errorsStrings, err.Error())
        }</span>
        <span class="cov0" title="0">if len(errorsStrings) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", strings.Join(errorsStrings, ", "))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (runtime *Runtime) Mount(container *Container) error <span class="cov0" title="0">{
        dir, err := runtime.driver.Get(container.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting container %s from driver %s: %s", container.ID, runtime.driver, err)
        }</span>
        <span class="cov0" title="0">if container.rootfs == "" </span><span class="cov0" title="0">{
                container.rootfs = dir
        }</span> <span class="cov0" title="0">else if container.rootfs != dir </span><span class="cov0" title="0">{
                return fmt.Errorf("Error: driver %s is returning inconsistent paths for container %s ('%s' then '%s')",
                        runtime.driver, container.ID, container.rootfs, dir)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (runtime *Runtime) Unmount(container *Container) error <span class="cov0" title="0">{
        // FIXME: Unmount is deprecated because drivers are responsible for mounting
        // and unmounting when necessary. Use driver.Remove() instead.
        return nil
}</span>

func (runtime *Runtime) Changes(container *Container) ([]archive.Change, error) <span class="cov0" title="0">{
        if differ, ok := runtime.driver.(graphdriver.Differ); ok </span><span class="cov0" title="0">{
                return differ.Changes(container.ID)
        }</span>
        <span class="cov0" title="0">cDir, err := runtime.driver.Get(container.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error getting container rootfs %s from driver %s: %s", container.ID, container.runtime.driver, err)
        }</span>
        <span class="cov0" title="0">initDir, err := runtime.driver.Get(container.ID + "-init")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error getting container init rootfs %s from driver %s: %s", container.ID, container.runtime.driver, err)
        }</span>
        <span class="cov0" title="0">return archive.ChangesDirs(cDir, initDir)</span>
}

func (runtime *Runtime) Diff(container *Container) (archive.Archive, error) <span class="cov0" title="0">{
        if differ, ok := runtime.driver.(graphdriver.Differ); ok </span><span class="cov0" title="0">{
                return differ.Diff(container.ID)
        }</span>

        <span class="cov0" title="0">changes, err := runtime.Changes(container)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cDir, err := runtime.driver.Get(container.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error getting container rootfs %s from driver %s: %s", container.ID, container.runtime.driver, err)
        }</span>

        <span class="cov0" title="0">return archive.ExportChanges(cDir, changes)</span>
}

// Nuke kills all containers then removes all content
// from the content root, including images, volumes and
// container filesystems.
// Again: this will remove your entire docker runtime!
func (runtime *Runtime) Nuke() error <span class="cov0" title="0">{
        var wg sync.WaitGroup
        for _, container := range runtime.List() </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(c *Container) </span><span class="cov0" title="0">{
                        c.Kill()
                        wg.Done()
                }</span>(container)
        }
        <span class="cov0" title="0">wg.Wait()
        runtime.Close()

        return os.RemoveAll(runtime.config.Root)</span>
}

func linkLxcStart(root string) error <span class="cov0" title="0">{
        sourcePath, err := exec.LookPath("lxc-start")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">targetPath := path.Join(root, "lxc-start-unconfined")

        if _, err := os.Lstat(targetPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span> <span class="cov0" title="0">else if err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(targetPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return os.Symlink(sourcePath, targetPath)</span>
}

// FIXME: this is a convenience function for integration tests
// which need direct access to runtime.graph.
// Once the tests switch to using engine and jobs, this method
// can go away.
func (runtime *Runtime) Graph() *Graph <span class="cov0" title="0">{
        return runtime.graph
}</span>

// History is a convenience type for storing a list of containers,
// ordered by creation date.
type History []*Container

func (history *History) Len() int <span class="cov0" title="0">{
        return len(*history)
}</span>

func (history *History) Less(i, j int) bool <span class="cov0" title="0">{
        containers := *history
        return containers[j].When().Before(containers[i].When())
}</span>

func (history *History) Swap(i, j int) <span class="cov0" title="0">{
        containers := *history
        tmp := containers[i]
        containers[i] = containers[j]
        containers[j] = tmp
}</span>

func (history *History) Add(container *Container) <span class="cov0" title="0">{
        *history = append(*history, container)
        sort.Sort(history)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package docker

import (
        "encoding/json"
        "errors"
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/auth"
        "github.com/dotcloud/docker/cgroups"
        "github.com/dotcloud/docker/engine"
        "github.com/dotcloud/docker/pkg/graphdb"
        "github.com/dotcloud/docker/registry"
        "github.com/dotcloud/docker/utils"
        "io"
        "io/ioutil"
        "log"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "os/signal"
        "path"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"
)

func (srv *Server) Close() error <span class="cov0" title="0">{
        return srv.runtime.Close()
}</span>

func init() <span class="cov8" title="1">{
        engine.Register("initapi", jobInitApi)
}</span>

// jobInitApi runs the remote api server `srv` as a daemon,
// Only one api server can run at the same time - this is enforced by a pidfile.
// The signals SIGINT, SIGQUIT and SIGTERM are intercepted for cleanup.
func jobInitApi(job *engine.Job) engine.Status <span class="cov0" title="0">{
        job.Logf("Creating server")
        // FIXME: ImportEnv deprecates ConfigFromJob
        srv, err := NewServer(job.Eng, ConfigFromJob(job))
        if err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if srv.runtime.config.Pidfile != "" </span><span class="cov0" title="0">{
                job.Logf("Creating pidfile")
                if err := utils.CreatePidFile(srv.runtime.config.Pidfile); err != nil </span><span class="cov0" title="0">{
                        // FIXME: do we need fatal here instead of returning a job error?
                        log.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">job.Logf("Setting up signal traps")
        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)
        go func() </span><span class="cov0" title="0">{
                sig := &lt;-c
                log.Printf("Received signal '%v', exiting\n", sig)
                utils.RemovePidFile(srv.runtime.config.Pidfile)
                srv.Close()
                os.Exit(0)
        }</span>()
        <span class="cov0" title="0">job.Eng.Hack_SetGlobalVar("httpapi.server", srv)
        job.Eng.Hack_SetGlobalVar("httpapi.runtime", srv.runtime)
        // https://github.com/dotcloud/docker/issues/2768
        if srv.runtime.networkManager.bridgeNetwork != nil </span><span class="cov0" title="0">{
                job.Eng.Hack_SetGlobalVar("httpapi.bridgeIP", srv.runtime.networkManager.bridgeNetwork.IP)
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("export", srv.ContainerExport); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("create", srv.ContainerCreate); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("stop", srv.ContainerStop); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("restart", srv.ContainerRestart); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("start", srv.ContainerStart); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("kill", srv.ContainerKill); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("serveapi", srv.ListenAndServe); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("wait", srv.ContainerWait); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("tag", srv.ImageTag); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("resize", srv.ContainerResize); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("commit", srv.ContainerCommit); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("info", srv.DockerInfo); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("container_delete", srv.ContainerDestroy); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if err := job.Eng.Register("image_export", srv.ImageExport); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

func (srv *Server) ListenAndServe(job *engine.Job) engine.Status <span class="cov0" title="0">{
        protoAddrs := job.Args
        chErrors := make(chan error, len(protoAddrs))
        for _, protoAddr := range protoAddrs </span><span class="cov0" title="0">{
                protoAddrParts := strings.SplitN(protoAddr, "://", 2)
                switch protoAddrParts[0] </span>{
                <span class="cov0" title="0">case "unix":
                        if err := syscall.Unlink(protoAddrParts[1]); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                <span class="cov0" title="0">case "tcp":
                        if !strings.HasPrefix(protoAddrParts[1], "127.0.0.1") </span><span class="cov0" title="0">{
                                log.Println("/!\\ DON'T BIND ON ANOTHER IP ADDRESS THAN 127.0.0.1 IF YOU DON'T KNOW WHAT YOU'RE DOING /!\\")
                        }</span>
                <span class="cov0" title="0">default:
                        job.Errorf("Invalid protocol format.")
                        return engine.StatusErr</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        // FIXME: merge Server.ListenAndServe with ListenAndServe
                        chErrors &lt;- ListenAndServe(protoAddrParts[0], protoAddrParts[1], srv, job.GetenvBool("Logging"))
                }</span>()
        }
        <span class="cov0" title="0">for i := 0; i &lt; len(protoAddrs); i += 1 </span><span class="cov0" title="0">{
                err := &lt;-chErrors
                if err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
        }
        <span class="cov0" title="0">return engine.StatusOK</span>
}

// simpleVersionInfo is a simple implementation of
// the interface VersionInfo, which is used
// to provide version information for some product,
// component, etc. It stores the product name and the version
// in string and returns them on calls to Name() and Version().
type simpleVersionInfo struct {
        name    string
        version string
}

func (v *simpleVersionInfo) Name() string <span class="cov0" title="0">{
        return v.name
}</span>

func (v *simpleVersionInfo) Version() string <span class="cov0" title="0">{
        return v.version
}</span>

// ContainerKill send signal to the container
// If no signal is given (sig 0), then Kill with SIGKILL and wait
// for the container to exit.
// If a signal is given, then just send it to the container and return.
func (srv *Server) ContainerKill(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if n := len(job.Args); n &lt; 1 || n &gt; 2 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s CONTAINER [SIGNAL]", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        var sig uint64
        if len(job.Args) == 2 &amp;&amp; job.Args[1] != "" </span><span class="cov0" title="0">{
                var err error
                // The largest legal signal is 31, so let's parse on 5 bits
                sig, err = strconv.ParseUint(job.Args[1], 10, 5)
                if err != nil </span><span class="cov0" title="0">{
                        job.Errorf("Invalid signal: %s", job.Args[1])
                        return engine.StatusErr
                }</span>
        }
        <span class="cov0" title="0">if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                // If no signal is passed, perform regular Kill (SIGKILL + wait())
                if sig == 0 </span><span class="cov0" title="0">{
                        if err := container.Kill(); err != nil </span><span class="cov0" title="0">{
                                job.Errorf("Cannot kill container %s: %s", name, err)
                                return engine.StatusErr
                        }</span>
                        <span class="cov0" title="0">srv.LogEvent("kill", container.ID, srv.runtime.repositories.ImageName(container.Image))</span>
                } <span class="cov0" title="0">else {
                        // Otherwise, just send the requested signal
                        if err := container.kill(int(sig)); err != nil </span><span class="cov0" title="0">{
                                job.Errorf("Cannot kill container %s: %s", name, err)
                                return engine.StatusErr
                        }</span>
                        // FIXME: Add event for signals
                }
        } <span class="cov0" title="0">else {
                job.Errorf("No such container: %s", name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

func (srv *Server) ContainerExport(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 1 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s container_id", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                data, err := container.Export()
                if err != nil </span><span class="cov0" title="0">{
                        job.Errorf("%s: %s", name, err)
                        return engine.StatusErr
                }</span>

                // Stream the entire contents of the container (basically a volatile snapshot)
                <span class="cov0" title="0">if _, err := io.Copy(job.Stdout, data); err != nil </span><span class="cov0" title="0">{
                        job.Errorf("%s: %s", name, err)
                        return engine.StatusErr
                }</span>
                // FIXME: factor job-specific LogEvent to engine.Job.Run()
                <span class="cov0" title="0">srv.LogEvent("export", container.ID, srv.runtime.repositories.ImageName(container.Image))
                return engine.StatusOK</span>
        }
        <span class="cov0" title="0">job.Errorf("No such container: %s", name)
        return engine.StatusErr</span>
}

// ImageExport exports all images with the given tag. All versions
// containing the same tag are exported. The resulting output is an
// uncompressed tar ball.
// name is the set of tags to export.
// out is the writer where the images are written to.
func (srv *Server) ImageExport(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 1 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s CONTAINER\n", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        // get image json
        tempdir, err := ioutil.TempDir("", "docker-export-")
        if err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tempdir)

        utils.Debugf("Serializing %s", name)

        rootRepo, err := srv.runtime.repositories.Get(name)
        if err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if rootRepo != nil </span><span class="cov0" title="0">{
                for _, id := range rootRepo </span><span class="cov0" title="0">{
                        image, err := srv.ImageInspect(id)
                        if err != nil </span><span class="cov0" title="0">{
                                job.Error(err)
                                return engine.StatusErr
                        }</span>

                        <span class="cov0" title="0">if err := srv.exportImage(image, tempdir); err != nil </span><span class="cov0" title="0">{
                                job.Error(err)
                                return engine.StatusErr
                        }</span>
                }

                // write repositories
                <span class="cov0" title="0">rootRepoMap := map[string]Repository{}
                rootRepoMap[name] = rootRepo
                rootRepoJson, _ := json.Marshal(rootRepoMap)

                if err := ioutil.WriteFile(path.Join(tempdir, "repositories"), rootRepoJson, os.ModeAppend); err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
        } <span class="cov0" title="0">else {
                image, err := srv.ImageInspect(name)
                if err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">if err := srv.exportImage(image, tempdir); err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
        }

        <span class="cov0" title="0">fs, err := archive.Tar(tempdir, archive.Uncompressed)
        if err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>

        <span class="cov0" title="0">if _, err := io.Copy(job.Stdout, fs); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

func (srv *Server) exportImage(image *Image, tempdir string) error <span class="cov0" title="0">{
        for i := image; i != nil; </span><span class="cov0" title="0">{
                // temporary directory
                tmpImageDir := path.Join(tempdir, i.ID)
                if err := os.Mkdir(tmpImageDir, os.ModeDir); err != nil </span><span class="cov0" title="0">{
                        if os.IsExist(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">var version = "1.0"
                var versionBuf = []byte(version)

                if err := ioutil.WriteFile(path.Join(tmpImageDir, "VERSION"), versionBuf, os.ModeAppend); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // serialize json
                <span class="cov0" title="0">b, err := json.Marshal(i)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := ioutil.WriteFile(path.Join(tmpImageDir, "json"), b, os.ModeAppend); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // serialize filesystem
                <span class="cov0" title="0">fs, err := i.TarLayer()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fsTar, err := os.Create(path.Join(tmpImageDir, "layer.tar"))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err = io.Copy(fsTar, fs); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fsTar.Close()

                // find parent
                if i.Parent != "" </span><span class="cov0" title="0">{
                        i, err = srv.ImageInspect(i.Parent)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } <span class="cov0" title="0">else {
                        i = nil
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Loads a set of images into the repository. This is the complementary of ImageExport.
// The input stream is an uncompressed tar ball containing images and metadata.
func (srv *Server) ImageLoad(in io.Reader) error <span class="cov0" title="0">{
        tmpImageDir, err := ioutil.TempDir("", "docker-import-")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tmpImageDir)

        var (
                repoTarFile = path.Join(tmpImageDir, "repo.tar")
                repoDir     = path.Join(tmpImageDir, "repo")
        )

        tarFile, err := os.Create(repoTarFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := io.Copy(tarFile, in); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tarFile.Close()

        repoFile, err := os.Open(repoTarFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := os.Mkdir(repoDir, os.ModeDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := archive.Untar(repoFile, repoDir, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dirs, err := ioutil.ReadDir(repoDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, d := range dirs </span><span class="cov0" title="0">{
                if d.IsDir() </span><span class="cov0" title="0">{
                        if err := srv.recursiveLoad(d.Name(), tmpImageDir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">repositoriesJson, err := ioutil.ReadFile(path.Join(tmpImageDir, "repo", "repositories"))
        if err == nil </span><span class="cov0" title="0">{
                repositories := map[string]Repository{}
                if err := json.Unmarshal(repositoriesJson, &amp;repositories); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for imageName, tagMap := range repositories </span><span class="cov0" title="0">{
                        for tag, address := range tagMap </span><span class="cov0" title="0">{
                                if err := srv.runtime.repositories.Set(imageName, tag, address, true); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        } <span class="cov0" title="0">else if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) recursiveLoad(address, tmpImageDir string) error <span class="cov0" title="0">{
        if _, err := srv.ImageInspect(address); err != nil </span><span class="cov0" title="0">{
                utils.Debugf("Loading %s", address)

                imageJson, err := ioutil.ReadFile(path.Join(tmpImageDir, "repo", address, "json"))
                if err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error reading json", err)
                        return err
                }</span>

                <span class="cov0" title="0">layer, err := os.Open(path.Join(tmpImageDir, "repo", address, "layer.tar"))
                if err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error reading embedded tar", err)
                        return err
                }</span>
                <span class="cov0" title="0">img, err := NewImgJSON(imageJson)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Debugf("Error unmarshalling json", err)
                        return err
                }</span>
                <span class="cov0" title="0">if img.Parent != "" </span><span class="cov0" title="0">{
                        if !srv.runtime.graph.Exists(img.Parent) </span><span class="cov0" title="0">{
                                if err := srv.recursiveLoad(img.Parent, tmpImageDir); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">if err := srv.runtime.graph.Register(imageJson, layer, img); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">utils.Debugf("Completed processing %s", address)

        return nil</span>
}

func (srv *Server) ImagesSearch(term string) ([]registry.SearchResult, error) <span class="cov0" title="0">{
        r, err := registry.NewRegistry(nil, srv.HTTPRequestFactory(nil), auth.IndexServerAddress())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">results, err := r.SearchRepositories(term)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return results.Results, nil</span>
}

func (srv *Server) ImageInsert(name, url, path string, out io.Writer, sf *utils.StreamFormatter) error <span class="cov0" title="0">{
        out = utils.NewWriteFlusher(out)
        img, err := srv.runtime.repositories.LookupImage(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err := utils.Download(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Body.Close()

        config, _, _, err := ParseRun([]string{img.ID, "echo", "insert", url, path}, srv.runtime.capabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c, _, err := srv.runtime.Create(config, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.Inject(utils.ProgressReader(file.Body, int(file.ContentLength), out, sf, false, "", "Downloading"), path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // FIXME: Handle custom repo, tag comment, author
        <span class="cov0" title="0">img, err = srv.runtime.Commit(c, "", "", img.Comment, img.Author, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">out.Write(sf.FormatStatus(img.ID, ""))
        return nil</span>
}

func (srv *Server) ImagesViz(out io.Writer) error <span class="cov0" title="0">{
        images, _ := srv.runtime.graph.Map()
        if images == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out.Write([]byte("digraph docker {\n"))

        var (
                parentImage *Image
                err         error
        )
        for _, image := range images </span><span class="cov0" title="0">{
                parentImage, err = image.GetParent()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error while getting parent image: %v", err)
                }</span>
                <span class="cov0" title="0">if parentImage != nil </span><span class="cov0" title="0">{
                        out.Write([]byte(" \"" + parentImage.ID + "\" -&gt; \"" + image.ID + "\"\n"))
                }</span> <span class="cov0" title="0">else {
                        out.Write([]byte(" base -&gt; \"" + image.ID + "\" [style=invis]\n"))
                }</span>
        }

        <span class="cov0" title="0">reporefs := make(map[string][]string)

        for name, repository := range srv.runtime.repositories.Repositories </span><span class="cov0" title="0">{
                for tag, id := range repository </span><span class="cov0" title="0">{
                        reporefs[utils.TruncateID(id)] = append(reporefs[utils.TruncateID(id)], fmt.Sprintf("%s:%s", name, tag))
                }</span>
        }

        <span class="cov0" title="0">for id, repos := range reporefs </span><span class="cov0" title="0">{
                out.Write([]byte(" \"" + id + "\" [label=\"" + id + "\\n" + strings.Join(repos, "\\n") + "\",shape=box,fillcolor=\"paleturquoise\",style=\"filled,rounded\"];\n"))
        }</span>
        <span class="cov0" title="0">out.Write([]byte(" base [style=invisible]\n}\n"))
        return nil</span>
}

func (srv *Server) Images(all bool, filter string) ([]APIImages, error) <span class="cov0" title="0">{
        var (
                allImages map[string]*Image
                err       error
        )
        if all </span><span class="cov0" title="0">{
                allImages, err = srv.runtime.graph.Map()
        }</span> <span class="cov0" title="0">else {
                allImages, err = srv.runtime.graph.Heads()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">lookup := make(map[string]APIImages)
        for name, repository := range srv.runtime.repositories.Repositories </span><span class="cov0" title="0">{
                if filter != "" </span><span class="cov0" title="0">{
                        if match, _ := path.Match(filter, name); !match </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">for tag, id := range repository </span><span class="cov0" title="0">{
                        image, err := srv.runtime.graph.Get(id)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: couldn't load %s from %s/%s: %s", id, name, tag, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if out, exists := lookup[id]; exists </span><span class="cov0" title="0">{
                                out.RepoTags = append(out.RepoTags, fmt.Sprintf("%s:%s", name, tag))

                                lookup[id] = out
                        }</span> <span class="cov0" title="0">else {
                                var out APIImages

                                delete(allImages, id)

                                out.ParentId = image.Parent
                                out.RepoTags = []string{fmt.Sprintf("%s:%s", name, tag)}
                                out.ID = image.ID
                                out.Created = image.Created.Unix()
                                out.Size = image.Size
                                out.VirtualSize = image.getParentsSize(0) + image.Size

                                lookup[id] = out
                        }</span>

                }
        }

        <span class="cov0" title="0">outs := make([]APIImages, 0, len(lookup))
        for _, value := range lookup </span><span class="cov0" title="0">{
                outs = append(outs, value)
        }</span>

        // Display images which aren't part of a repository/tag
        <span class="cov0" title="0">if filter == "" </span><span class="cov0" title="0">{
                for _, image := range allImages </span><span class="cov0" title="0">{
                        var out APIImages
                        out.ID = image.ID
                        out.ParentId = image.Parent
                        out.RepoTags = []string{"&lt;none&gt;:&lt;none&gt;"}
                        out.Created = image.Created.Unix()
                        out.Size = image.Size
                        out.VirtualSize = image.getParentsSize(0) + image.Size
                        outs = append(outs, out)
                }</span>
        }

        <span class="cov0" title="0">sortImagesByCreationAndTag(outs)
        return outs, nil</span>
}

func (srv *Server) DockerInfo(job *engine.Job) engine.Status <span class="cov0" title="0">{
        images, _ := srv.runtime.graph.Map()
        var imgcount int
        if images == nil </span><span class="cov0" title="0">{
                imgcount = 0
        }</span> <span class="cov0" title="0">else {
                imgcount = len(images)
        }</span>
        <span class="cov0" title="0">lxcVersion := ""
        if output, err := exec.Command("lxc-version").CombinedOutput(); err == nil </span><span class="cov0" title="0">{
                outputStr := string(output)
                if len(strings.SplitN(outputStr, ":", 2)) == 2 </span><span class="cov0" title="0">{
                        lxcVersion = strings.TrimSpace(strings.SplitN(string(output), ":", 2)[1])
                }</span>
        }
        <span class="cov0" title="0">kernelVersion := "&lt;unknown&gt;"
        if kv, err := utils.GetKernelVersion(); err == nil </span><span class="cov0" title="0">{
                kernelVersion = kv.String()
        }</span>

        // if we still have the original dockerinit binary from before we copied it locally, let's return the path to that, since that's more intuitive (the copied path is trivial to derive by hand given VERSION)
        <span class="cov0" title="0">initPath := utils.DockerInitPath("")
        if initPath == "" </span><span class="cov0" title="0">{
                // if that fails, we'll just return the path from the runtime
                initPath = srv.runtime.sysInitPath
        }</span>

        <span class="cov0" title="0">v := &amp;engine.Env{}
        v.SetInt("Containers", len(srv.runtime.List()))
        v.SetInt("Images", imgcount)
        v.Set("Driver", srv.runtime.driver.String())
        v.SetJson("DriverStatus", srv.runtime.driver.Status())
        v.SetBool("MemoryLimit", srv.runtime.capabilities.MemoryLimit)
        v.SetBool("SwapLimit", srv.runtime.capabilities.SwapLimit)
        v.SetBool("IPv4Forwarding", !srv.runtime.capabilities.IPv4ForwardingDisabled)
        v.SetBool("Debug", os.Getenv("DEBUG") != "")
        v.SetInt("NFd", utils.GetTotalUsedFds())
        v.SetInt("NGoroutines", runtime.NumGoroutine())
        v.Set("LXCVersion", lxcVersion)
        v.SetInt("NEventsListener", len(srv.events))
        v.Set("KernelVersion", kernelVersion)
        v.Set("IndexServerAddress", auth.IndexServerAddress())
        v.Set("InitSha1", utils.INITSHA1)
        v.Set("InitPath", initPath)
        if _, err := v.WriteTo(job.Stdout); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

func (srv *Server) ImageHistory(name string) ([]APIHistory, error) <span class="cov0" title="0">{
        image, err := srv.runtime.repositories.LookupImage(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">lookupMap := make(map[string][]string)
        for name, repository := range srv.runtime.repositories.Repositories </span><span class="cov0" title="0">{
                for tag, id := range repository </span><span class="cov0" title="0">{
                        // If the ID already has a reverse lookup, do not update it unless for "latest"
                        if _, exists := lookupMap[id]; !exists </span><span class="cov0" title="0">{
                                lookupMap[id] = []string{}
                        }</span>
                        <span class="cov0" title="0">lookupMap[id] = append(lookupMap[id], name+":"+tag)</span>
                }
        }

        <span class="cov0" title="0">outs := []APIHistory{} //produce [] when empty instead of 'null'
        err = image.WalkHistory(func(img *Image) error </span><span class="cov0" title="0">{
                var out APIHistory
                out.ID = img.ID
                out.Created = img.Created.Unix()
                out.CreatedBy = strings.Join(img.ContainerConfig.Cmd, " ")
                out.Tags = lookupMap[img.ID]
                out.Size = img.Size
                outs = append(outs, out)
                return nil
        }</span>)
        <span class="cov0" title="0">return outs, nil</span>

}

func (srv *Server) ContainerTop(name, psArgs string) (*APITop, error) <span class="cov0" title="0">{
        if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                if !container.State.IsRunning() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Container %s is not running", name)
                }</span>
                <span class="cov0" title="0">pids, err := cgroups.GetPidsForContainer(container.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(psArgs) == 0 </span><span class="cov0" title="0">{
                        psArgs = "-ef"
                }</span>
                <span class="cov0" title="0">output, err := exec.Command("ps", psArgs).Output()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error running ps: %s", err)
                }</span>

                <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
                header := strings.Fields(lines[0])
                procs := APITop{
                        Titles: header,
                }

                pidIndex := -1
                for i, name := range header </span><span class="cov0" title="0">{
                        if name == "PID" </span><span class="cov0" title="0">{
                                pidIndex = i
                        }</span>
                }
                <span class="cov0" title="0">if pidIndex == -1 </span><span class="cov0" title="0">{
                        return nil, errors.New("Couldn't find PID field in ps output")
                }</span>

                <span class="cov0" title="0">for _, line := range lines[1:] </span><span class="cov0" title="0">{
                        if len(line) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">fields := strings.Fields(line)
                        p, err := strconv.Atoi(fields[pidIndex])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Unexpected pid '%s': %s", fields[pidIndex], err)
                        }</span>

                        <span class="cov0" title="0">for _, pid := range pids </span><span class="cov0" title="0">{
                                if pid == p </span><span class="cov0" title="0">{
                                        // Make sure number of fields equals number of header titles
                                        // merging "overhanging" fields
                                        processes := fields[:len(procs.Titles)-1]
                                        processes = append(processes, strings.Join(fields[len(procs.Titles)-1:], " "))

                                        procs.Processes = append(procs.Processes, processes)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return &amp;procs, nil</span>

        }
        <span class="cov0" title="0">return nil, fmt.Errorf("No such container: %s", name)</span>
}

func (srv *Server) ContainerChanges(name string) ([]archive.Change, error) <span class="cov0" title="0">{
        if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                return container.Changes()
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("No such container: %s", name)</span>
}

func (srv *Server) Containers(all, size bool, n int, since, before string) []APIContainers <span class="cov0" title="0">{
        var foundBefore bool
        var displayed int
        out := []APIContainers{}

        names := map[string][]string{}
        srv.runtime.containerGraph.Walk("/", func(p string, e *graphdb.Entity) error </span><span class="cov0" title="0">{
                names[e.ID()] = append(names[e.ID()], p)
                return nil
        }</span>, -1)

        <span class="cov0" title="0">for _, container := range srv.runtime.List() </span><span class="cov0" title="0">{
                if !container.State.IsRunning() &amp;&amp; !all &amp;&amp; n == -1 &amp;&amp; since == "" &amp;&amp; before == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if before != "" &amp;&amp; !foundBefore </span><span class="cov0" title="0">{
                        if container.ID == before || utils.TruncateID(container.ID) == before </span><span class="cov0" title="0">{
                                foundBefore = true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if displayed == n </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if container.ID == since || utils.TruncateID(container.ID) == since </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">displayed++
                c := createAPIContainer(names[container.ID], container, size, srv.runtime)
                out = append(out, c)</span>
        }
        <span class="cov0" title="0">return out</span>
}

func createAPIContainer(names []string, container *Container, size bool, runtime *Runtime) APIContainers <span class="cov0" title="0">{
        c := APIContainers{
                ID: container.ID,
        }
        c.Names = names
        c.Image = runtime.repositories.ImageName(container.Image)
        c.Command = fmt.Sprintf("%s %s", container.Path, strings.Join(container.Args, " "))
        c.Created = container.Created.Unix()
        c.Status = container.State.String()
        c.Ports = container.NetworkSettings.PortMappingAPI()
        if size </span><span class="cov0" title="0">{
                c.SizeRw, c.SizeRootFs = container.GetSize()
        }</span>
        <span class="cov0" title="0">return c</span>
}
func (srv *Server) ContainerCommit(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 1 </span><span class="cov0" title="0">{
                job.Errorf("Not enough arguments. Usage: %s CONTAINER\n", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]

        container := srv.runtime.Get(name)
        if container == nil </span><span class="cov0" title="0">{
                job.Errorf("No such container: %s", name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">var config Config
        if err := job.GetenvJson("config", &amp;config); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>

        <span class="cov0" title="0">img, err := srv.runtime.Commit(container, job.Getenv("repo"), job.Getenv("tag"), job.Getenv("comment"), job.Getenv("author"), &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">job.Printf("%s\n", img.ID)
        return engine.StatusOK</span>
}

func (srv *Server) ImageTag(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 2 &amp;&amp; len(job.Args) != 3 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s IMAGE REPOSITORY [TAG]\n", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">var tag string
        if len(job.Args) == 3 </span><span class="cov0" title="0">{
                tag = job.Args[2]
        }</span>
        <span class="cov0" title="0">if err := srv.runtime.repositories.Set(job.Args[1], tag, job.Args[0], job.GetenvBool("force")); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

func (srv *Server) pullImage(r *registry.Registry, out io.Writer, imgID, endpoint string, token []string, sf *utils.StreamFormatter) error <span class="cov0" title="0">{
        history, err := r.GetRemoteHistory(imgID, endpoint, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(imgID), "Pulling dependent layers", nil))
        // FIXME: Try to stream the images?
        // FIXME: Launch the getRemoteImage() in goroutines

        for i := len(history) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                id := history[i]

                // ensure no two downloads of the same layer happen at the same time
                if c, err := srv.poolAdd("pull", "layer:"+id); err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Image (id: %s) pull is already running, skipping: %v", id, err)
                        &lt;-c
                }</span>
                <span class="cov0" title="0">defer srv.poolRemove("pull", "layer:"+id)

                if !srv.runtime.graph.Exists(id) </span><span class="cov0" title="0">{
                        out.Write(sf.FormatProgress(utils.TruncateID(id), "Pulling metadata", nil))
                        imgJSON, imgSize, err := r.GetRemoteImageJSON(id, endpoint, token)
                        if err != nil </span><span class="cov0" title="0">{
                                out.Write(sf.FormatProgress(utils.TruncateID(id), "Error pulling dependent layers", nil))
                                // FIXME: Keep going in case of error?
                                return err
                        }</span>
                        <span class="cov0" title="0">img, err := NewImgJSON(imgJSON)
                        if err != nil </span><span class="cov0" title="0">{
                                out.Write(sf.FormatProgress(utils.TruncateID(id), "Error pulling dependent layers", nil))
                                return fmt.Errorf("Failed to parse json: %s", err)
                        }</span>

                        // Get the layer
                        <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(id), "Pulling fs layer", nil))
                        layer, err := r.GetRemoteImageLayer(img.ID, endpoint, token)
                        if err != nil </span><span class="cov0" title="0">{
                                out.Write(sf.FormatProgress(utils.TruncateID(id), "Error pulling dependent layers", nil))
                                return err
                        }</span>
                        <span class="cov0" title="0">defer layer.Close()
                        if err := srv.runtime.graph.Register(imgJSON, utils.ProgressReader(layer, imgSize, out, sf, false, utils.TruncateID(id), "Downloading"), img); err != nil </span><span class="cov0" title="0">{
                                out.Write(sf.FormatProgress(utils.TruncateID(id), "Error downloading dependent layers", nil))
                                return err
                        }</span>
                }
                <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(id), "Download complete", nil))</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) pullRepository(r *registry.Registry, out io.Writer, localName, remoteName, askedTag string, sf *utils.StreamFormatter, parallel bool) error <span class="cov0" title="0">{
        out.Write(sf.FormatStatus("", "Pulling repository %s", localName))

        repoData, err := r.GetRepositoryData(remoteName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">utils.Debugf("Retrieving the tag list")
        tagsList, err := r.GetRemoteTags(repoData.Endpoints, remoteName, repoData.Tokens)
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorf("%v", err)
                return err
        }</span>

        <span class="cov0" title="0">for tag, id := range tagsList </span><span class="cov0" title="0">{
                repoData.ImgList[id] = &amp;registry.ImgData{
                        ID:       id,
                        Tag:      tag,
                        Checksum: "",
                }
        }</span>

        <span class="cov0" title="0">utils.Debugf("Registering tags")
        // If no tag has been specified, pull them all
        if askedTag == "" </span><span class="cov0" title="0">{
                for tag, id := range tagsList </span><span class="cov0" title="0">{
                        repoData.ImgList[id].Tag = tag
                }</span>
        } <span class="cov0" title="0">else {
                // Otherwise, check that the tag exists and use only that one
                id, exists := tagsList[askedTag]
                if !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("Tag %s not found in repository %s", askedTag, localName)
                }</span>
                <span class="cov0" title="0">repoData.ImgList[id].Tag = askedTag</span>
        }

        <span class="cov0" title="0">errors := make(chan error)
        for _, image := range repoData.ImgList </span><span class="cov0" title="0">{
                downloadImage := func(img *registry.ImgData) </span><span class="cov0" title="0">{
                        if askedTag != "" &amp;&amp; img.Tag != askedTag </span><span class="cov0" title="0">{
                                utils.Debugf("(%s) does not match %s (id: %s), skipping", img.Tag, askedTag, img.ID)
                                if parallel </span><span class="cov0" title="0">{
                                        errors &lt;- nil
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">if img.Tag == "" </span><span class="cov0" title="0">{
                                utils.Debugf("Image (id: %s) present in this repository but untagged, skipping", img.ID)
                                if parallel </span><span class="cov0" title="0">{
                                        errors &lt;- nil
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        // ensure no two downloads of the same image happen at the same time
                        <span class="cov0" title="0">if c, err := srv.poolAdd("pull", "img:"+img.ID); err != nil </span><span class="cov0" title="0">{
                                if c != nil </span><span class="cov0" title="0">{
                                        out.Write(sf.FormatProgress(utils.TruncateID(img.ID), "Layer already being pulled by another client. Waiting.", nil))
                                        &lt;-c
                                        out.Write(sf.FormatProgress(utils.TruncateID(img.ID), "Download complete", nil))
                                }</span> <span class="cov0" title="0">else {
                                        utils.Errorf("Image (id: %s) pull is already running, skipping: %v", img.ID, err)
                                }</span>
                                <span class="cov0" title="0">if parallel </span><span class="cov0" title="0">{
                                        errors &lt;- nil
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov0" title="0">defer srv.poolRemove("pull", "img:"+img.ID)

                        out.Write(sf.FormatProgress(utils.TruncateID(img.ID), fmt.Sprintf("Pulling image (%s) from %s", img.Tag, localName), nil))
                        success := false
                        var lastErr error
                        for _, ep := range repoData.Endpoints </span><span class="cov0" title="0">{
                                out.Write(sf.FormatProgress(utils.TruncateID(img.ID), fmt.Sprintf("Pulling image (%s) from %s, endpoint: %s", img.Tag, localName, ep), nil))
                                if err := srv.pullImage(r, out, img.ID, ep, repoData.Tokens, sf); err != nil </span><span class="cov0" title="0">{
                                        // Its not ideal that only the last error  is returned, it would be better to concatenate the errors.
                                        // As the error is also given to the output stream the user will see the error.
                                        lastErr = err
                                        out.Write(sf.FormatProgress(utils.TruncateID(img.ID), fmt.Sprintf("Error pulling image (%s) from %s, endpoint: %s, %s", img.Tag, localName, ep, err), nil))
                                        continue</span>
                                }
                                <span class="cov0" title="0">success = true
                                break</span>
                        }
                        <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                                out.Write(sf.FormatProgress(utils.TruncateID(img.ID), fmt.Sprintf("Error pulling image (%s) from %s, %s", img.Tag, localName, lastErr), nil))
                                if parallel </span><span class="cov0" title="0">{
                                        errors &lt;- fmt.Errorf("Could not find repository on any of the indexed registries.")
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(img.ID), "Download complete", nil))

                        if parallel </span><span class="cov0" title="0">{
                                errors &lt;- nil
                        }</span>
                }

                <span class="cov0" title="0">if parallel </span><span class="cov0" title="0">{
                        go downloadImage(image)
                }</span> <span class="cov0" title="0">else {
                        downloadImage(image)
                }</span>
        }
        <span class="cov0" title="0">if parallel </span><span class="cov0" title="0">{
                var lastError error
                for i := 0; i &lt; len(repoData.ImgList); i++ </span><span class="cov0" title="0">{
                        if err := &lt;-errors; err != nil </span><span class="cov0" title="0">{
                                lastError = err
                        }</span>
                }
                <span class="cov0" title="0">if lastError != nil </span><span class="cov0" title="0">{
                        return lastError
                }</span>

        }
        <span class="cov0" title="0">for tag, id := range tagsList </span><span class="cov0" title="0">{
                if askedTag != "" &amp;&amp; tag != askedTag </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err := srv.runtime.repositories.Set(localName, tag, id, true); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if err := srv.runtime.repositories.Save(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) poolAdd(kind, key string) (chan struct{}, error) <span class="cov8" title="1">{
        srv.Lock()
        defer srv.Unlock()

        if c, exists := srv.pullingPool[key]; exists </span><span class="cov8" title="1">{
                return c, fmt.Errorf("pull %s is already in progress", key)
        }</span>
        <span class="cov8" title="1">if c, exists := srv.pushingPool[key]; exists </span><span class="cov0" title="0">{
                return c, fmt.Errorf("push %s is already in progress", key)
        }</span>

        <span class="cov8" title="1">c := make(chan struct{})
        switch kind </span>{
        <span class="cov8" title="1">case "pull":
                srv.pullingPool[key] = c</span>
        <span class="cov0" title="0">case "push":
                srv.pushingPool[key] = c</span>
        <span class="cov8" title="1">default:
                return nil, fmt.Errorf("Unknown pool type")</span>
        }
        <span class="cov8" title="1">return c, nil</span>
}

func (srv *Server) poolRemove(kind, key string) error <span class="cov8" title="1">{
        srv.Lock()
        defer srv.Unlock()
        switch kind </span>{
        <span class="cov8" title="1">case "pull":
                if c, exists := srv.pullingPool[key]; exists </span><span class="cov8" title="1">{
                        close(c)
                        delete(srv.pullingPool, key)
                }</span>
        <span class="cov8" title="1">case "push":
                if c, exists := srv.pushingPool[key]; exists </span><span class="cov0" title="0">{
                        close(c)
                        delete(srv.pushingPool, key)
                }</span>
        <span class="cov8" title="1">default:
                return fmt.Errorf("Unknown pool type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (srv *Server) ImagePull(localName string, tag string, out io.Writer, sf *utils.StreamFormatter, authConfig *auth.AuthConfig, metaHeaders map[string][]string, parallel bool) error <span class="cov0" title="0">{
        out = utils.NewWriteFlusher(out)

        c, err := srv.poolAdd("pull", localName+":"+tag)
        if err != nil </span><span class="cov0" title="0">{
                if c != nil </span><span class="cov0" title="0">{
                        // Another pull of the same repository is already taking place; just wait for it to finish
                        out.Write(sf.FormatStatus("", "Repository %s already being pulled by another client. Waiting.", localName))
                        &lt;-c
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer srv.poolRemove("pull", localName+":"+tag)

        // Resolve the Repository name from fqn to endpoint + name
        endpoint, remoteName, err := registry.ResolveRepositoryName(localName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r, err := registry.NewRegistry(authConfig, srv.HTTPRequestFactory(metaHeaders), endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if endpoint == auth.IndexServerAddress() </span><span class="cov0" title="0">{
                // If pull "index.docker.io/foo/bar", it's stored locally under "foo/bar"
                localName = remoteName
        }</span>

        <span class="cov0" title="0">if err = srv.pullRepository(r, out, localName, remoteName, tag, sf, parallel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Retrieve the all the images to be uploaded in the correct order
// Note: we can't use a map as it is not ordered
func (srv *Server) getImageList(localRepo map[string]string) ([][]*registry.ImgData, error) <span class="cov0" title="0">{
        imgList := map[string]*registry.ImgData{}
        depGraph := utils.NewDependencyGraph()

        for tag, id := range localRepo </span><span class="cov0" title="0">{
                img, err := srv.runtime.graph.Get(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">depGraph.NewNode(img.ID)
                img.WalkHistory(func(current *Image) error </span><span class="cov0" title="0">{
                        imgList[current.ID] = &amp;registry.ImgData{
                                ID:  current.ID,
                                Tag: tag,
                        }
                        parent, err := current.GetParent()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if parent == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">depGraph.NewNode(parent.ID)
                        depGraph.AddDependency(current.ID, parent.ID)
                        return nil</span>
                })
        }

        <span class="cov0" title="0">traversalMap, err := depGraph.GenerateTraversalMap()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">utils.Debugf("Traversal map: %v", traversalMap)
        result := [][]*registry.ImgData{}
        for _, round := range traversalMap </span><span class="cov0" title="0">{
                dataRound := []*registry.ImgData{}
                for _, imgID := range round </span><span class="cov0" title="0">{
                        dataRound = append(dataRound, imgList[imgID])
                }</span>
                <span class="cov0" title="0">result = append(result, dataRound)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func flatten(slc [][]*registry.ImgData) []*registry.ImgData <span class="cov0" title="0">{
        result := []*registry.ImgData{}
        for _, x := range slc </span><span class="cov0" title="0">{
                result = append(result, x...)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (srv *Server) pushRepository(r *registry.Registry, out io.Writer, localName, remoteName string, localRepo map[string]string, sf *utils.StreamFormatter) error <span class="cov0" title="0">{
        out = utils.NewWriteFlusher(out)
        imgList, err := srv.getImageList(localRepo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">flattenedImgList := flatten(imgList)
        out.Write(sf.FormatStatus("", "Sending image list"))

        var repoData *registry.RepositoryData
        repoData, err = r.PushImageJSONIndex(remoteName, flattenedImgList, false, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, ep := range repoData.Endpoints </span><span class="cov0" title="0">{
                out.Write(sf.FormatStatus("", "Pushing repository %s (%d tags)", localName, len(localRepo)))
                // This section can not be parallelized (each round depends on the previous one)
                for i, round := range imgList </span><span class="cov0" title="0">{
                        // FIXME: This section can be parallelized
                        for _, elem := range round </span><span class="cov0" title="0">{
                                var pushTags func() error
                                pushTags = func() error </span><span class="cov0" title="0">{
                                        if i &lt; (len(imgList) - 1) </span><span class="cov0" title="0">{
                                                // Only tag the top layer in the repository
                                                return nil
                                        }</span>

                                        <span class="cov0" title="0">out.Write(sf.FormatStatus("", "Pushing tags for rev [%s] on {%s}", utils.TruncateID(elem.ID), ep+"repositories/"+remoteName+"/tags/"+elem.Tag))
                                        if err := r.PushRegistryTag(remoteName, elem.ID, elem.Tag, ep, repoData.Tokens); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }
                                <span class="cov0" title="0">if _, exists := repoData.ImgList[elem.ID]; exists </span><span class="cov0" title="0">{
                                        if err := pushTags(); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(elem.ID), "Image already pushed, skipping", nil))
                                        continue</span>
                                } <span class="cov0" title="0">else if r.LookupRemoteImage(elem.ID, ep, repoData.Tokens) </span><span class="cov0" title="0">{
                                        if err := pushTags(); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(elem.ID), "Image already pushed, skipping", nil))
                                        continue</span>
                                }
                                <span class="cov0" title="0">checksum, err := srv.pushImage(r, out, remoteName, elem.ID, ep, repoData.Tokens, sf)
                                if err != nil </span><span class="cov0" title="0">{
                                        // FIXME: Continue on error?
                                        return err
                                }</span>
                                <span class="cov0" title="0">elem.Checksum = checksum

                                if err := pushTags(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if _, err := r.PushImageJSONIndex(remoteName, flattenedImgList, true, repoData.Endpoints); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) pushImage(r *registry.Registry, out io.Writer, remote, imgID, ep string, token []string, sf *utils.StreamFormatter) (checksum string, err error) <span class="cov0" title="0">{
        out = utils.NewWriteFlusher(out)
        jsonRaw, err := ioutil.ReadFile(path.Join(srv.runtime.graph.Root, imgID, "json"))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Cannot retrieve the path for {%s}: %s", imgID, err)
        }</span>
        <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(imgID), "Pushing", nil))

        imgData := &amp;registry.ImgData{
                ID: imgID,
        }

        // Send the json
        if err := r.PushImageJSONRegistry(imgData, jsonRaw, ep, token); err != nil </span><span class="cov0" title="0">{
                if err == registry.ErrAlreadyExists </span><span class="cov0" title="0">{
                        out.Write(sf.FormatProgress(utils.TruncateID(imgData.ID), "Image already pushed, skipping", nil))
                        return "", nil
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }

        <span class="cov0" title="0">layerData, err := srv.runtime.graph.TempLayerArchive(imgID, archive.Uncompressed, sf, out)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Failed to generate layer archive: %s", err)
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(layerData.Name())

        // Send the layer
        checksum, err = r.PushImageLayerRegistry(imgData.ID, utils.ProgressReader(layerData, int(layerData.Size), out, sf, false, utils.TruncateID(imgData.ID), "Pushing"), ep, token, jsonRaw)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">imgData.Checksum = checksum
        // Send the checksum
        if err := r.PushImageChecksumRegistry(imgData, ep, token); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">out.Write(sf.FormatProgress(utils.TruncateID(imgData.ID), "Image successfully pushed", nil))
        return imgData.Checksum, nil</span>
}

// FIXME: Allow to interrupt current push when new push of same image is done.
func (srv *Server) ImagePush(localName string, out io.Writer, sf *utils.StreamFormatter, authConfig *auth.AuthConfig, metaHeaders map[string][]string) error <span class="cov0" title="0">{
        if _, err := srv.poolAdd("push", localName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer srv.poolRemove("push", localName)

        // Resolve the Repository name from fqn to endpoint + name
        endpoint, remoteName, err := registry.ResolveRepositoryName(localName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">out = utils.NewWriteFlusher(out)
        img, err := srv.runtime.graph.Get(localName)
        r, err2 := registry.NewRegistry(authConfig, srv.HTTPRequestFactory(metaHeaders), endpoint)
        if err2 != nil </span><span class="cov0" title="0">{
                return err2
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                reposLen := len(srv.runtime.repositories.Repositories[localName])
                out.Write(sf.FormatStatus("", "The push refers to a repository [%s] (len: %d)", localName, reposLen))
                // If it fails, try to get the repository
                if localRepo, exists := srv.runtime.repositories.Repositories[localName]; exists </span><span class="cov0" title="0">{
                        if err := srv.pushRepository(r, out, localName, remoteName, localRepo, sf); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">var token []string
        out.Write(sf.FormatStatus("", "The push refers to an image: [%s]", localName))
        if _, err := srv.pushImage(r, out, remoteName, img.ID, endpoint, token, sf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) ImageImport(src, repo, tag string, in io.Reader, out io.Writer, sf *utils.StreamFormatter) error <span class="cov0" title="0">{
        var archive io.Reader
        var resp *http.Response

        if src == "-" </span><span class="cov0" title="0">{
                archive = in
        }</span> <span class="cov0" title="0">else {
                u, err := url.Parse(src)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if u.Scheme == "" </span><span class="cov0" title="0">{
                        u.Scheme = "http"
                        u.Host = src
                        u.Path = ""
                }</span>
                <span class="cov0" title="0">out.Write(sf.FormatStatus("", "Downloading from %s", u))
                // Download with curl (pretty progress bar)
                // If curl is not available, fallback to http.Get()
                resp, err = utils.Download(u.String())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">archive = utils.ProgressReader(resp.Body, int(resp.ContentLength), out, sf, true, "", "Importing")</span>
        }
        <span class="cov0" title="0">img, err := srv.runtime.graph.Create(archive, nil, "Imported from "+src, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Optionally register the image at REPO/TAG
        <span class="cov0" title="0">if repo != "" </span><span class="cov0" title="0">{
                if err := srv.runtime.repositories.Set(repo, tag, img.ID, true); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">out.Write(sf.FormatStatus("", img.ID))
        return nil</span>
}

func (srv *Server) ContainerCreate(job *engine.Job) engine.Status <span class="cov0" title="0">{
        var name string
        if len(job.Args) == 1 </span><span class="cov0" title="0">{
                name = job.Args[0]
        }</span> <span class="cov0" title="0">else if len(job.Args) &gt; 1 </span><span class="cov0" title="0">{
                job.Printf("Usage: %s", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">var config Config
        if err := job.ExportEnv(&amp;config); err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if config.Memory != 0 &amp;&amp; config.Memory &lt; 524288 </span><span class="cov0" title="0">{
                job.Errorf("Minimum memory limit allowed is 512k")
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if config.Memory &gt; 0 &amp;&amp; !srv.runtime.capabilities.MemoryLimit </span><span class="cov0" title="0">{
                config.Memory = 0
        }</span>
        <span class="cov0" title="0">if config.Memory &gt; 0 &amp;&amp; !srv.runtime.capabilities.SwapLimit </span><span class="cov0" title="0">{
                config.MemorySwap = -1
        }</span>
        <span class="cov0" title="0">container, buildWarnings, err := srv.runtime.Create(&amp;config, name)
        if err != nil </span><span class="cov0" title="0">{
                if srv.runtime.graph.IsNotExist(err) </span><span class="cov0" title="0">{
                        _, tag := utils.ParseRepositoryTag(config.Image)
                        if tag == "" </span><span class="cov0" title="0">{
                                tag = DEFAULTTAG
                        }</span>
                        <span class="cov0" title="0">job.Errorf("No such image: %s (tag: %s)", config.Image, tag)
                        return engine.StatusErr</span>
                }
                <span class="cov0" title="0">job.Error(err)
                return engine.StatusErr</span>
        }
        <span class="cov0" title="0">srv.LogEvent("create", container.ID, srv.runtime.repositories.ImageName(container.Image))
        // FIXME: this is necessary because runtime.Create might return a nil container
        // with a non-nil error. This should not happen! Once it's fixed we
        // can remove this workaround.
        if container != nil </span><span class="cov0" title="0">{
                job.Printf("%s\n", container.ID)
        }</span>
        <span class="cov0" title="0">for _, warning := range buildWarnings </span><span class="cov0" title="0">{
                job.Errorf("%s\n", warning)
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

func (srv *Server) ContainerRestart(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 1 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s CONTAINER\n", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        t := job.GetenvInt("t")
        if t == -1 </span><span class="cov0" title="0">{
                t = 10
        }</span>
        <span class="cov0" title="0">if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                if err := container.Restart(int(t)); err != nil </span><span class="cov0" title="0">{
                        job.Errorf("Cannot restart container %s: %s\n", name, err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">srv.LogEvent("restart", container.ID, srv.runtime.repositories.ImageName(container.Image))</span>
        } <span class="cov0" title="0">else {
                job.Errorf("No such container: %s\n", name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>

}

func (srv *Server) ContainerDestroy(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 1 </span><span class="cov0" title="0">{
                job.Errorf("Not enough arguments. Usage: %s CONTAINER\n", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        removeVolume := job.GetenvBool("removeVolume")
        removeLink := job.GetenvBool("removeLink")

        container := srv.runtime.Get(name)

        if removeLink </span><span class="cov0" title="0">{
                if container == nil </span><span class="cov0" title="0">{
                        job.Errorf("No such link: %s", name)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">name, err := getFullName(name)
                if err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">parent, n := path.Split(name)
                if parent == "/" </span><span class="cov0" title="0">{
                        job.Errorf("Conflict, cannot remove the default name of the container")
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">pe := srv.runtime.containerGraph.Get(parent)
                if pe == nil </span><span class="cov0" title="0">{
                        job.Errorf("Cannot get parent %s for name %s", parent, name)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">parentContainer := srv.runtime.Get(pe.ID())

                if parentContainer != nil &amp;&amp; parentContainer.activeLinks != nil </span><span class="cov0" title="0">{
                        if link, exists := parentContainer.activeLinks[n]; exists </span><span class="cov0" title="0">{
                                link.Disable()
                        }</span> <span class="cov0" title="0">else {
                                utils.Debugf("Could not find active link for %s", name)
                        }</span>
                }

                <span class="cov0" title="0">if err := srv.runtime.containerGraph.Delete(name); err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">return engine.StatusOK</span>
        }

        <span class="cov0" title="0">if container != nil </span><span class="cov0" title="0">{
                if container.State.IsRunning() </span><span class="cov0" title="0">{
                        job.Errorf("Impossible to remove a running container, please stop it first")
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">volumes := make(map[string]struct{})

                binds := make(map[string]struct{})

                for _, bind := range container.hostConfig.Binds </span><span class="cov0" title="0">{
                        splitBind := strings.Split(bind, ":")
                        source := splitBind[0]
                        binds[source] = struct{}{}
                }</span>

                // Store all the deleted containers volumes
                <span class="cov0" title="0">for _, volumeId := range container.Volumes </span><span class="cov0" title="0">{

                        // Skip the volumes mounted from external
                        if _, exists := binds[volumeId]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">volumeId = strings.TrimSuffix(volumeId, "/layer")
                        volumeId = filepath.Base(volumeId)
                        volumes[volumeId] = struct{}{}</span>
                }
                <span class="cov0" title="0">if err := srv.runtime.Destroy(container); err != nil </span><span class="cov0" title="0">{
                        job.Errorf("Cannot destroy container %s: %s", name, err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">srv.LogEvent("destroy", container.ID, srv.runtime.repositories.ImageName(container.Image))

                if removeVolume </span><span class="cov0" title="0">{
                        // Retrieve all volumes from all remaining containers
                        usedVolumes := make(map[string]*Container)
                        for _, container := range srv.runtime.List() </span><span class="cov0" title="0">{
                                for _, containerVolumeId := range container.Volumes </span><span class="cov0" title="0">{
                                        usedVolumes[containerVolumeId] = container
                                }</span>
                        }

                        <span class="cov0" title="0">for volumeId := range volumes </span><span class="cov0" title="0">{
                                // If the requested volu
                                if c, exists := usedVolumes[volumeId]; exists </span><span class="cov0" title="0">{
                                        log.Printf("The volume %s is used by the container %s. Impossible to remove it. Skipping.\n", volumeId, c.ID)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err := srv.runtime.volumes.Delete(volumeId); err != nil </span><span class="cov0" title="0">{
                                        job.Error(err)
                                        return engine.StatusErr
                                }</span>
                        }
                }
        } <span class="cov0" title="0">else {
                job.Errorf("No such container: %s", name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

var ErrImageReferenced = errors.New("Image referenced by a repository")

func (srv *Server) deleteImageAndChildren(id string, imgs *[]APIRmi, byParents map[string][]*Image) error <span class="cov0" title="0">{
        // If the image is referenced by a repo, do not delete
        if len(srv.runtime.repositories.ByID()[id]) != 0 </span><span class="cov0" title="0">{
                return ErrImageReferenced
        }</span>
        // If the image is not referenced but has children, go recursive
        <span class="cov0" title="0">referenced := false
        for _, img := range byParents[id] </span><span class="cov0" title="0">{
                if err := srv.deleteImageAndChildren(img.ID, imgs, byParents); err != nil </span><span class="cov0" title="0">{
                        if err != ErrImageReferenced </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">referenced = true</span>
                }
        }
        <span class="cov0" title="0">if referenced </span><span class="cov0" title="0">{
                return ErrImageReferenced
        }</span>

        // If the image is not referenced and has no children, remove it
        <span class="cov0" title="0">byParents, err := srv.runtime.graph.ByParent()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(byParents[id]) == 0 &amp;&amp; srv.canDeleteImage(id) == nil </span><span class="cov0" title="0">{
                if err := srv.runtime.repositories.DeleteAll(id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err := srv.runtime.graph.Delete(id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*imgs = append(*imgs, APIRmi{Deleted: id})
                srv.LogEvent("delete", id, "")
                return nil</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) deleteImageParents(img *Image, imgs *[]APIRmi) error <span class="cov0" title="0">{
        if img.Parent != "" </span><span class="cov0" title="0">{
                parent, err := srv.runtime.graph.Get(img.Parent)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">byParents, err := srv.runtime.graph.ByParent()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Remove all children images
                <span class="cov0" title="0">if err := srv.deleteImageAndChildren(img.Parent, imgs, byParents); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return srv.deleteImageParents(parent, imgs)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) deleteImage(img *Image, repoName, tag string) ([]APIRmi, error) <span class="cov0" title="0">{
        var (
                imgs = []APIRmi{}
                tags = []string{}
        )

        //If delete by id, see if the id belong only to one repository
        if repoName == "" </span><span class="cov0" title="0">{
                for _, repoAndTag := range srv.runtime.repositories.ByID()[img.ID] </span><span class="cov0" title="0">{
                        parsedRepo, parsedTag := utils.ParseRepositoryTag(repoAndTag)
                        if repoName == "" || repoName == parsedRepo </span><span class="cov0" title="0">{
                                repoName = parsedRepo
                                if parsedTag != "" </span><span class="cov0" title="0">{
                                        tags = append(tags, parsedTag)
                                }</span>
                        } <span class="cov0" title="0">else if repoName != parsedRepo </span><span class="cov0" title="0">{
                                // the id belongs to multiple repos, like base:latest and user:test,
                                // in that case return conflict
                                return nil, fmt.Errorf("Conflict, cannot delete image %s because it is tagged in multiple repositories", utils.TruncateID(img.ID))
                        }</span>
                }
        } <span class="cov0" title="0">else {
                tags = append(tags, tag)
        }</span>

        //Untag the current image
        <span class="cov0" title="0">for _, tag := range tags </span><span class="cov0" title="0">{
                tagDeleted, err := srv.runtime.repositories.Delete(repoName, tag)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if tagDeleted </span><span class="cov0" title="0">{
                        imgs = append(imgs, APIRmi{Untagged: img.ID})
                        srv.LogEvent("untag", img.ID, "")
                }</span>
        }

        <span class="cov0" title="0">if len(srv.runtime.repositories.ByID()[img.ID]) == 0 </span><span class="cov0" title="0">{
                if err := srv.deleteImageAndChildren(img.ID, &amp;imgs, nil); err != nil </span><span class="cov0" title="0">{
                        if err != ErrImageReferenced </span><span class="cov0" title="0">{
                                return imgs, err
                        }</span>
                } <span class="cov0" title="0">else if err := srv.deleteImageParents(img, &amp;imgs); err != nil </span><span class="cov0" title="0">{
                        if err != ErrImageReferenced </span><span class="cov0" title="0">{
                                return imgs, err
                        }</span>
                }
        }
        <span class="cov0" title="0">return imgs, nil</span>
}

func (srv *Server) ImageDelete(name string, autoPrune bool) ([]APIRmi, error) <span class="cov0" title="0">{
        var (
                repository, tag string
                img, err        = srv.runtime.repositories.LookupImage(name)
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("No such image: %s", name)
        }</span>

        // FIXME: What does autoPrune mean ?
        <span class="cov0" title="0">if !autoPrune </span><span class="cov0" title="0">{
                if err := srv.runtime.graph.Delete(img.ID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Cannot delete image %s: %s", name, err)
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }

        <span class="cov0" title="0">if !strings.Contains(img.ID, name) </span><span class="cov0" title="0">{
                repository, tag = utils.ParseRepositoryTag(name)
        }</span>

        // If we have a repo and the image is not referenced anywhere else
        // then just perform an untag and do not validate.
        //
        // i.e. only validate if we are performing an actual delete and not
        // an untag op
        <span class="cov0" title="0">if repository != "" &amp;&amp; len(srv.runtime.repositories.ByID()[img.ID]) == 1 </span><span class="cov0" title="0">{
                // Prevent deletion if image is used by a container
                if err := srv.canDeleteImage(img.ID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return srv.deleteImage(img, repository, tag)</span>
}

func (srv *Server) canDeleteImage(imgID string) error <span class="cov0" title="0">{
        for _, container := range srv.runtime.List() </span><span class="cov0" title="0">{
                parent, err := srv.runtime.repositories.LookupImage(container.Image)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := parent.WalkHistory(func(p *Image) error {
                        if imgID == p.ID {
                                return fmt.Errorf("Conflict, cannot delete %s because the container %s is using it", utils.TruncateID(imgID), utils.TruncateID(container.ID))
                        }
                        return nil
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) ImageGetCached(imgID string, config *Config) (*Image, error) <span class="cov0" title="0">{

        // Retrieve all images
        images, err := srv.runtime.graph.Map()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store the tree in a map of map (map[parentId][childId])
        <span class="cov0" title="0">imageMap := make(map[string]map[string]struct{})
        for _, img := range images </span><span class="cov0" title="0">{
                if _, exists := imageMap[img.Parent]; !exists </span><span class="cov0" title="0">{
                        imageMap[img.Parent] = make(map[string]struct{})
                }</span>
                <span class="cov0" title="0">imageMap[img.Parent][img.ID] = struct{}{}</span>
        }

        // Loop on the children of the given image and check the config
        <span class="cov0" title="0">var match *Image
        for elem := range imageMap[imgID] </span><span class="cov0" title="0">{
                img, err := srv.runtime.graph.Get(elem)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if CompareConfig(&amp;img.ContainerConfig, config) </span><span class="cov0" title="0">{
                        if match == nil || match.Created.Before(img.Created) </span><span class="cov0" title="0">{
                                match = img
                        }</span>
                }
        }
        <span class="cov0" title="0">return match, nil</span>
}

func (srv *Server) RegisterLinks(container *Container, hostConfig *HostConfig) error <span class="cov0" title="0">{
        runtime := srv.runtime

        if hostConfig != nil &amp;&amp; hostConfig.Links != nil </span><span class="cov0" title="0">{
                for _, l := range hostConfig.Links </span><span class="cov0" title="0">{
                        parts, err := parseLink(l)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">child, err := srv.runtime.GetByName(parts["name"])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if child == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Could not get container for %s", parts["name"])
                        }</span>
                        <span class="cov0" title="0">if err := runtime.RegisterLink(container, child, parts["alias"]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // After we load all the links into the runtime
                // set them to nil on the hostconfig
                <span class="cov0" title="0">hostConfig.Links = nil
                if err := container.writeHostConfig(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) ContainerStart(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) &lt; 1 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s container_id", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        runtime := srv.runtime
        container := runtime.Get(name)

        if container == nil </span><span class="cov0" title="0">{
                job.Errorf("No such container: %s", name)
                return engine.StatusErr
        }</span>
        // If no environment was set, then no hostconfig was passed.
        <span class="cov0" title="0">if len(job.Environ()) &gt; 0 </span><span class="cov0" title="0">{
                var hostConfig HostConfig
                if err := job.ExportEnv(&amp;hostConfig); err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
                // Validate the HostConfig binds. Make sure that:
                // 1) the source of a bind mount isn't /
                //         The bind mount "/:/foo" isn't allowed.
                // 2) Check that the source exists
                //        The source to be bind mounted must exist.
                <span class="cov0" title="0">for _, bind := range hostConfig.Binds </span><span class="cov0" title="0">{
                        splitBind := strings.Split(bind, ":")
                        source := splitBind[0]

                        // refuse to bind mount "/" to the container
                        if source == "/" </span><span class="cov0" title="0">{
                                job.Errorf("Invalid bind mount '%s' : source can't be '/'", bind)
                                return engine.StatusErr
                        }</span>

                        // ensure the source exists on the host
                        <span class="cov0" title="0">_, err := os.Stat(source)
                        if err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov0" title="0">{
                                job.Errorf("Invalid bind mount '%s' : source doesn't exist", bind)
                                return engine.StatusErr
                        }</span>
                }
                // Register any links from the host config before starting the container
                <span class="cov0" title="0">if err := srv.RegisterLinks(container, &amp;hostConfig); err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">container.hostConfig = &amp;hostConfig
                container.ToDisk()</span>
        }
        <span class="cov0" title="0">if err := container.Start(); err != nil </span><span class="cov0" title="0">{
                job.Errorf("Cannot start container %s: %s", name, err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">srv.LogEvent("start", container.ID, runtime.repositories.ImageName(container.Image))

        return engine.StatusOK</span>
}

func (srv *Server) ContainerStop(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 1 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s CONTAINER\n", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        t := job.GetenvInt("t")
        if t == -1 </span><span class="cov0" title="0">{
                t = 10
        }</span>
        <span class="cov0" title="0">if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                if err := container.Stop(int(t)); err != nil </span><span class="cov0" title="0">{
                        job.Errorf("Cannot stop container %s: %s\n", name, err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">srv.LogEvent("stop", container.ID, srv.runtime.repositories.ImageName(container.Image))</span>
        } <span class="cov0" title="0">else {
                job.Errorf("No such container: %s\n", name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

func (srv *Server) ContainerWait(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 1 </span><span class="cov0" title="0">{
                job.Errorf("Usage: %s", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                status := container.Wait()
                job.Printf("%d\n", status)
                return engine.StatusOK
        }</span>
        <span class="cov0" title="0">job.Errorf("%s: no such container: %s", job.Name, name)
        return engine.StatusErr</span>
}

func (srv *Server) ContainerResize(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if len(job.Args) != 3 </span><span class="cov0" title="0">{
                job.Errorf("Not enough arguments. Usage: %s CONTAINER HEIGHT WIDTH\n", job.Name)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">name := job.Args[0]
        height, err := strconv.Atoi(job.Args[1])
        if err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">width, err := strconv.Atoi(job.Args[2])
        if err != nil </span><span class="cov0" title="0">{
                job.Error(err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                if err := container.Resize(height, width); err != nil </span><span class="cov0" title="0">{
                        job.Error(err)
                        return engine.StatusErr
                }</span>
                <span class="cov0" title="0">return engine.StatusOK</span>
        }
        <span class="cov0" title="0">job.Errorf("No such container: %s", name)
        return engine.StatusErr</span>
}

func (srv *Server) ContainerAttach(name string, logs, stream, stdin, stdout, stderr bool, inStream io.ReadCloser, outStream, errStream io.Writer) error <span class="cov0" title="0">{
        container := srv.runtime.Get(name)
        if container == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("No such container: %s", name)
        }</span>

        //logs
        <span class="cov0" title="0">if logs </span><span class="cov0" title="0">{
                cLog, err := container.ReadLog("json")
                if err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Legacy logs
                        utils.Errorf("Old logs format")
                        if stdout </span><span class="cov0" title="0">{
                                cLog, err := container.ReadLog("stdout")
                                if err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("Error reading logs (stdout): %s", err)
                                }</span> <span class="cov0" title="0">else if _, err := io.Copy(outStream, cLog); err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("Error streaming logs (stdout): %s", err)
                                }</span>
                        }
                        <span class="cov0" title="0">if stderr </span><span class="cov0" title="0">{
                                cLog, err := container.ReadLog("stderr")
                                if err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("Error reading logs (stderr): %s", err)
                                }</span> <span class="cov0" title="0">else if _, err := io.Copy(errStream, cLog); err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("Error streaming logs (stderr): %s", err)
                                }</span>
                        }
                } <span class="cov0" title="0">else if err != nil </span><span class="cov0" title="0">{
                        utils.Errorf("Error reading logs (json): %s", err)
                }</span> <span class="cov0" title="0">else {
                        dec := json.NewDecoder(cLog)
                        for </span><span class="cov0" title="0">{
                                l := &amp;utils.JSONLog{}

                                if err := dec.Decode(l); err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                } <span class="cov0" title="0">else if err != nil </span><span class="cov0" title="0">{
                                        utils.Errorf("Error streaming logs: %s", err)
                                        break</span>
                                }
                                <span class="cov0" title="0">if l.Stream == "stdout" &amp;&amp; stdout </span><span class="cov0" title="0">{
                                        fmt.Fprintf(outStream, "%s", l.Log)
                                }</span>
                                <span class="cov0" title="0">if l.Stream == "stderr" &amp;&amp; stderr </span><span class="cov0" title="0">{
                                        fmt.Fprintf(errStream, "%s", l.Log)
                                }</span>
                        }
                }
        }

        //stream
        <span class="cov0" title="0">if stream </span><span class="cov0" title="0">{
                if container.State.IsGhost() </span><span class="cov0" title="0">{
                        return fmt.Errorf("Impossible to attach to a ghost container")
                }</span>

                <span class="cov0" title="0">var (
                        cStdin           io.ReadCloser
                        cStdout, cStderr io.Writer
                        cStdinCloser     io.Closer
                )

                if stdin </span><span class="cov0" title="0">{
                        r, w := io.Pipe()
                        go func() </span><span class="cov0" title="0">{
                                defer w.Close()
                                defer utils.Debugf("Closing buffered stdin pipe")
                                io.Copy(w, inStream)
                        }</span>()
                        <span class="cov0" title="0">cStdin = r
                        cStdinCloser = inStream</span>
                }
                <span class="cov0" title="0">if stdout </span><span class="cov0" title="0">{
                        cStdout = outStream
                }</span>
                <span class="cov0" title="0">if stderr </span><span class="cov0" title="0">{
                        cStderr = errStream
                }</span>

                <span class="cov0" title="0">&lt;-container.Attach(cStdin, cStdinCloser, cStdout, cStderr)

                // If we are in stdinonce mode, wait for the process to end
                // otherwise, simply return
                if container.Config.StdinOnce &amp;&amp; !container.Config.Tty </span><span class="cov0" title="0">{
                        container.Wait()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (srv *Server) ContainerInspect(name string) (*Container, error) <span class="cov0" title="0">{
        if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{
                return container, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("No such container: %s", name)</span>
}

func (srv *Server) ImageInspect(name string) (*Image, error) <span class="cov0" title="0">{
        if image, err := srv.runtime.repositories.LookupImage(name); err == nil &amp;&amp; image != nil </span><span class="cov0" title="0">{
                return image, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("No such image: %s", name)</span>
}

func (srv *Server) ContainerCopy(name string, resource string, out io.Writer) error <span class="cov0" title="0">{
        if container := srv.runtime.Get(name); container != nil </span><span class="cov0" title="0">{

                data, err := container.Copy(resource)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := io.Copy(out, data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("No such container: %s", name)</span>

}

func NewServer(eng *engine.Engine, config *DaemonConfig) (*Server, error) <span class="cov0" title="0">{
        runtime, err := NewRuntime(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">srv := &amp;Server{
                Eng:         eng,
                runtime:     runtime,
                pullingPool: make(map[string]chan struct{}),
                pushingPool: make(map[string]chan struct{}),
                events:      make([]utils.JSONMessage, 0, 64), //only keeps the 64 last events
                listeners:   make(map[string]chan utils.JSONMessage),
        }
        runtime.srv = srv
        return srv, nil</span>
}

func (srv *Server) HTTPRequestFactory(metaHeaders map[string][]string) *utils.HTTPRequestFactory <span class="cov0" title="0">{
        srv.Lock()
        defer srv.Unlock()
        v := dockerVersion()
        httpVersion := make([]utils.VersionInfo, 0, 4)
        httpVersion = append(httpVersion, &amp;simpleVersionInfo{"docker", v.Get("Version")})
        httpVersion = append(httpVersion, &amp;simpleVersionInfo{"go", v.Get("GoVersion")})
        httpVersion = append(httpVersion, &amp;simpleVersionInfo{"git-commit", v.Get("GitCommit")})
        httpVersion = append(httpVersion, &amp;simpleVersionInfo{"kernel", v.Get("KernelVersion")})
        httpVersion = append(httpVersion, &amp;simpleVersionInfo{"os", v.Get("Os")})
        httpVersion = append(httpVersion, &amp;simpleVersionInfo{"arch", v.Get("Arch")})
        ud := utils.NewHTTPUserAgentDecorator(httpVersion...)
        md := &amp;utils.HTTPMetaHeadersDecorator{
                Headers: metaHeaders,
        }
        factory := utils.NewHTTPRequestFactory(ud, md)
        return factory
}</span>

func (srv *Server) LogEvent(action, id, from string) *utils.JSONMessage <span class="cov8" title="1">{
        now := time.Now().UTC().Unix()
        jm := utils.JSONMessage{Status: action, ID: id, From: from, Time: now}
        srv.AddEvent(jm)
        for _, c := range srv.listeners </span><span class="cov8" title="1">{
                select </span>{ // non blocking channel
                <span class="cov8" title="1">case c &lt;- jm:</span>
                <span class="cov8" title="1">default:</span>
                }
        }
        <span class="cov8" title="1">return &amp;jm</span>
}

func (srv *Server) AddEvent(jm utils.JSONMessage) <span class="cov8" title="1">{
        srv.Lock()
        defer srv.Unlock()
        srv.events = append(srv.events, jm)
}</span>

func (srv *Server) GetEvents() []utils.JSONMessage <span class="cov8" title="1">{
        srv.RLock()
        defer srv.RUnlock()
        return srv.events
}</span>

type Server struct {
        sync.RWMutex
        runtime     *Runtime
        pullingPool map[string]chan struct{}
        pushingPool map[string]chan struct{}
        events      []utils.JSONMessage
        listeners   map[string]chan utils.JSONMessage
        Eng         *engine.Engine
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package docker

import "sort"

type imageSorter struct {
        images []APIImages
        by     func(i1, i2 *APIImages) bool // Closure used in the Less method.
}

// Len is part of sort.Interface.
func (s *imageSorter) Len() int <span class="cov0" title="0">{
        return len(s.images)
}</span>

// Swap is part of sort.Interface.
func (s *imageSorter) Swap(i, j int) <span class="cov0" title="0">{
        s.images[i], s.images[j] = s.images[j], s.images[i]
}</span>

// Less is part of sort.Interface. It is implemented by calling the "by" closure in the sorter.
func (s *imageSorter) Less(i, j int) bool <span class="cov0" title="0">{
        return s.by(&amp;s.images[i], &amp;s.images[j])
}</span>

// Sort []ApiImages by most recent creation date and tag name.
func sortImagesByCreationAndTag(images []APIImages) <span class="cov0" title="0">{
        creationAndTag := func(i1, i2 *APIImages) bool </span><span class="cov0" title="0">{
                return i1.Created &gt; i2.Created
        }</span>

        <span class="cov0" title="0">sorter := &amp;imageSorter{
                images: images,
                by:     creationAndTag}

        sort.Sort(sorter)</span>
}

type portSorter struct {
        ports []Port
        by    func(i, j Port) bool
}

func (s *portSorter) Len() int <span class="cov8" title="1">{
        return len(s.ports)
}</span>

func (s *portSorter) Swap(i, j int) <span class="cov8" title="1">{
        s.ports[i], s.ports[j] = s.ports[j], s.ports[i]
}</span>

func (s *portSorter) Less(i, j int) bool <span class="cov8" title="1">{
        ip := s.ports[i]
        jp := s.ports[j]

        return s.by(ip, jp)
}</span>

func sortPorts(ports []Port, predicate func(i, j Port) bool) <span class="cov8" title="1">{
        s := &amp;portSorter{ports, predicate}
        sort.Sort(s)
}</span>

type containerSorter struct {
        containers []*Container
        by         func(i, j *Container) bool
}

func (s *containerSorter) Len() int <span class="cov0" title="0">{
        return len(s.containers)
}</span>

func (s *containerSorter) Swap(i, j int) <span class="cov0" title="0">{
        s.containers[i], s.containers[j] = s.containers[j], s.containers[i]
}</span>

func (s *containerSorter) Less(i, j int) bool <span class="cov0" title="0">{
        return s.by(s.containers[i], s.containers[j])
}</span>

func sortContainers(containers []*Container, predicate func(i, j *Container) bool) <span class="cov0" title="0">{
        s := &amp;containerSorter{containers, predicate}
        sort.Sort(s)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package docker

import (
        "fmt"
        "github.com/dotcloud/docker/utils"
        "sync"
        "time"
)

type State struct {
        sync.RWMutex
        Running    bool
        Pid        int
        ExitCode   int
        StartedAt  time.Time
        FinishedAt time.Time
        Ghost      bool
}

// String returns a human-readable description of the state
func (s *State) String() string <span class="cov0" title="0">{
        s.RLock()
        defer s.RUnlock()

        if s.Running </span><span class="cov0" title="0">{
                if s.Ghost </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Ghost")
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Up %s", utils.HumanDuration(time.Now().UTC().Sub(s.StartedAt)))</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("Exit %d", s.ExitCode)</span>
}

func (s *State) IsRunning() bool <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()

        return s.Running
}</span>

func (s *State) IsGhost() bool <span class="cov0" title="0">{
        s.RLock()
        defer s.RUnlock()

        return s.Ghost
}</span>

func (s *State) GetExitCode() int <span class="cov0" title="0">{
        s.RLock()
        defer s.RUnlock()

        return s.ExitCode
}</span>

func (s *State) SetGhost(val bool) <span class="cov0" title="0">{
        s.Lock()
        defer s.Unlock()

        s.Ghost = val
}</span>

func (s *State) SetRunning(pid int) <span class="cov0" title="0">{
        s.Lock()
        defer s.Unlock()

        s.Running = true
        s.Ghost = false
        s.ExitCode = 0
        s.Pid = pid
        s.StartedAt = time.Now().UTC()
}</span>

func (s *State) SetStopped(exitCode int) <span class="cov0" title="0">{
        s.Lock()
        defer s.Unlock()

        s.Running = false
        s.Pid = 0
        s.FinishedAt = time.Now().UTC()
        s.ExitCode = exitCode
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package docker

import (
        "encoding/json"
        "fmt"
        "github.com/dotcloud/docker/utils"
        "io/ioutil"
        "os"
        "path/filepath"
        "sort"
        "strings"
)

const DEFAULTTAG = "latest"

type TagStore struct {
        path         string
        graph        *Graph
        Repositories map[string]Repository
}

type Repository map[string]string

func NewTagStore(path string, graph *Graph) (*TagStore, error) <span class="cov8" title="1">{
        abspath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">store := &amp;TagStore{
                path:         abspath,
                graph:        graph,
                Repositories: make(map[string]Repository),
        }
        // Load the json file if it exists, otherwise create it.
        if err := store.Reload(); os.IsNotExist(err) </span><span class="cov8" title="1">{
                if err := store.Save(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } <span class="cov0" title="0">else if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return store, nil</span>
}

func (store *TagStore) Save() error <span class="cov8" title="1">{
        // Store the json ball
        jsonData, err := json.Marshal(store)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ioutil.WriteFile(store.path, jsonData, 0600); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (store *TagStore) Reload() error <span class="cov8" title="1">{
        jsonData, err := ioutil.ReadFile(store.path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(jsonData, store); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (store *TagStore) LookupImage(name string) (*Image, error) <span class="cov8" title="1">{
        // FIXME: standardize on returning nil when the image doesn't exist, and err for everything else
        // (so we can pass all errors here)
        repos, tag := utils.ParseRepositoryTag(name)
        if tag == "" </span><span class="cov8" title="1">{
                tag = DEFAULTTAG
        }</span>
        <span class="cov8" title="1">img, err := store.GetImage(repos, tag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> <span class="cov8" title="1">else if img == nil </span><span class="cov8" title="1">{
                if img, err = store.graph.Get(name); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return img, nil</span>
}

// Return a reverse-lookup table of all the names which refer to each image
// Eg. {"43b5f19b10584": {"base:latest", "base:v1"}}
func (store *TagStore) ByID() map[string][]string <span class="cov0" title="0">{
        byID := make(map[string][]string)
        for repoName, repository := range store.Repositories </span><span class="cov0" title="0">{
                for tag, id := range repository </span><span class="cov0" title="0">{
                        name := repoName + ":" + tag
                        if _, exists := byID[id]; !exists </span><span class="cov0" title="0">{
                                byID[id] = []string{name}
                        }</span> <span class="cov0" title="0">else {
                                byID[id] = append(byID[id], name)
                                sort.Strings(byID[id])
                        }</span>
                }
        }
        <span class="cov0" title="0">return byID</span>
}

func (store *TagStore) ImageName(id string) string <span class="cov0" title="0">{
        if names, exists := store.ByID()[id]; exists &amp;&amp; len(names) &gt; 0 </span><span class="cov0" title="0">{
                return names[0]
        }</span>
        <span class="cov0" title="0">return utils.TruncateID(id)</span>
}

func (store *TagStore) DeleteAll(id string) error <span class="cov0" title="0">{
        names, exists := store.ByID()[id]
        if !exists || len(names) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for _, name := range names </span><span class="cov0" title="0">{
                if strings.Contains(name, ":") </span><span class="cov0" title="0">{
                        nameParts := strings.Split(name, ":")
                        if _, err := store.Delete(nameParts[0], nameParts[1]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } <span class="cov0" title="0">else {
                        if _, err := store.Delete(name, ""); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (store *TagStore) Delete(repoName, tag string) (bool, error) <span class="cov0" title="0">{
        deleted := false
        if err := store.Reload(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if r, exists := store.Repositories[repoName]; exists </span><span class="cov0" title="0">{
                if tag != "" </span><span class="cov0" title="0">{
                        if _, exists2 := r[tag]; exists2 </span><span class="cov0" title="0">{
                                delete(r, tag)
                                if len(r) == 0 </span><span class="cov0" title="0">{
                                        delete(store.Repositories, repoName)
                                }</span>
                                <span class="cov0" title="0">deleted = true</span>
                        } <span class="cov0" title="0">else {
                                return false, fmt.Errorf("No such tag: %s:%s", repoName, tag)
                        }</span>
                } <span class="cov0" title="0">else {
                        delete(store.Repositories, repoName)
                        deleted = true
                }</span>
        } <span class="cov0" title="0">else {
                fmt.Errorf("No such repository: %s", repoName)
        }</span>
        <span class="cov0" title="0">return deleted, store.Save()</span>
}

func (store *TagStore) Set(repoName, tag, imageName string, force bool) error <span class="cov8" title="1">{
        img, err := store.LookupImage(imageName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if tag == "" </span><span class="cov8" title="1">{
                tag = DEFAULTTAG
        }</span>
        <span class="cov8" title="1">if err := validateRepoName(repoName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateTagName(tag); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := store.Reload(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var repo Repository
        if r, exists := store.Repositories[repoName]; exists </span><span class="cov0" title="0">{
                repo = r
        }</span> <span class="cov8" title="1">else {
                repo = make(map[string]string)
                if old, exists := store.Repositories[repoName]; exists &amp;&amp; !force </span><span class="cov0" title="0">{
                        return fmt.Errorf("Conflict: Tag %s:%s is already set to %s", repoName, tag, old)
                }</span>
                <span class="cov8" title="1">store.Repositories[repoName] = repo</span>
        }
        <span class="cov8" title="1">repo[tag] = img.ID
        return store.Save()</span>
}

func (store *TagStore) Get(repoName string) (Repository, error) <span class="cov8" title="1">{
        if err := store.Reload(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if r, exists := store.Repositories[repoName]; exists </span><span class="cov8" title="1">{
                return r, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (store *TagStore) GetImage(repoName, tagOrID string) (*Image, error) <span class="cov8" title="1">{
        repo, err := store.Get(repoName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> <span class="cov8" title="1">else if repo == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if revision, exists := repo[tagOrID]; exists </span><span class="cov8" title="1">{
                return store.graph.Get(revision)
        }</span>
        // If no matching tag is found, search through images for a matching image id
        <span class="cov8" title="1">for _, revision := range repo </span><span class="cov8" title="1">{
                if strings.HasPrefix(revision, tagOrID) </span><span class="cov8" title="1">{
                        return store.graph.Get(revision)
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// Validate the name of a repository
func validateRepoName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Repository name can't be empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate the name of a tag
func validateTagName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Tag name can't be empty")
        }</span>
        <span class="cov8" title="1">if strings.Contains(name, "/") || strings.Contains(name, ":") </span><span class="cov0" title="0">{
                return fmt.Errorf("Illegal tag name: %s", name)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package docker

import (
        "fmt"
        "github.com/dotcloud/docker/archive"
        "github.com/dotcloud/docker/pkg/namesgenerator"
        "github.com/dotcloud/docker/utils"
        "io/ioutil"
        "strconv"
        "strings"
)

type Change struct {
        archive.Change
}

// Compare two Config struct. Do not compare the "Image" nor "Hostname" fields
// If OpenStdin is set, then it differs
func CompareConfig(a, b *Config) bool <span class="cov8" title="1">{
        if a == nil || b == nil ||
                a.OpenStdin || b.OpenStdin </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if a.AttachStdout != b.AttachStdout ||
                a.AttachStderr != b.AttachStderr ||
                a.User != b.User ||
                a.Memory != b.Memory ||
                a.MemorySwap != b.MemorySwap ||
                a.CpuShares != b.CpuShares ||
                a.OpenStdin != b.OpenStdin ||
                a.Tty != b.Tty ||
                a.VolumesFrom != b.VolumesFrom </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(a.Cmd) != len(b.Cmd) ||
                len(a.Dns) != len(b.Dns) ||
                len(a.Env) != len(b.Env) ||
                len(a.PortSpecs) != len(b.PortSpecs) ||
                len(a.ExposedPorts) != len(b.ExposedPorts) ||
                len(a.Entrypoint) != len(b.Entrypoint) ||
                len(a.Volumes) != len(b.Volumes) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(a.Cmd); i++ </span><span class="cov0" title="0">{
                if a.Cmd[i] != b.Cmd[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(a.Dns); i++ </span><span class="cov8" title="1">{
                if a.Dns[i] != b.Dns[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(a.Env); i++ </span><span class="cov8" title="1">{
                if a.Env[i] != b.Env[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(a.PortSpecs); i++ </span><span class="cov8" title="1">{
                if a.PortSpecs[i] != b.PortSpecs[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for k := range a.ExposedPorts </span><span class="cov0" title="0">{
                if _, exists := b.ExposedPorts[k]; !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(a.Entrypoint); i++ </span><span class="cov0" title="0">{
                if a.Entrypoint[i] != b.Entrypoint[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for key := range a.Volumes </span><span class="cov8" title="1">{
                if _, exists := b.Volumes[key]; !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func MergeConfig(userConf, imageConf *Config) error <span class="cov8" title="1">{
        if userConf.User == "" </span><span class="cov8" title="1">{
                userConf.User = imageConf.User
        }</span>
        <span class="cov8" title="1">if userConf.Memory == 0 </span><span class="cov8" title="1">{
                userConf.Memory = imageConf.Memory
        }</span>
        <span class="cov8" title="1">if userConf.MemorySwap == 0 </span><span class="cov8" title="1">{
                userConf.MemorySwap = imageConf.MemorySwap
        }</span>
        <span class="cov8" title="1">if userConf.CpuShares == 0 </span><span class="cov8" title="1">{
                userConf.CpuShares = imageConf.CpuShares
        }</span>
        <span class="cov8" title="1">if userConf.ExposedPorts == nil || len(userConf.ExposedPorts) == 0 </span><span class="cov8" title="1">{
                userConf.ExposedPorts = imageConf.ExposedPorts
        }</span> <span class="cov8" title="1">else if imageConf.ExposedPorts != nil </span><span class="cov8" title="1">{
                if userConf.ExposedPorts == nil </span><span class="cov0" title="0">{
                        userConf.ExposedPorts = make(map[Port]struct{})
                }</span>
                <span class="cov8" title="1">for port := range imageConf.ExposedPorts </span><span class="cov8" title="1">{
                        if _, exists := userConf.ExposedPorts[port]; !exists </span><span class="cov8" title="1">{
                                userConf.ExposedPorts[port] = struct{}{}
                        }</span>
                }
        }

        <span class="cov8" title="1">if userConf.PortSpecs != nil &amp;&amp; len(userConf.PortSpecs) &gt; 0 </span><span class="cov8" title="1">{
                if userConf.ExposedPorts == nil </span><span class="cov8" title="1">{
                        userConf.ExposedPorts = make(map[Port]struct{})
                }</span>
                <span class="cov8" title="1">ports, _, err := parsePortSpecs(userConf.PortSpecs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for port := range ports </span><span class="cov8" title="1">{
                        if _, exists := userConf.ExposedPorts[port]; !exists </span><span class="cov8" title="1">{
                                userConf.ExposedPorts[port] = struct{}{}
                        }</span>
                }
                <span class="cov8" title="1">userConf.PortSpecs = nil</span>
        }
        <span class="cov8" title="1">if imageConf.PortSpecs != nil &amp;&amp; len(imageConf.PortSpecs) &gt; 0 </span><span class="cov8" title="1">{
                utils.Debugf("Migrating image port specs to containter: %s", strings.Join(imageConf.PortSpecs, ", "))
                if userConf.ExposedPorts == nil </span><span class="cov0" title="0">{
                        userConf.ExposedPorts = make(map[Port]struct{})
                }</span>

                <span class="cov8" title="1">ports, _, err := parsePortSpecs(imageConf.PortSpecs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for port := range ports </span><span class="cov8" title="1">{
                        if _, exists := userConf.ExposedPorts[port]; !exists </span><span class="cov8" title="1">{
                                userConf.ExposedPorts[port] = struct{}{}
                        }</span>
                }
        }
        <span class="cov8" title="1">if !userConf.Tty </span><span class="cov8" title="1">{
                userConf.Tty = imageConf.Tty
        }</span>
        <span class="cov8" title="1">if !userConf.OpenStdin </span><span class="cov8" title="1">{
                userConf.OpenStdin = imageConf.OpenStdin
        }</span>
        <span class="cov8" title="1">if !userConf.StdinOnce </span><span class="cov8" title="1">{
                userConf.StdinOnce = imageConf.StdinOnce
        }</span>
        <span class="cov8" title="1">if userConf.Env == nil || len(userConf.Env) == 0 </span><span class="cov0" title="0">{
                userConf.Env = imageConf.Env
        }</span> <span class="cov8" title="1">else {
                for _, imageEnv := range imageConf.Env </span><span class="cov8" title="1">{
                        found := false
                        imageEnvKey := strings.Split(imageEnv, "=")[0]
                        for _, userEnv := range userConf.Env </span><span class="cov8" title="1">{
                                userEnvKey := strings.Split(userEnv, "=")[0]
                                if imageEnvKey == userEnvKey </span><span class="cov8" title="1">{
                                        found = true
                                }</span>
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                userConf.Env = append(userConf.Env, imageEnv)
                        }</span>
                }
        }
        <span class="cov8" title="1">if userConf.Cmd == nil || len(userConf.Cmd) == 0 </span><span class="cov8" title="1">{
                userConf.Cmd = imageConf.Cmd
        }</span>
        <span class="cov8" title="1">if userConf.Dns == nil || len(userConf.Dns) == 0 </span><span class="cov0" title="0">{
                userConf.Dns = imageConf.Dns
        }</span> <span class="cov8" title="1">else {
                //duplicates aren't an issue here
                userConf.Dns = append(userConf.Dns, imageConf.Dns...)
        }</span>
        <span class="cov8" title="1">if userConf.Entrypoint == nil || len(userConf.Entrypoint) == 0 </span><span class="cov8" title="1">{
                userConf.Entrypoint = imageConf.Entrypoint
        }</span>
        <span class="cov8" title="1">if userConf.WorkingDir == "" </span><span class="cov8" title="1">{
                userConf.WorkingDir = imageConf.WorkingDir
        }</span>
        <span class="cov8" title="1">if userConf.VolumesFrom == "" </span><span class="cov8" title="1">{
                userConf.VolumesFrom = imageConf.VolumesFrom
        }</span>
        <span class="cov8" title="1">if userConf.Volumes == nil || len(userConf.Volumes) == 0 </span><span class="cov0" title="0">{
                userConf.Volumes = imageConf.Volumes
        }</span> <span class="cov8" title="1">else {
                for k, v := range imageConf.Volumes </span><span class="cov8" title="1">{
                        userConf.Volumes[k] = v
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func parseLxcConfOpts(opts ListOpts) ([]KeyValuePair, error) <span class="cov8" title="1">{
        out := make([]KeyValuePair, opts.Len())
        for i, o := range opts.GetAll() </span><span class="cov0" title="0">{
                k, v, err := parseLxcOpt(o)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out[i] = KeyValuePair{Key: k, Value: v}</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

func parseLxcOpt(opt string) (string, string, error) <span class="cov8" title="1">{
        parts := strings.SplitN(opt, "=", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("Unable to parse lxc conf option: %s", opt)
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1]), nil</span>
}

// FIXME: network related stuff (including parsing) should be grouped in network file
const (
        PortSpecTemplate       = "ip:hostPort:containerPort"
        PortSpecTemplateFormat = "ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort"
)

// We will receive port specs in the format of ip:public:private/proto and these need to be
// parsed in the internal types
func parsePortSpecs(ports []string) (map[Port]struct{}, map[Port][]PortBinding, error) <span class="cov8" title="1">{
        var (
                exposedPorts = make(map[Port]struct{}, len(ports))
                bindings     = make(map[Port][]PortBinding)
        )

        for _, rawPort := range ports </span><span class="cov8" title="1">{
                proto := "tcp"

                if i := strings.LastIndex(rawPort, "/"); i != -1 </span><span class="cov8" title="1">{
                        proto = rawPort[i+1:]
                        rawPort = rawPort[:i]
                }</span>
                <span class="cov8" title="1">if !strings.Contains(rawPort, ":") </span><span class="cov8" title="1">{
                        rawPort = fmt.Sprintf("::%s", rawPort)
                }</span> <span class="cov8" title="1">else if len(strings.Split(rawPort, ":")) == 2 </span><span class="cov8" title="1">{
                        rawPort = fmt.Sprintf(":%s", rawPort)
                }</span>

                <span class="cov8" title="1">parts, err := utils.PartParser(PortSpecTemplate, rawPort)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">var (
                        containerPort = parts["containerPort"]
                        rawIp         = parts["ip"]
                        hostPort      = parts["hostPort"]
                )

                if containerPort == "" </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("No port specified: %s&lt;empty&gt;", rawPort)
                }</span>
                <span class="cov8" title="1">if _, err := strconv.ParseUint(containerPort, 10, 16); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("Invalid containerPort: %s", containerPort)
                }</span>
                <span class="cov8" title="1">if _, err := strconv.ParseUint(hostPort, 10, 16); hostPort != "" &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("Invalid hostPort: %s", hostPort)
                }</span>

                <span class="cov8" title="1">port := NewPort(proto, containerPort)
                if _, exists := exposedPorts[port]; !exists </span><span class="cov8" title="1">{
                        exposedPorts[port] = struct{}{}
                }</span>

                <span class="cov8" title="1">binding := PortBinding{
                        HostIp:   rawIp,
                        HostPort: hostPort,
                }
                bslice, exists := bindings[port]
                if !exists </span><span class="cov8" title="1">{
                        bslice = []PortBinding{}
                }</span>
                <span class="cov8" title="1">bindings[port] = append(bslice, binding)</span>
        }
        <span class="cov8" title="1">return exposedPorts, bindings, nil</span>
}

// Splits a port in the format of port/proto
func splitProtoPort(rawPort string) (string, string) <span class="cov0" title="0">{
        parts := strings.Split(rawPort, "/")
        l := len(parts)
        if l == 0 </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov0" title="0">if l == 1 </span><span class="cov0" title="0">{
                return "tcp", rawPort
        }</span>
        <span class="cov0" title="0">return parts[0], parts[1]</span>
}

func parsePort(rawPort string) (int, error) <span class="cov8" title="1">{
        port, err := strconv.ParseUint(rawPort, 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return int(port), nil</span>
}

func migratePortMappings(config *Config, hostConfig *HostConfig) error <span class="cov0" title="0">{
        if config.PortSpecs != nil </span><span class="cov0" title="0">{
                ports, bindings, err := parsePortSpecs(config.PortSpecs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">config.PortSpecs = nil
                if len(bindings) &gt; 0 </span><span class="cov0" title="0">{
                        if hostConfig == nil </span><span class="cov0" title="0">{
                                hostConfig = &amp;HostConfig{}
                        }</span>
                        <span class="cov0" title="0">hostConfig.PortBindings = bindings</span>
                }

                <span class="cov0" title="0">if config.ExposedPorts == nil </span><span class="cov0" title="0">{
                        config.ExposedPorts = make(map[Port]struct{}, len(ports))
                }</span>
                <span class="cov0" title="0">for k, v := range ports </span><span class="cov0" title="0">{
                        config.ExposedPorts[k] = v
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Links come in the format of
// name:alias
func parseLink(rawLink string) (map[string]string, error) <span class="cov8" title="1">{
        return utils.PartParser("name:alias", rawLink)
}</span>

func RootIsShared() bool <span class="cov0" title="0">{
        if data, err := ioutil.ReadFile("/proc/self/mountinfo"); err == nil </span><span class="cov0" title="0">{
                for _, line := range strings.Split(string(data), "\n") </span><span class="cov0" title="0">{
                        cols := strings.Split(line, " ")
                        if len(cols) &gt;= 6 &amp;&amp; cols[4] == "/" </span><span class="cov0" title="0">{
                                return strings.HasPrefix(cols[6], "shared")
                        }</span>
                }
        }

        // No idea, probably safe to assume so
        <span class="cov0" title="0">return true</span>
}

type checker struct {
        runtime *Runtime
}

func (c *checker) Exists(name string) bool <span class="cov0" title="0">{
        return c.runtime.containerGraph.Exists("/" + name)
}</span>

// Generate a random and unique name
func generateRandomName(runtime *Runtime) (string, error) <span class="cov0" title="0">{
        return namesgenerator.GenerateRandomName(&amp;checker{runtime})
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package docker

import (
        "github.com/dotcloud/docker/engine"
        "github.com/dotcloud/docker/utils"
        "runtime"
)

func init() <span class="cov8" title="1">{
        engine.Register("version", jobVersion)
}</span>

func jobVersion(job *engine.Job) engine.Status <span class="cov0" title="0">{
        if _, err := dockerVersion().WriteTo(job.Stdout); err != nil </span><span class="cov0" title="0">{
                job.Errorf("%s", err)
                return engine.StatusErr
        }</span>
        <span class="cov0" title="0">return engine.StatusOK</span>
}

// dockerVersion returns detailed version information in the form of a queriable
// environment.
func dockerVersion() *engine.Env <span class="cov0" title="0">{
        v := &amp;engine.Env{}
        v.Set("Version", VERSION)
        v.Set("GitCommit", GITCOMMIT)
        v.Set("GoVersion", runtime.Version())
        v.Set("Os", runtime.GOOS)
        v.Set("Arch", runtime.GOARCH)
        // FIXME:utils.GetKernelVersion should only be needed here
        if kernelVersion, err := utils.GetKernelVersion(); err == nil </span><span class="cov0" title="0">{
                v.Set("KernelVersion", kernelVersion.String())
        }</span>
        <span class="cov0" title="0">return v</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
